[{"title":"前端面试之道","date":"2021-11-01T14:38:34.000Z","date_formatted":{"ll":"Nov 1, 2021","L":"11/01/2021","MM-DD":"11-01"},"updated":"2023-11-14T12:07:06.466Z","content":"前端面试之道-小册\n\n来源：https://gitee.com/orange88/juejin_book\n来源：前端面试之道\n\n\n一、目录\n\n小册使用指南： 点击查看\nJS 基础知识点及常考面试题（一）: 点击查看\nJS 基础知识点及常考面试题（二）: 点击查看\nES6 知识点及常考面试题: 点击查看\nJS 异步编程及常考面试题: 点击查看\n手写 Promise: 点击查看\nEvent Loop: 点击查看\nJS 进阶知识点及常考面试题: 点击查看\nJS 思考题: 点击查看\nDevTools Tips: 点击查看\n浏览器基础知识点及常考面试题: 点击查看\n浏览器缓存机制: 点击查看\n浏览器渲染原理: 点击查看\n安全防范知识点: 点击查看\n从 V8 中看 JS 性能优化: 点击查看\n性能优化琐碎事: 点击查看\nWebpack 性能优化: 点击查看\n实现小型打包工具: 点击查看\nReact 和 Vue 两大框架之间的相爱相杀: 点击查看\nVue 常考基础知识点: 点击查看\nVue 常考进阶知识点: 点击查看\nReact 常考基础知识点: 点击查看\nReact 常考进阶知识点: 点击查看\n监控: 点击查看\nUDP: 点击查看\nTCP: 点击查看\nHTTP 及 TLS: 点击查看\nHTTP/2 及 HTTP/3: 点击查看\n输入 URL 到页面渲染的整个流程: 点击查看\n设计模式: 点击查看\n常见数据结构: 点击查看\n常考算法题解析: 点击查看\nCSS 常考面试题资料: 点击查看\n如何写好一封简历: 点击查看\n面试常用技巧: 点击查看\n前方的路，让我们结伴同行: 点击查看\n\n","plink":"https://blog.jschef.com/Learning/5febc93b0929/"},{"title":"WebRTC实践","date":"2021-07-28T08:59:20.000Z","date_formatted":{"ll":"Jul 28, 2021","L":"07/28/2021","MM-DD":"07-28"},"updated":"2023-11-14T12:07:06.466Z","content":"【长文警告⚠️】本文内容涉及到了WebRTC涉及的协议讲解、相关服务器的搭建、WebRTC核心API学习，最后包含一个WenRTC音视频通话的小实例开发教程实践（含完整代码）。\n\nPPT讲解：https://pan.baidu.com/s/1TXrCi7lubkUGyhcIVz_Lhg 提取码: fm6h\n一、协议\n1.1 P2P通信原理与实现\n1.1.1 基本术语\n防火墙（Firewall）： 防火墙主要限制内网和公网的通讯，通常丢弃未经许可的数据包。防火墙会检测(但是不修改)试图进入内网数据包的IP地址和TCP/UDP端口信息。\n网络地址转换协议（NAT）： 用来给你的（私网）设备映射一个公网的IP地址的协议。一般情况下，路由器的WAN口有一个公网IP，所有连接这个路由器LAN口的设备会分配一个私有网段的IP地址（例如192.168.1.3）。私网设备的IP被映射成路由器的公网IP和唯一的端口，通过这种方式不需要为每一个私网设备分配不同的公网IP，但是依然能被外网设备发现。NAT不止检查进入数据包的头部，而且对其进行修改，从而实现同一内网中不同主机共用更少的公网IP（通常是一个）。\n基本NAT（Basic NAT）： 基本NAT会将内网主机的IP地址映射为一个公网IP，不改变其TCP/UDP端口号。基本NAT通常只有在当NAT有公网IP池的时候才有用。\n网络地址-端口转换器（NAPT）： 到目前为止最常见的即为NAPT，其检测并修改出入数据包的IP地址和端口号，从而允许多个内网主机同时共享一个公网IP地址。\n锥形NAT（Cone NAT）： 在建立了一对（公网IP，公网端口）和（内网IP，内网端口）二元组的绑定之后，Cone NAT会重用这组绑定用于接下来该应用程序的所有会话（同一内网IP和端口），只要还有一个会话还是激活的。 例如，假设客户端A建立了两个连续的对外会话，从相同的内部端点（10.0.0.1:1234）到两个不同的外部服务端S1和S2。Cone NAT只为两个会话映射了一个公网端点（155.99.25.11:62000）， 确保客户端端口的“身份”在地址转换的时候保持不变。由于基本NAT和防火墙都不改变数据包的端口号，因此这些类型的中间件也可以看作是退化的Cone NAT。\n12345678910111213141516171819    Server S1                                     Server S218.181.0.31:1235                              138.76.29.7:1235       |                                             |       |                                             |       +----------------------+----------------------+                              |  ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^  |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  |  v 155.99.25.11:62000 v      |      v 155.99.25.11:62000 v                              |                           Cone NAT                         155.99.25.11                              |  ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^  |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  |  v   10.0.0.1:1234    v      |      v   10.0.0.1:1234    v                              |                           Client A                        10.0.0.1:1234\n1.1.2 UDP打洞(UDP hole punching)\nP2P通信技术中被广泛采用的技术“UDP打洞”。UDP打洞技术依赖于通常防火墙和cone NAT允许正当的P2P应用程序在中间件中打洞且与对方建立直接链接的特性。\n在学习UDP打洞之前，我们先了解一下另外两种P2P通信技术。\n（1）中继（Relaying）\n中继是最可靠但效率最低的一种P2P通信技术，它的原理是通过一台服务器来中继转发不同客户端的数据。\n123456789                       Server S                          |                          |   +----------------------+----------------------+   |                                             | NAT A                                         NAT B   |                                             |   |                                             |Client A                                      Client B\n什么意思呢？就是我和你开视频，我和你的视频数据会直接被我们共同连接上的一台服务器接收，这台服务器会将你我的视频数据分别转发响应给我和你的客户端。这样服务器压力就很大，带宽需求也非常大，当仅仅只有两个客户端连接服务器开视频的话，服务器的带宽就至少是客户端带宽的两倍，CPU消耗同样也是。那么当同时视频通话的人很多了，那么服务器的压力难以想象。\n所以中继是一种效率很低的P2P通信技术。\n（2）逆向连接（Connection reversal）\n这种连接只有在两个通信端点中有一个不存在中间件的时候有效。\n例如，客户端A在NAT之后而客户端B拥有全局IP地址，如下图：\n123456789101112                            Server S                        18.181.0.31:1235                               |                               |        +----------------------+----------------------+        |                                             |      NAT A                                           |155.99.25.11:62000                                    |        |                                             |        |                                             |     Client A                                      Client B  10.0.0.1:1234                               138.76.29.7:1234　\n客户端A内网地址为10.0.0.1，且应用程序正在使用TCP端口1234。A和服务器S建立了一个连接，服务器的IP地址为18.181.0.31，监听1235端口。NAT A给客户端A分配了TCP端口62000，地址为NAT的公网IP地址155.99.25.11， 作为客户端A对外当前会话的临时IP和端口。因此S认为客户端A就是155.99.25.11:62000。而B由于有公网地址，所以对S来说B就是138.76.29.7:1234。\n当客户端B想要发起一个对客户端A的P2P链接时，要么链接A的外网地址155.99.25.11:62000，要么链接A的内网地址10.0.0.1:1234，然而两种方式链接都会失败。 链接10.0.0.1:1234失败自不用说，为什么链接155.99.25.11:62000也会失败呢？来自B的TCP SYN握手请求到达NAT A的时候会被拒绝，因为对NAT A来说只有外出的链接才是允许的。\n在直接链接A失败之后，B可以通过S向A中继一个链接请求，从而从A方向“逆向“地建立起A-B之间的点对点链接。\n现在很多P2P系统都实现了这种技术，但是这种技术有局限性，只有当其中一放客户端有公网IP的时候才能建立起连接。为什么现在很多P2P系统都实现了逆向连接技术，因为我们接下来要讲的UDP打洞技术，主要是依赖这种技术。\nUDP打洞正文开始：\n现在最多的网路连接情况是双方都是在内网下，都需要通过NAT进行地址转换，所以上面的逆向连接不适用，但是可以利用逆向连接技术进行改造。\n假设客户端A和客户端B的地址都是内网地址，且在不同的NAT后面。A、B上运行的P2P应用程序和服务器S都使用了UDP端口1234，A和B分别初始化了 与Server的UDP通信，地址映射如图所示:\n123456789101112                            Server S                        18.181.0.31:1234                               |                               |        +----------------------+----------------------+        |                                             |      NAT A                                         NAT B155.99.25.11:62000                            138.76.29.7:31000        |                                             |        |                                             |     Client A                                      Client B  10.0.0.1:1234                                 10.1.1.3:1234\n现在假设客户端A打算与客户端B直接建立一个UDP通信会话。如果A直接给B的公网地址138.76.29.7:31000发送UDP数据，NAT B将很可能会无视进入的 数据（除非是Full Cone NAT），因为源地址和端口与S不匹配，而最初只与S建立过会话。B往A直接发信息也类似。\n假设A开始给B的公网地址发送UDP数据的同时，给服务器S发送一个中继请求，要求B开始给A的公网地址发送UDP信息。\nA往B的输出信息会导致NAT A打开 一个A的内网地址与与B的外网地址之间的新通讯会话，B往A亦然。一旦新的UDP会话在两个方向都打开之后，客户端A和客户端B就能直接通讯， 而无须再通过引导服务器S了。\nUDP打洞技术有许多有用的性质。一旦一个的P2P链接建立，链接的双方都能反过来作为“引导服务器”来帮助其他中间件后的客户端进行打洞， 极大减少了服务器的负载。应用程序不需要知道中间件具体是什么（如果有的话），因为以上的过程在没有中间件或者有多个中间件的情况下 也一样能建立通信链路。\n还有一些特殊情况：当通信双方都在同一局域网，也就是两个客户端都在一个内网下呢？是不是可以降低NAT转换，直接在内网上连接呢？此外还有，当一些大型企业，内网中有多级NAT转换呢？这里已不再本文的讨论中了，详细可以看以下参考文章详细了解：\n\n参考文章：https://zhuanlan.zhihu.com/p/26796476\n\n学到这里，根据上面的原理是可以实现自己的一套程序和通信规则，但很多时候是需要对接第三方的协议，往往这个适配是比较麻烦的。因此就产生了标准化的通用规则（STUN、TURN、ICE），下面的几个章节将逐个介绍这些协议。\n1.2 STUN协议\nSTUN（STUN/RFC3489(废弃)，STUN/RFC5389）是P2P标准化通信规则（协议）之一。\n1.2.1 简介\nNAT的会话穿越功能Session Traversal Utilities for NAT (STUN) (缩略语的最后一个字母是NAT的首字母)是一个允许位于NAT后的客户端找出自己的公网地址，判断出路由器阻止直连的限制方法的协议。\nSTUN是一个C/S架构的协议，支持两种传输类型。一种是请求/响应（request/respond）类型，由客户端给服务器发送请求，并等待服务器返回响应；另一种是指示类型（indication transaction），由服务器或者客户端 发送指示，另一方不产生响应。对于请求/响应类型，允许客户端将响应和产生响应的请求连接起来； 对于指示类型，通常在debug时使用。我们主要了解请求/响应类型。\n1.2.2 通信过程\n客户端通过给公网的STUN服务器发送请求获得自己的公网地址信息，以及是否能够被（穿过路由器）访问。\n\n客户端A向服务器产生一个Request（STUN叔叔，你能告诉我我的ip是多少吗）\n服务器接收Request，检查报文是否合法，并生成Success响应或Error响应（A小朋友，你的ip是208.141.55.130:3255）\n\n\n1.3 TURN协议\nTURN（TURN/RFC5766）是P2P标准化通信规则（协议）之一，是对STUN的补充。\n1.3.1 简介\nTURN的全称为Traversal Using Relays around NAT (TURN) ，是STUN/RFC5389的一个拓展，主要添加了Relay功能。前面介绍的STUN协议处理的是市面上大多数的Cone NAT，但还有少量的设备使用的Symmetric NAT。因此传统的打洞方法不适用，为了保证这一部分设备能够建立通信，我们不得不通过中继（Relaying）的方法进行连接，这时就需要公网的服务器作为一个中继， 对来往的数据进行转发。这个转发的协议就被定义为TURN。这种情况会增加服务器负担，所以这是最坏的情况的通信解决方案。\nTURN服务器与客户端之间的连接都是基于UDP的，但是服务器和客户端之间可以通过其他各种连接来传输STUN报文, 比如TCP/UDP/TLS-over-TCP。客户端之间通过中继传输数据时候，如果用了TCP，也会在服务端转换为UDP，因此建议客户端使用 UDP来进行传输。至于为什么要支持TCP，那是因为一部分防火墙会完全阻挡UDP数据，而对于三次握手的TCP数据则不做隔离。\n1.3.2 通信过程\n客户端A向STUN服务器发送请求获取自己的公网地址，STUN服务器可以获取到客户端A的地址，但发现客户端A的使用的Symmetric NAT，因此STUN服务器告诉客户端A，我不能帮助你和客户端B建立连接，你们之间可以通过TURN进行连接。因此客户端A和客户端B同时去连接TURN服务器，通过TURN服务器进行中继连接。\n\n客户端A向STUN服务器产生一个Request（STUN叔叔，你能告诉我我的ip是多少吗）\nSTUN服务器响应（A小朋友，你的ip是208.141.55.130:3255，可是你的ip别人不能和你连接哦，你需要去找你TURN大伯，他是专门负责帮你连接）\n客户端A向TURN服务器发起请求（TURN大伯，STUN叔叔叫我来找你）\nTURN服务器响应（A小侄儿，我知道了，但是现在还没有其他小朋友找你哦，你可以在这附近逛一逛，每10分钟要给我报告一下你还在这附近哦，一有其他小朋友来找你我就通知你。）\n\n\n1.4 ICE协议\nTURN（ICE/RFC5245）是P2P标准化通信规则（协议）之一，提供了完整的NAT传输解决方案。\n\nSTUN、TURN都是工具类协议，只提供穿透NAT的功能。且TURN本身就是被设计为ICE/RFC5245的一部分\n\n1.4.1 简介\nICE的全称为Interactive Connectivity Establishment (ICE)，即交互式连接建立。在实际的网络当中，有很多原因能导致简单的从A端到B端直连不能如愿完成。这需要绕过阻止建立连接的防火墙，给你的设备分配一个唯一可见的地址（通常情况下我们的大部分设备没有一个固定的公网地址），如果路由器不允许主机直连，还得通过一台服务器转发数据。ICE通过使用STUN、TURN、NAT、SDP技术完成上述工作。(引用自：https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols)\nICE是一个用于在Offer/Answer模式下的NAT传输协议，主要用于UDP下多媒体会话的建立，其使用了STUN协议以及TURN 协议，同时也能被其他实现了Offer/Answer模型的的其他程序所使用，比如SIP(Session Initiation Protocol)。\n\n网络编程的ICE（Internate Communications Engine）：是一种用于分布式程序设计的网络通信中间件，本文指并非此ICE\n\n\n交互式连接ICE（Interactive Connectivity Establishment）：是一个允许你的浏览器和对端浏览器建立连接的协议框架。\n\n1.4.2 SDP会话描述\nICE信息的描述格式通常采用标准的SDP，其全称为Session Description Protocol (SDP) ，即会话描述协议。SDP不是一个真正的协议，而是一种数据格式，用于描述在设备之间共享媒体的连接。可以被其他传输协议用来交换必要的信息，如SIP和RTSP等。\nSDP格式：\nSDP由一行或多行UTF-8文本组成，每行以一个字符的类型开头，后跟等号（“ =”），然后是包含值或描述的结构化文本，其格式取决于类型。\nSDP会话描述包含了多行如下类型的文本:\n1&lt;type&gt;=&lt;value&gt;\n以给定字母开头的文本行通常称为“字母行”。例如，提供媒体描述的行的类型为“ m”，因此这些行称为“ m行”。\n1m=audio 49170 RTP/AVP 0\n&lt;type&gt;是大小写敏感的，其中一些行是必须要有的，有些是可选的，所有元素都必须以固定顺序给出。如下所示，其中可选的元素标记为* ：\n1234567891011121314151617181920212223242526272829会话描述:     v=  (protocol version)     o=  (originator and session identifier)     s=  (session name)     i=* (session information)     u=* (URI of description)     e=* (email address)     p=* (phone number)     c=* (connection information -- not required if included in          all media)     b=* (zero or more bandwidth information lines)     One or more time descriptions (&quot;t=&quot; and &quot;r=&quot; lines; see below)     z=* (time zone adjustments)     k=* (encryption key)     a=* (zero or more session attribute lines)     Zero or more media descriptions时间信息描述:     t=  (time the session is active)     r=* (zero or more repeat times)多媒体信息描述(如果有的话):     m=  (media name and transport address)     i=* (media title)     c=* (connection information -- optional if included at          session level)     b=* (zero or more bandwidth information lines)     k=* (encryption key)     a=* (zero or more media attribute lines)\n所有元素的type都为小写，并且不提供拓展.但是我们可以用a(attribute)字段来提供额外的信息。一个SDP描述的例子如下：\n123456789101112v=0o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5s=SDP Seminari=A Seminar on the session description protocolu=http://www.example.com/seminars/sdp.pdfe=j.doe@example.com (Jane Doe)c=IN IP4 224.2.17.12/127t=2873397496 2873404696a=recvonlym=audio 49170 RTP/AVP 0m=video 51372 RTP/AVP 99a=rtpmap:99 h263-1998/90000\n具体字段的type/value描述和格式可以参考RFC4566。\n1.4.3 Offer/Answer模型\nSDP用来描述多播主干网络的会话信息，但是并没有具体的交互操作细节是如何实现的，因此RFC3264 定义了一种基于SDP的Offer/Answer模型。\n在该模型中，会话参与者的其中一方生成一个SDP报文构成offer， 其中包含了一组offer希望使用的多媒体流和编解码方法，以及offer用来接收改数据的IP地址和端口信息。\noffer传输到会话的另一端(称为answer)，由这一端生成一个answer，即用来响应对应offer的SDP报文。\nanswer中包含不同offer对应的多媒体流，并指明该流是否可以接受。\n\n1.4.4 ICE工作流程\n一个典型的ICE工作环境如下，有两个端点A和B，都运行在各自的NAT之后(他们自己也许并不知道)，NAT的类型和性质也是未知的。L和R通过交换SDP信息在彼此之间建立多媒体会话，通常交换通过一个SIP服务器完成：\n1234567891011121314151617181920                 +-----------+                 |    SIP    |+-------+        |    Srvr   |         +-------+| STUN  |        |           |         | STUN  || Srvr  |        +-----------+         | Srvr  ||       |        /           \\         |       |+-------+       /             \\        +-------+               /&lt;- Signaling -&gt;\\              /                 \\         +--------+          +--------+         |  NAT   |          |  NAT   |         +--------+          +--------+           /                       \\          /                         \\         /                           \\     +-------+                    +-------+     | Agent |                    | Agent |     |   A   |                    |   B   |     |       |                    |       |     +-------+                    +-------+\nICE的基本思路是，每个终端都有一系列传输地址(包括传输协议，IP地址和端口)的候选，可以用来和其他端点进行通信。其中可能包括：\n\n直接和网络接口联系的传输地址(host address)\n经过NAT转换的传输地址,即反射地址(server reflective address)\nTURN服务器分配的中继地址(relay address)\n\n\n通过之前的学习，我们可以了解到每个终端的情况是比较复杂的（有的终端可能同时连着wifi和网线，有多个内网地址），所有每个终端有多种可以连接的方案。\n\n获取到这一系列传输地址后，会以一定优先级将地址排序。按照优先级和其他终端的传输地址进行组合检测连接可用性（连接性检查：Connectivity Checks）。\n两端连接性检查，是一个4次握手过程:\n1234567A                        B-                        -STUN request -&gt;                  \\  A&#x27;s          &lt;- STUN response       /  check           &lt;- STUN request       \\  B&#x27;sSTUN response -&gt;                 /  check\n连接性检查详细过程：\n\n\n为中继候选地址生成许可(Permissions)；\n\n\n从本地候选往远端候选发送Binding Request：\n在Binding请求中通常需要包含一些特殊的属性，以在ICE进行连接性检查的时候提供必要信息：\n\nPRIORITY 和 USE-CANDIDATE：优先级和候选\nICE-CONTROLLED和ICE-CONTROLLING：标识本端是受控方还是主控方（offer生成方）。\n生成Credential：STUN短期身份验证\n\n\n\n处理Response：\n当收到Binding Response时，终端会将其与Binding Request相联系，通常生成事务ID。随后将会将此事务ID与候选地址对进行绑定。\n\n成功响应：要同时满足三个条件（STUN传输产生一个Success Response；response的源IP和端口等于Binding Request的目的IP和端口；response的目的IP和端口等于Binding Request的源IP和端口）\n失败响应：487错误，并将检测地址状态设置为Waiting\n\n\n\n以上仅对协议作了简单的介绍，具体服务器程序实现可参考：https://github.com/evilpan/TurnServer\n1.5 经典WebRTC连接建立流程\n通过前面的协议了解学习，相信大家已经对WebRTC的底层连接流程有了一个模糊的意思，这里有张图展现了具体的连接流程。\n\n\n引用自：https://aggresss.blog.csdn.net/article/details/106832965\n\n二、服务器搭建\n2.1 STUN/TURN服务器【可跳过】\n\n网上有公用的stun服务器，本节可直接跳过。\n\nSTUN服务器已有现成项目：https://github.com/coturn/coturn\n以下是在ubuntu上的安装和配置：\n2.1.1 安装coturn\n可以克隆github上的源码编译安装，在ubuntu里有直接的安装包\n12apt-get -y updateapt-get -y install coturn\n安装完毕后，先关闭coturn服务：\n1systemctl stop coturn\n2.1.2 配置coturn\n(1) 允许turnserver\n首先需要允许turnserver，打开/etc/default/coturn文件，将注释去掉：\n1vim /etc/default/coturn\n取消注释后如下：\n1TURNSERVER_ENABLED=1\n(2) 获取ip和SSL\n首选需要获取一下自己的内网ip以及网卡:\n1ifconfig\n生成SSL证书:\n1apt install openssl\n1openssl req -x509 -newkey rsa:2048 -keyout /etc/turn_server_pkey.pem -out /etc/turn_server_cert.pem -days 99999 -nodes \n(3) 配置\n接下来正式改配置文件/etc/turnserver.conf，改之前先将原文件备份一个：\n1mv /etc/turnserver.conf /etc/turnserver.conf.bat\n然后新建配置文件：\n1vim /etc/turnserver.conf\n然后复制以下配置：\n123456789101112131415161718192021222324server-name=turn.webrtc.zzboy.cnrealm=turn.webrtc.zzboy.cnfingerprintrelay-device=eth0   #与前ifconfig查到的网卡名称一致listening-ip=192.168.0.186    #内网IPlistening-port=3478tls-listening-port=5349relay-ip=192.168.0.186external-ip=121.36.105.109    #公网IPrelay-threads=50lt-cred-mechno-cliverbosecert=/etc/turn_server_cert.pempkey=/etc/turn_server_pkey.pem#pidfile=/var/run/turnserver.pidmin-port=49152max-port=65535user=jun:123456    #用户名密码，创建IceServer时用\n2.1.3 测试\n工具：Trickle ICE\n点击打开上面的工具\n2.2 Nodejs构建信令服务器(Signal Server)\n信令服务器我直接使用的一个开源项目：https://github.com/qdgx/WebRtcRoomServer\n其实信令服务器已经涉及到实战了，这里就不讲具体实现，这里只先部署。\n单纯地看，信令服务器其实可以算作是一个后端项目，我们这里部署也只是对该项目进行服务器部署。这里我使用的这个开源项目是使用node.js开发的，因此部署步骤和node.js部署步骤相差无异。\n以下是我在ubuntu上的安装和配置：\n2.2.1 安装node环境\n(1) 更新环境，安装curl、git\n12apt-get updateapt-get install -y curl git\n(2) 安装node.js\n先去官网https://nodejs.org/，查看最新稳定长期支持版，发现最新稳定版是14.15.3 LTS，node.js的每个大版本号都有相对应的源，比如这里的14.15.3版本的源是 https://deb.nodesource.com/setup_14.x\n所以在终端执行：\n1curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -\n然后安装node.js\n1apt-get install nodejs\nnode -v  和 npm -v 查看node和npm是否安装成功\n2.2.2 克隆项目，安装依赖\n进入用户目录，克隆项目：\n1cd ~/ &amp;&amp; git clone https://github.com/qdgx/WebRtcRoomServer.git\n安装依赖：\n12cd ~/WebRtcRoomServernpm i\n启动服务：\n1node app.js\n在浏览器打开以下地址，测试一下是否访问：\nhttps://你服务器外网地址:8443\n只要浏览器提示该页面存在风险，即表示项目已生效，点击高级，选择接受风险继续访问即可。（为什么提示风险：因为这个项目的证书是自签名证书）\n\n如果无法访问，请检查服务器安全组是否打开了TCP和UDP协议的8443端口，有些服务器开端口需要在服务器上那配置安全组，比如阿里云ECS和华为云。\n2.2.3 pm2管理node服务\n直接用node app.js运行项目，在关闭终端后，node项目也会随之被关闭，因此需要使用额外的工具来保持node服务一直开启。\n安装pm2：\n1npm install pm2@latest -g\n启动服务：\n1pm2 start app.js --name signal-server --watch\n\nname：给应用命名，可以不管\nwatch：相当于热更新，应用文件更新后会重启应用\n\n有关pm2的使用，可以百度查询一下，也可以参考本人之前写的一篇文章：https://www.jschef.com/Learning/f360ef90efef\n三、API学习\n以下主要介绍下一章节实战开中需要到的常用接口，完整的接口学习可查看对应官方文档。\n3.1 socket.io\n\n官方文档：https://socket.io/docs/v3/\n\n\n中文w3chool：https://www.w3cschool.cn/socket/\n\nSocket是一种全双工通信,当客户端和服务端建立起连接后，如果不主动断开，双方可以一直互相发送消息，适合于双方频繁通信的场景，也是支持服务端主动推送的一种通信方式。WebSocket是Html5推出的前端可以直接使用的API，不过目前项目中用的还是socket.io比较多。socket.io在浏览器环境下封装了WebSocket, 可以给开发者带来更好的体验，在功能上也更完善。\nsocket.io主要使用两个方法：\n\n\nemit(description: string, data: any：监听事件；description是标识；data是需要发送的数据。\n\n\non(description: string, callback: function：监听事件；description表示监听的标识；callback是监到事件后处理方法，参数是emit发送的数据。\n\n\n通俗说，一个就是发送，一个是接收。发送方法需要指定谁(description)来接收；接收方法找到对应description接收。\n3.1.1 服务器端\n(1) 安装\n1npm install socket.io\n(2) 初始化\n12345678910const httpServer = require(&quot;http&quot;).createServer(); // 创建http服务// 使用socket.io监听http服务const socketIO = require(&quot;socket.io&quot;);const io = socketIO.listen(httpServer);// 也可以使用如下方式const io = require(&quot;socket.io&quot;)(httpServer, &#123;  // options配置项&#125;);\n配置项：是初始配置socket.io的一些参数，我们使用默认的接口，如需要配置，可以看文档了解具体配置项：https://socket.io/docs/v3/server-api/#new-Server-httpServer-options\n根据WebRTC安全策略，我们需要使用https，因此，比较完整的初始化代码为：\n1234567891011const fs = require(&#x27;fs&#x27;);const server = require(&#x27;https&#x27;).createServer(&#123;  key: fs.readFileSync(&#x27;/tmp/key.pem&#x27;),  cert: fs.readFileSync(&#x27;/tmp/cert.pem&#x27;)&#125;);const options = &#123; /* ... */ &#125;;const io = require(&#x27;socket.io&#x27;)(server, options);io.on(&#x27;connection&#x27;, socket =&gt; &#123; /* ... */ &#125;);server.listen(3000);\n(3) 方法\nio.on(‘connection’, fn) ：监听客户端连接\n从上面初始化代码不难看出，socket.io第一个方法应该io.on('connection', fn)。\nconnection是保留description，当有客户端连接上当前服务器时，就会触发。\n我们需要在其回调中处理相关业务：\n1234567io.on(&#x27;connection&#x27;, socket =&gt; &#123;  // 监听断开连接  socket.on(&#x27;disconnect&#x27;, reason =&gt; console.log(reason)) // socket断开监听，disconnect也是保留字段  \t// 其他业务监听  socket.on(&#x27;join&#x27;, data =&gt; console.log(`欢迎$&#123;data.name&#125;进入直播间`));&#125;);\nsocket.on(‘disconnect’, fn) ：监听客户端断开连接\n123socket.on(&#x27;disconnect&#x27;, reason =&gt; &#123;  console.log(reason); // 断开原因有很多，可能是用户主动断开，也可能是浏览器直接关闭等&#125;)\nsocket.emit() : 发送信息\n3.1.2 客户端\n3.2 音视频相关API\n3.2.1 navigator.mediaDevices\n浏览器API，可以通过该浏览器API获取用户媒体设备，通常只会用到一个方法：getUserMedia(options)，调用该方法时，浏览器会弹出请求音频或视频的权限，用户同意授权过后，即可获取到音视频流。\n1234567navigator.mediaDevices.getUserMedia(options).then(function(stream) &#123;  /* use the stream */&#125;).catch(function(err) &#123;  /* handle the error */&#125;);\n需要注意：navigator的mediaDevices属性需要在https环境下才会有，这是浏览器的限制。\noptions: 配置项\n一般可直接设置为：&#123; audio: true, video: true &#125;，表示为获取音频和视频。\n12345678910navigator.mediaDevices.getUserMedia(&#123;  audio: true,  video: true&#125;).then(function(stream) &#123;  /* use the stream */&#125;).catch(function(err) &#123;  /* handle the error */&#125;);\n视频方面，也可以准确定义视频画面的宽高：\n12345678910navigator.mediaDevices.getUserMedia(&#123;  audio: true,  video: &#123; width: 1280, height: 720 &#125; // 当定义宽高是，视频算是true，请求视频权限&#125;).then(function(stream) &#123;  /* use the stream */&#125;).catch(function(err) &#123;  /* handle the error */&#125;);\n其他更多配置可参考：https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n3.2.2 video\n(1) video标签\n123&lt;video src=&quot;path/to/movie.mp4&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持 video 标签。&lt;/video&gt;\n属性：\n\nautoplay: 如果出现该属性，则视频在就绪后马上播放\ncontrols：如果出现该属性，则向用户显示控件，比如播放按钮\nloop：如果出现该属性，则当媒介文件完成播放后再次开始播放\nmuted：规定视频的音频输出应该被静音\nposter：规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像\npreload：如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性\nsrc：要播放的视频的 URL\nwidth：设置视频播放器的宽度，单位px\nheight：设置视频播放器的高度，单位px\n\n我们在进行音视频通话时，通常\n**本地视频（我方视频）**应如下：\n123&lt;video id=&quot;local&quot; muted autoplay&gt;您的浏览器不支持 video 标签。&lt;/video&gt;\n本地视频静音播放，因为我们无需我们自己发出的声音，因为我们到时候视频资源是从设备直接实时获取视频流，因此无需设置src，并且设置autoplay，可以让我们获取到视频流直接播放。\n**远程视频（对方视频）**应如下：\n123&lt;video id=&quot;remote&quot; poster=&quot;xxx&quot; autoplay&gt;您的浏览器不支持 video 标签。&lt;/video&gt;\n远程视频同样设置autoplay属性，让接收到的视频流直接播放。另外可设置一个poster属性，可以在呼叫过程中或者被呼叫时，让页面显示呼叫中或者是显示对方头像肖像等，不然页面全黑会显得很尴尬。\n(2) video对象\n使用音视频通话，我们控制音视频的播放基本通过js实现的，就连前面介绍的video标签一般都是通过js创建。video对象有很多属性，我这里只简单介绍部分属性，能基本满足WebRTC音视频通话。\n我们要实现音视频实时通讯，传递的数据是音视频流，音视频流怎么让video播放出来呢？看看下面代码：\n1234567891011121314151617181920212223/** * 视频流绑定到video节点展示 * @param &#123;dom&#125; video video节点 * @param &#123;obj&#125; stream 视频流 */const pushStreamToVideo = (video, stream) =&gt; &#123;  video.srcObject = stream;&#125;// 获取video节点const domLocalVideo = $(&#x27;#local&#x27;);// 调用摄像头navigator.mediaDevices.getUserMedia(&#123;  audio: true,  video: true&#125;).then(stream =&gt; &#123;  pushStreamToVideo(domLocalVideo[0], stream); // 实时显示&#125;).catch(err =&gt; &#123;  alert(`getUserMedia() error: $&#123;err.name&#125;`)&#125;);\n不难看出，video对象有个srcObject的属性，初始时该属性值是null，将我们获取到音视频流直接赋值给该属性，我们的video标签就可以实时播放了。上面这个例子是调用本地摄像头并展示到一个id=local的video标签上，需要在https上就可以正常运行了。\n我们如何关闭视频呢？\n方法一：简单粗暴，关闭页面或者关闭浏览器。（你会让用户这么干么？）\n方法二：使用MediaStream.getTracks()，获取到所有媒体流轨道，每条轨道调用一个方法stop()，就可以关闭当前流，摄像头也会停止录制。\n12345678/** * 关闭摄像头 * @param &#123;dom&#125; video video节点 */const closeCamera = video =&gt; &#123;  video.srcObject.getTracks()[0].stop(); // audio  video.srcObject.getTracks()[1].stop(); // video&#125;\n音频是第一条轨道，视频是第二条轨道，两个同时关闭即可。\n3.3 WebRTC\n\n官方文档（不推荐）：https://www.w3.org/TR/webrtc/#peer-to-peer-connections\n\n\n官方文档中文翻译（不推荐）：https://github.com/RTC-Developer/WebRTC-Documentation-in-Chinese/tree/master/resource\n\n\nMDN Web Docs（推荐）：https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API\n\n3.3.1 RTCPeerConnection\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/\n\nRTCPeerConnection是浏览器之间点对点连接的核心API，用于处理对等体之间流数据的稳定和有效通信，\n1const pc = new RTCPeerConnection(serverConfig);\nserverConfig包含iceServers参数，它包含有关STUN和TURN服务器相关信息数组，在查找ICE的时候候选使用。可以在网上找一些公共的STUN服务器，也可以使用前面章节我们自己通过coturn搭建的STUN服务器。\n123456789101112const serverConfig = &#123;  iceServers: [    &#123;      urls: &#x27;stun:stun.xten.com&#x27;    &#125;,    &#123;      urls: &#x27;stun:你的服务器ip:3478&#x27;, // 见2.1服务器搭建      username: &#x27;用户名&#x27;,      credential: &#x27;密码&#x27;    &#125;  ]&#125;\n(1) onicecandidate = eventHandler\n作用：监听RTCPeerConnection实例上发生icecandidate事件，该函数会返回ICE协商结果，我们需要将结果发送给信令服务器，交由信令服务器转发给对方。\n1234567pc.onicecandidate = event =&gt; &#123;  if (event.candidate) &#123;    sendCandidateToRemotePeer(event.candidate);  &#125; else &#123;    /* there are no more candidates coming during this negotiation */  &#125;&#125;;\n**(2) ontrack = eventHandler **\n作用：监听RTCPeerConnection实例上接收到远程的数据流，该函数可获取到对端的媒体流。\n123pc.ontrack = event =&gt; &#123;  document.getElementById(&quot;received_video&quot;).srcObject = event.streams[0];&#125;;\n(3) addTrack(track, stream…)\n作用：设置轨道，该轨道将会在连同后传输到对端。\n123456async openCall(pc) &#123;  const gumStream = await navigator.mediaDevices.getUserMedia(&#123;video: true, audio: true&#125;);  for (const track of gumStream.getTracks()) &#123;    pc.addTrack(track);  &#125;&#125;\nMDN不建议使用addStream()\n(3) removeTrack(sender)\n作用：删除轨道，删除已添加的轨道，用于挂断的时候\n1234567891011var pc, sender;navigator.getUserMedia(&#123;video: true&#125;, function(stream) &#123;  pc = new RTCPeerConnection();  var track = stream.getVideoTracks()[0];  sender = pc.addTrack(track, stream);&#125;);document.getElementById(&quot;closeButton&quot;).addEventListener(&quot;click&quot;, function(event) &#123;  pc.removeTrack(sender);  pc.close();&#125;, false);\n不建议的：onremovestream\n(5) setLocalDescription()/setRemoteDescription()\nsetLocalDescription(sessionDescription)：\n设置本地offer，将自己的描述信息加入到PeerConnection中，参数类型：RTCSessionDescription（见下一小节 3.2.2 RTCSessionDescription）\nsetRemoteDescription(sessionDescription)：\n设置远端的answer，将对方的描述信息加入到PeerConnection中，参数类型：RTCSessionDescription（见下一小节 3.2.2 RTCSessionDescription）\n\n通俗说：Alice为了和Bob建立合作关系(连接)，Alice我把拟好了一份合同，并签字了，我这里先保留扫描版，纸质合同通过快递(SDP)给你了，你通过快递(SDP)拿到合同后，先签字确认，这时候纸质合同上都有我们双方的签名了，但我这边还没有你的签名。你保存一下扫描版，然后通过快递把纸质再给我发回来，我拿到快递后，我也保存一下扫描版。这样，你我双放都有双方签名的扫描版合同。合同开始生效！\n(6) createOffer()/createAnswer()\ncreateOffer([options])：\n创建一个offer，表示我方的请求。通常在WebRTC通信中，我们会请求对方接收我们的音频和视频数据。\n1234567const offerOptions = &#123;  offerToReceiveAudio: true, // 请求接收音频  offerToReceiveVideo: true, // 请求接收视频&#125;,pc.createOffer(offerOptions)        .then(offer =&gt; onCreateOfferSuccess(offer.sdp))        .catch(error =&gt; onCreateOfferError());\ncreateAnswer([options])：\n创建一个answer，回应对方offer。answer也是有offer作用的，在回应的时候，表示答应你，并向你请求。\n打个比方：A向B表白，请求B做A的女朋友。如果B接受了，表示B成了A女朋友。同时，这也有另外一层含义，表示B有请求：请A做我的男朋友。\n1234567const answerOptions = &#123;  offerToReceiveAudio: true, // 请求接收音频  offerToReceiveVideo: true, // 请求接收视频&#125;,pc.createAnswer(answerOptions)        .then(answer =&gt; onCreateAnswerSuccess(answer.sdp))        .catch(error =&gt; onCreateAnswerError());\n3.3.2 RTCSessionDescription\n用于生成Offer/Answer协商过程中SDP协议的相关描述。\n1new RTCSessionDescription(rtcDescription)\nrtcDescription只有两个属性：type，sdp\n\ntype只能设置：‘answer’，‘offer’，‘pranswer’，‘rollback’；\nsdp是标准的SDP会话描述（可由createOffer/createAnswer生成）\n\n3.3.3 RTCIceCandidate\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidate\nhttps://blog.51cto.com/zhangjunhd/25481\n\n用于建立ICE连接。通常我们不会手动去实例化一个RTCIceCandidate对象，在前面3.3.1 RTCPeerConnection中的onicecandidate事件回调就是一个RTCIceCandidate对象，我们只需要了解其中几个属性即可。\n\ncandidate: 用于连接性检测的对象\nsdpMid: candidate的媒体流的识别标签\nsdpMLineIndex: candidate的媒体流的相关联的SDP描述索引号\naddress: 本机IP地址\nrelatedAddress: 中继IP\nport: 本机端口\nrelatedPort: 中继端口\ncomponent: 候选协议，只有两种情况：RTP(Real-Time Transport Protocol)， RTCP(Real-Time Transport Control Protocol)\nfoundation: 来自于STUN服务器的唯一标识符\npriority: 优先级\ntcpType: 如果使用的TCP协议，这个属性及表示TCP的状态\ntype: RTCIceCandidateType类型\nusernameFragment: ice-ufrag片段，用于生成ice-pwd，同一ICE进程的连接都将使用的是同一个片段。\n\n四、实战开发\n前面基本上已经列举了大部分基础知识，现在开始运用起来。\n本章实战开发，是开发一个 web实时音视频聊天室 ：输入相同房间号，即可加入聊天室，进行视频聊天。\n主要有两个项目，前端界面(页面+WebRTC+socket.io)，后端信令服务器控制转发(Express+socket.io)。\n整个项目完整代码：https://github.com/Chef5/WebRTC-demo\n4.1 环境准备\n\nanywhere:  npm i -g anywhere\n\n4.2 信令服务器\n因为信令服务器代码结构比较简单，咱们先开发信令服务器。观察1.5 经典WebRTC连接建立流程，不难发现，信令服务器主要需要实现：转发offer、转发answer、转发candidate的三大核心功能。此外，我们开发聊天室，还需要：创建聊天室、退出聊天室的功能。\n\n4.2.1 搭建项目\n（1）创建一个文件夹signal-server，在目录下创建两个文件：\npackage.json\n1234567891011121314&#123;  &quot;name&quot;: &quot;signal-server&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;author&quot;: &quot;Patrick Jun&quot;,  &quot;description&quot;: &quot;A webRTC signal server&quot;,  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;node app.js&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;express&quot;: &quot;^4.17.1&quot;,    &quot;express-session&quot;: &quot;^1.17.1&quot;,    &quot;socket.io&quot;: &quot;^2.3.0&quot;  &#125;&#125;\napp.js\n1234567891011121314151617181920212223242526const https = require(&#x27;https&#x27;);  // https服务const fs = require(&#x27;fs&#x27;);        // fsconst socketIO = require(&#x27;socket.io&#x27;);//读取密钥和签名证书const options = &#123;  key: fs.readFileSync(&#x27;keys/server_key.pem&#x27;),  cert: fs.readFileSync(&#x27;keys/server_crt.pem&#x27;),&#125;// 构建https服务器const apps = https.createServer(options);const SSL_PORT = 8443;apps.listen(SSL_PORT);// 构建signal serverconst io = socketIO.listen(apps);// socket监听连接io.sockets.on(&#x27;connection&#x27;, (socket) =&gt; &#123;  console.log(&#x27;连接建立&#x27;);  // 之后所有业务处理，写在这里面&#125;);\n（2）创建证书\n在项目文件夹下，创建一个文件夹keys，然后开始生成自签名证书：\nlinux环境下：\n1openssl req -x509 -newkey rsa:2048 -keyout ./keys/server_key.pem -out ./keys/server_crt.pem -days 99999 -nodes \nwindows下：参考 https://letsencrypt.org/zh-cn/docs/certificates-for-localhost/\n修改app.js，将秘钥和签名证书的路径改为你电脑中的绝对路径，例如：\n12345//读取密钥和签名证书const options = &#123;  key: fs.readFileSync(&#x27;D://signal-server/keys/server_key.pem&#x27;),  cert: fs.readFileSync(&#x27;D://signal-server/keys/server_crt.pem&#x27;),&#125;\n（3）运行\n在项目根目录下，安装依赖：\n1npm i\n然后，启动：\n1node app.js\n打开浏览器，访问：https://localhost:8443\n访问时，浏览器会提示不安全的访问，这个时候，直接敲键盘：thisisunsafe 即可继续访问。当看到浏览器地址栏继续一直在请求中，那么就表示项目成功运行。\n4.2.2 房间功能\n房间功能主要包括：创建/加入房间、退出房间。\n业务处理，都放在连接成功后的回调函数里。\n（1）创建房间\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// socket监听连接io.sockets.on(&#x27;connection&#x27;, (socket) =&gt; &#123;  console.log(&#x27;连接建立&#x27;);    // 创建/加入房间  socket.on(&#x27;createAndJoinRoom&#x27;, (message) =&gt; &#123;    const &#123; room &#125; = message;    console.log(&#x27;Received createAndJoinRoom：&#x27; + room);    // 判断room是否存在    const clientsInRoom = io.sockets.adapter.rooms[room];    const numClients = clientsInRoom ? Object.keys(clientsInRoom.sockets).length : 0;    console.log(&#x27;Room &#x27; + room + &#x27; now has &#x27; + numClients + &#x27; client(s)&#x27;);    if (numClients === 0) &#123;      // room 不存在 不存在则创建（socket.join）      // 加入并创建房间      socket.join(room);      console.log(&#x27;Client ID &#x27; + socket.id + &#x27; created room &#x27; + room);      // 发送消息至客户端 [id,room,peers]      const data = &#123;        id: socket.id, //socket id        room: room, // 房间号        peers: [], // 其他连接      &#125;;      socket.emit(&#x27;created&#x27;, data);    &#125; else &#123;      // room 存在      // 加入房间中      socket.join(room);      console.log(&#x27;Client ID &#x27; + socket.id + &#x27; joined room &#x27; + room);            // joined告知房间里的其他客户端 [id,room]      io.sockets.in(room).emit(&#x27;joined&#x27;, &#123;        id: socket.id, //socket id        room: room, // 房间号      &#125;);      // 发送消息至客户端 [id,room,peers]      const data = &#123;        id: socket.id, //socket id        room: room, // 房间号        peers: [], // 其他连接      &#125;;      // 查询其他连接      const otherSocketIds = Object.keys(clientsInRoom.sockets);      for (let i = 0; i &lt; otherSocketIds.length; i++) &#123;        if (otherSocketIds[i] !== socket.id) &#123;          data.peers.push(&#123;            id: otherSocketIds[i],          &#125;);        &#125;      &#125;      socket.emit(&#x27;created&#x27;, data);    &#125;  &#125;);  &#125;);\n（2）退出房间\n在加入房间监听后面，继续添加：\n12345678910111213141516// 退出房间，转发exit消息至room其他客户端 [from,room]socket.on(&#x27;exit&#x27;, (message) =&gt; &#123;  console.log(&#x27;Received exit: &#x27; + message.from + &#x27; message: &#x27; + JSON.stringify(message));  const &#123; room &#125; = message;  // 关闭该连接  socket.leave(room);  // 转发exit消息至room其他客户端  const clientsInRoom = io.sockets.adapter.rooms[room];  if (clientsInRoom) &#123;    const otherSocketIds = Object.keys(clientsInRoom.sockets);    for (let i = 0; i &lt; otherSocketIds.length; i++) &#123;      const otherSocket = io.sockets.connected[otherSocketIds[i]];      otherSocket.emit(&#x27;exit&#x27;, message);    &#125;  &#125;&#125;);\n还有一种情况，当socket连接异常断开时，也需要退出房间：\n12345678910// socket关闭socket.on(&#x27;disconnect&#x27;, function(reason)&#123;  const socketId = socket.id;  console.log(&#x27;disconnect: &#x27; + socketId + &#x27; reason:&#x27; + reason );  const message = &#123;    from: socketId,    room: &#x27;&#x27;,  &#125;;  socket.broadcast.emit(&#x27;exit&#x27;, message);&#125;);\n4.2.3 转发功能\n转发功能有：转发offer、转发answer、转发candidate\n（1）转发offer\n123456789101112// 转发offer消息至room其他客户端 [from,to,room,sdp]socket.on(&#x27;offer&#x27;, (message) =&gt; &#123;  // const room = Object.keys(socket.rooms)[1];  console.log(&#x27;收到offer: from &#x27; + message.from + &#x27; room:&#x27; + message.room + &#x27; to &#x27; + message.to);  // 根据id找到对应连接  const otherClient = io.sockets.connected[message.to];  if (!otherClient) &#123;    return;  &#125;  // 转发offer消息至其他客户端  otherClient.emit(&#x27;offer&#x27;, message);&#125;);\n（2）转发answer\n123456789101112// 转发answer消息至room其他客户端 [from,to,room,sdp]socket.on(&#x27;answer&#x27;, (message) =&gt; &#123;  // const room = Object.keys(socket.rooms)[1];  console.log(&#x27;收到answer: from &#x27; + message.from + &#x27; room:&#x27; + message.room + &#x27; to &#x27; + message.to);  // 根据id找到对应连接  const otherClient = io.sockets.connected[message.to];  if (!otherClient) &#123;    return;  &#125;  // 转发answer消息至其他客户端  otherClient.emit(&#x27;answer&#x27;, message);&#125;);\n（3）转发candidate\n1234567891011// 转发candidate消息至room其他客户端 [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]]socket.on(&#x27;candidate&#x27;, (message) =&gt; &#123;  console.log(&#x27;收到candidate: from &#x27; + message.from + &#x27; room:&#x27; + room + &#x27; to &#x27; + message.to);  // 根据id找到对应连接  const otherClient = io.sockets.connected[message.to];  if (!otherClient) &#123;    return;  &#125;  // 转发candidate消息至其他客户端  otherClient.emit(&#x27;candidate&#x27;, message);&#125;);\n4.2.4 完整代码\nhttps://github.com/Chef5/WebRTC-demo/tree/main/signal-server\n4.3 前端\n前端可以分为三大功能：音视频设备控制和音视频显示控制、Offer/Answer沟通、ICE连接。\n\n4.3.1 搭建项目\n（1）创建一个文件夹webrtc-client，在目录下创建一个index.html文件，创建一个目录`js\n123|- webrtc-client/   |- js/   |- index.html\n（2）在js目录下创建几个文件，并在从网上下载socket.io.js和jquery.min.js文件\n12345678|- webrtc-client/   |- js/      |- config.js      |- sdk.js      |- main.js      |- socket.io.js  // 自行从网上下载      |- jquery.min.js // 自行从网上下载   |- index.html\n（3）代码\nindex.html\n123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;    &lt;title&gt;WebRtc视频通话demo&lt;/title&gt;    &lt;style&gt;      video &#123;        background-color: bisque;      &#125;    &lt;/style&gt;    &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;js/socket.io.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;js/config.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;js/sdk.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; id=&quot;room&quot; value=&quot;1&quot; placeholder=&quot;输入房间号&quot; /&gt;    &lt;button id=&quot;connect&quot;&gt;连接&lt;/button&gt;    &lt;button id=&quot;logout&quot;&gt;挂断&lt;/button&gt;    &lt;br/&gt;    &lt;h3&gt;本地视频&lt;/h3&gt;    &lt;video id=&quot;localVideo&quot; style=&#x27;width:200px;height:200px;&#x27; autoplay muted&gt;&lt;/video&gt;    &lt;br/&gt;        &lt;h3&gt;远程视频&lt;/h3&gt;    &lt;div id=&#x27;remoteDiv&#x27;&gt;&lt;/div&gt;    &lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\nconfig.js\n12345678910111213141516// WebRTC配置文件const THSConfig = &#123;  // 信令服务器  signalServer: &#x27;wss://localhost:8443&#x27;,  // Offer/Answer模型请求配置  offerOptions: &#123;    offerToReceiveAudio: true, // 请求接收音频    offerToReceiveVideo: true, // 请求接收视频  &#125;,  // ICE服务器  iceServers: &#123;    iceServers: [      &#123; urls: &#x27;stun:stun.xten.com&#x27; &#125;, // Safri兼容：url -&gt; urls    ]  &#125;&#125;\n4.3.2 兼容预处理\n因为部分web API在不同浏览器有不同的名称或者属性，因此需要处理兼容，以下是兼容代码，预先定义一下。\n编辑sdk.js：\n12345678910// 兼容处理const PeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;const SessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;const GET_USER_MEDIA = navigator.getUserMedia ? &quot;getUserMedia&quot; :                     navigator.mozGetUserMedia ? &quot;mozGetUserMedia&quot; :                     navigator.webkitGetUserMedia ? &quot;webkitGetUserMedia&quot; : &quot;getUserMedia&quot;;const v = document.createElement(&quot;video&quot;);const SRC_OBJECT = &#x27;srcObject&#x27; in v ? &quot;srcObject&quot; :                 &#x27;mozSrcObject&#x27; in v ? &quot;mozSrcObject&quot; :                 &#x27;webkitSrcObject&#x27; in v ? &quot;webkitSrcObject&quot; : &quot;srcObject&quot;;\n4.3.3 音视频控制\n音视频控制主要分打开关闭摄像头，视频流绑定到video标签，其实这一节前面3.2 音视频相关API已经学习过了，这里直接给出代码。\n接着编辑sdk.js\n12345678910111213141516171819202122232425262728/** * 启动摄像头 */const openCamera = () =&gt; &#123;  return navigator.mediaDevices[GET_USER_MEDIA](&#123;    audio: true,    video: true  &#125;);&#125;/** * 关闭摄像头 * @param &#123;dom&#125; video video节点 */const closeCamera = video =&gt; &#123;  video[SRC_OBJECT].getTracks()[0].stop(); // audio  video[SRC_OBJECT].getTracks()[1].stop(); // video&#125;/** * 视频流绑定到video节点展示 * @param &#123;dom&#125; video video节点 * @param &#123;obj&#125; stream 视频流 */const pushStreamToVideo = (video, stream) =&gt; &#123;  console.log(&#x27;视频流绑定到video节点展示&#x27;, video, stream)  video[SRC_OBJECT] = stream;&#125;\n编辑main.js：\n12345678910111213141516171819202122232425/** * dom获取 */const btnConnect = $(&#x27;#connect&#x27;); // 连接domconst btnLogout = $(&#x27;#logout&#x27;); // 挂断domconst domLocalVideo = $(&#x27;#localVideo&#x27;); // 本地视频dom/** * 连接 */btnConnect.click(() =&gt; &#123;  //启动摄像头  if (localStream == null) &#123;    openCamera().then(stream =&gt; &#123;      pushStreamToVideo(domLocalVideo[0], stream);    &#125;).catch(e =&gt; alert(`getUserMedia() error: $&#123;e.name&#125;`));  &#125;&#125;);/** * 挂断 */btnLogout.click(() =&gt; &#123;  closeCamera(domLocalVideo[0]);&#125;)\n测试一下摄像头功能，因为开启摄像头需要使用https服务，因此在前端项目根目录打开控制台命令，运行：\n1anywhere 5000\n然后浏览器打开命令行提示里的端口号为5001的那个https协议的地址，例如：https://192.168.1.4:5001/\n这时候，可能也会提示您的连接不是私密连接，点击高级，最下面继续前往。\n点击连接按钮，允许访问摄像头，看摄像头是否正常打开，页面视频是否出现，然后点击断开，看摄像头是否关闭、画面是否消失。\n4.3.4 Offer/Answer模型\n从这节开始，就正式涉及到WebRTC相关API了，下面先写几个全局变量，用于保存一些公用数据：\n编辑sdk.js\n12345678910// socket连接const socket = io(THSConfig.signalServer);// 本地socket idlet socketId;// 房间 idlet roomId;// 对RTCPeerConnection连接进行缓存let rtcPeerConnects = &#123;&#125;;// 本地streamlet localStream = null;\n（1）加入房间\n在开始Offer/Answer模型前，我们必须得至少有两个客户端才行。因此，我们先写一下，怎么控制房间。\n咱们先整理一下思路，我们先让甲创建一个房间，然后，这个房间里只有甲一个人，无法进行Offer/Answer。这时候乙在进入房间时，可以获取一下房间的人数，如果房间有人，那么乙就给房间里的每一个人发送Offer请求。房间里的甲监听到了刚进来乙的Offer后，给乙回复Answer。这样就建立起了Offer/Answer模型。\n编辑sdk.js\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 连接（给signal server 发送创建或者加入房间的消息） * @param &#123;string&#125; roomid 房间号 */const connect = roomid =&gt; &#123;  console.log(&#x27;创建或者加入房间&#x27;, roomid)  socket.emit(&#x27;createAndJoinRoom&#x27;, &#123;    room: roomid  &#125;);&#125;/** * 监听signal server创建房间或者加入房间成功的消息，signal server会判断房间里是否有人 */socket.on(&#x27;created&#x27;, async data =&gt; &#123;  // data: [id,room,peers]  console.log(&#x27;created: &#x27;, data);  // 保存signal server给我分配的socketId  socketId = data.id;  // 保存创建房间或者加入房间的room id  roomId = data.room;  // 如果data.peers = []，说明房间里没有人，是创建房间，以下步骤则不会执行  // 如果data.peers != []，说明房间里有人，是加入房间，给返回的每一个peers，创建WebRtcPeerConnection并发送offer消息  for (let i = 0; i &lt; data.peers.length; i++) &#123;    let otherSocketId = data.peers[i].id;    // 创建WebRtcPeerConnection // 注意：这个函数是下一个步骤写的。    let pc = getWebRTCConnect(otherSocketId);    // 创建offer    const offer = await pc.createOffer(THSConfig.offerOptions);    // 发送offer    onCreateOfferSuccess(pc, otherSocketId, offer);  &#125;&#125;)/** * offer创建成功回调 * @param &#123;*&#125; pc  * @param &#123;*&#125; otherSocketId  * @param &#123;*&#125; offer  */function onCreateOfferSuccess(pc, otherSocketId, offer) &#123;  console.log(&#x27;createOffer: success &#x27; + &#x27; id:&#x27; + otherSocketId + &#x27; offer: &#x27;, offer);  // 设置本地setLocalDescription 将自己的描述信息加入到PeerConnection中  pc.setLocalDescription(offer);  // 构建offer  const message = &#123;    from: socketId,    to: otherSocketId,    room: roomId,    sdp: offer.sdp  &#125;;  console.log(&#x27;发送offer消息&#x27;, message)  // 发送offer消息  socket.emit(&#x27;offer&#x27;, message);&#125;\n前面，可以算是把Offer发出去了，可以回顾4.2.3 转发功能，信令服务器收到Offer后，会将其转发给房间里的每一个用户，然后，我们就需要写一个监听，当信令服务器转发过来Offer后，我们应该进行Answer：\n继续编辑sdk.js\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 监听signal server转发过来的offer消息，将对方的描述信息加入到PeerConnection中，然后构建answer */socket.on(&#x27;offer&#x27;, data =&gt; &#123;  // data:  [from,to,room,sdp]  console.log(&#x27;收到offer: &#x27;, data);  // 获取RTCPeerConnection  const pc = getWebRTCConnect(data.from);  console.log(&#x27;getWebRTCConnect: &#x27;, pc);  // 构建RTCSessionDescription参数  const rtcDescription = &#123;    type: &#x27;offer&#x27;,    sdp: data.sdp  &#125;;  console.log(&#x27;offer设置远端setRemoteDescription&#x27;)  // 设置远端setRemoteDescription  pc.setRemoteDescription(new SessionDescription(rtcDescription));  console.log(&#x27;setRemoteDescription: &#x27;, rtcDescription);  // createAnswer  pc.createAnswer(THSConfig.offerOptions)    .then(offer =&gt; onCreateAnswerSuccess(pc, data.from, offer))    .catch(error =&gt; onCreateAnswerError(error));&#125;)/** * answer创建成功回调 * @param &#123;*&#125; pc  * @param &#123;*&#125; otherSocketId  * @param &#123;*&#125; offer  */function onCreateAnswerSuccess(pc, otherSocketId, offer) &#123;  console.log(&#x27;createAnswer: success &#x27; + &#x27; id:&#x27; + otherSocketId + &#x27; offer: &#x27;, offer);  // 设置本地setLocalDescription，将对方的描述信息加入到PeerConnection中  pc.setLocalDescription(offer);  // 构建answer信息  const message = &#123;    from: socketId,    to: otherSocketId,    room: roomId,    sdp: offer.sdp  &#125;;  console.log(&#x27;发送answer消息&#x27;, message)  // 发送answer消息  socket.emit(&#x27;answer&#x27;, message);&#125;/** * answer创建失败回调 * @param &#123;*&#125; error  */function onCreateAnswerError(error) &#123;  console.log(&#x27;createAnswer: fail error &#x27; + error);&#125;\n现在，我们把Answer信息回复出去了，通过信令服务器会转发指定的用户（刚刚发来offer的用户），然后我们还要添加一个监听Answer的信息：\n继续编辑sdk.js\n1234567891011121314151617181920/** * 监听signal server转发过来的answer消息，将对方的描述信息加入到PeerConnection中 */socket.on(&#x27;answer&#x27;, data =&gt; &#123;  // data:  [from,to,room,sdp]  console.log(&#x27;收到answer: &#x27;, data);  // 获取RTCPeerConnection  const pc = getWebRTCConnect(data.from);  // 构建RTCSessionDescription参数  const rtcDescription = &#123;    type: &#x27;answer&#x27;,    sdp: data.sdp  &#125;;  console.log(&#x27;answer设置远端setRemoteDescription&#x27;)  console.log(&#x27;setRemoteDescription: &#x27;, rtcDescription);  //设置远端setRemoteDescription  pc.setRemoteDescription(new SessionDescription(rtcDescription));&#125;)\n（2）获取RTCPeerConnection、移除RTCPeerConnection\n接上一步骤，其中涉及到一个getWebRTCConnect的方法，这节就写如何实现它，以及本地如何管理与他人的连接。\n继续编辑sdk.js\n123456789101112131415161718192021222324252627282930313233343536373839404142434445// 对RTCPeerConnection连接进行缓存let rtcPeerConnects = &#123;&#125;;  // 这是开始前设置的全局变量/** * 获取RTCPeerConnection * @param &#123;string&#125; otherSocketId 对方socketId */function getWebRTCConnect(otherSocketId) &#123;  if (!otherSocketId) return;  // 查询全局中是否已经保存了连接  let pc = rtcPeerConnects[otherSocketId];  console.log(&#x27;建立连接：&#x27;, otherSocketId, pc)  if (typeof (pc) === &#x27;undefined&#x27;) &#123; // 如果没有保存，就创建RTCPeerConnection    // 构建RTCPeerConnection    pc = new PeerConnection(THSConfig.iceServers); // PeerConnection是4.3.2定义的兼容处理    // 设置获取icecandidate信息回调 此处可暂时忽略，将在4.3.5讲解    pc.onicecandidate = e =&gt; onIceCandidate(pc, otherSocketId, e);    // 设置获取对端stream数据回调-track方式 此处可暂时忽略，将在4.3.5讲解    pc.ontrack = e =&gt; &#123;      console.log(&#x27;我接到数据流了！！&#x27;, pc, otherSocketId, e)      onTrack(pc, otherSocketId, e);    &#125;    // 设置获取对端stream数据回调 此处可暂时忽略，将在4.3.5讲解    pc.onremovestream = e =&gt; onRemoveStream(pc, otherSocketId, e);    // peer设置本地流 此处可暂时忽略，将在4.3.5讲解    if (localStream != null) &#123;      localStream.getTracks().forEach(track =&gt; &#123;        pc.addTrack(track, localStream);      &#125;);    &#125;    // 缓存peer连接    rtcPeerConnects[otherSocketId] = pc;  &#125;  return pc;&#125;/** * 移除RTCPeerConnection连接缓存 * @param &#123;string&#125; otherSocketId 对方socketId */function removeRtcConnect(otherSocketId) &#123;  delete rtcPeerConnects[otherSocketId];&#125;\n4.3.5 ICE连接/接收音视频流\nOffer/Answer模型让两个客户端互相建立了签订了合同，建立了信任的合作伙伴关系，接下来可以开始进行交易了（传输音视频数据）。在交易前，我们要互相知道对方真实的交易地址和银行账号（允许主机直连的地址，详细可回顾1.4ICE协议），我给你发货，你给我打钱。\n通常，在第一步乙的Offer发出后，乙客户端就开始通过ICE获取自己的地址（通过ICE协议可以了解，这个地址可能是自己的IP地址），只要等甲方同意（设置远程描述完成，这时候可能还未回复Answer），甲方就可以接收到乙客户端的音视频流了。同理，甲方回复的Answer之后，只要乙客户端同意，乙客户端也就能收到甲方的音视频流了。至此，双方都收到对方的视频流了，视频通话建立。\n回顾上一小节 4.3.4 (2) 获取RTCPeerConnection中的一段代码：\n123456789101112131415161718// 构建RTCPeerConnectionpc = new PeerConnection(THSConfig.iceServers); // PeerConnection是4.3.2定义的兼容处理// 1. 设置获取icecandidate信息回调pc.onicecandidate = e =&gt; onIceCandidate(pc, otherSocketId, e);// 2. 设置获取对端stream数据回调-track方式  还有种方式是onaddstream，但这种方式已经不推荐使用了。pc.ontrack = e =&gt; &#123;  console.log(&#x27;我接到数据流了！！&#x27;, pc, otherSocketId, e)  onTrack(pc, otherSocketId, e);&#125;// 3. 设置获取对端stream数据回调pc.onremovestream = e =&gt; onRemoveStream(pc, otherSocketId, e);// 4. peer设置本地流if (localStream != null) &#123;  localStream.getTracks().forEach(track =&gt; &#123;    pc.addTrack(track, localStream);  &#125;);&#125;\n实例pc实际就是window.RTCPeerConnection对象，这个对象有几个回调方法在3.3.1节已经讲过了。\n（1）onicecandidate\n当ICE协商完成后，我们将协商结果发送至信令服务器，让其转发给指定的客户端。\n继续编辑sdk.js\n12345678910111213141516171819202122232425/** * RTCPeerConnection 事件回调，获取icecandidate信息回调 * @param &#123;*&#125; pc  * @param &#123;*&#125; otherSocketId  * @param &#123;*&#125; event  */function onIceCandidate(pc, otherSocketId, event) &#123;  console.log(&#x27;onIceCandidate to &#x27; + otherSocketId + &#x27; candidate: &#x27;, event);  if (event.candidate !== null) &#123;    // 构建信息 [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]]    const message = &#123;      from: socketId,      to: otherSocketId,      room: roomId,      candidate: &#123;        sdpMid: event.candidate.sdpMid,        sdpMLineIndex: event.candidate.sdpMLineIndex,        sdp: event.candidate.candidate      &#125;    &#125;;    console.log(&#x27;向信令服务器发送candidate&#x27;, message)    // 向信令服务器发送candidate    socket.emit(&#x27;candidate&#x27;, message);  &#125;&#125;\n远程客户端收到candidate后，添加candidate后即可接收到本机的音视频流：\n继续编辑sdk.js，添加监听事件：\n123456789101112131415161718192021/** * 监听signal server转发过来的candidate消息 */socket.on(&#x27;candidate&#x27;, data =&gt; &#123;  // data:  [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]]  console.log(&#x27;candidate: &#x27;, data);  const iceData = data.candidate;    // 获取RTCPeerConnection  const pc = getWebRTCConnect(data.from);    const rtcIceCandidate = new RTCIceCandidate(&#123;    candidate: iceData.sdp,    sdpMid: iceData.sdpMid,    sdpMLineIndex: iceData.sdpMLineIndex  &#125;);  console.log(&#x27;添加对端Candidate&#x27;)  // 添加对端Candidate  pc.addIceCandidate(rtcIceCandidate);&#125;)\n（2）ontrack\n当监听到对方传递过来时音视频流后，动态创建一个video标签，显示接收到的音视频流数据。\n继续编辑sdk.js\n123456789101112131415161718192021/** * 获取对端stream数据回调-ontrack模式 * @param &#123;*&#125; pc  * @param &#123;*&#125; otherSocketId  * @param &#123;*&#125; event  */ function onTrack(pc, otherSocketId, event) &#123;  console.log(&#x27;onTrack from: &#x27; + otherSocketId);  let otherVideoDom = $(&#x27;#&#x27; + otherSocketId);  if (otherVideoDom.length === 0) &#123; // TODO 未知原因：会两次onTrack，就会导致建立两次dom    const video = document.createElement(&#x27;video&#x27;);    video.id = otherSocketId;    video.autoplay = &#x27;autoplay&#x27;;    video.muted = &#x27;muted&#x27;;    video.style.width = 200;    video.style.height = 200;    video.style.marginRight = 5;    $(&#x27;#remoteDiv&#x27;).append(video);  &#125;  $(&#x27;#&#x27; + otherSocketId)[0][SRC_OBJECT] = event.streams[0];&#125;\n（3）onremovestream\n监听对方停止传输视频流的时候，我方进行相应处理：\n继续编辑sdk.js\n123456789101112131415/** * onRemoveStream回调 * @param &#123;*&#125; pc  * @param &#123;*&#125; otherSocketId  * @param &#123;*&#125; event  */function onRemoveStream(pc, otherSocketId, event) &#123;  console.log(&#x27;onRemoveStream from: &#x27; + otherSocketId);  // peer关闭  getWebRTCConnect(otherSocketId).close;  // 删除peer对象  removeRtcConnect(otherSocketId)  // 移除video  $(&#x27;#&#x27; + otherSocketId).remove();&#125;\n（4）添加本地音视频流\n当我方开启摄像头后，全局变量localStream就不为null，我们需要往对方塞过去我们的的音视频数据，通过addTrack方法。这样，在对方同意（添加我方描述）后，就可以获取到我方的音视频数据了。\n4.3.6 完善逻辑\n前面的内容基本把整个逻辑讲完了，但是你现在启动项目运行，是不是还是只能看到自己，后面的步骤根本没有执行？\n因为前面的我们只打开了摄像头，还没有对接后续操作。\n现在编辑main.js，修改一下之前的代码：\n12345678910111213141516171819202122232425262728293031323334353637/** * dom获取 */const btnConnect = $(&#x27;#connect&#x27;); // 连接domconst btnLogout = $(&#x27;#logout&#x27;); // 挂断domconst domLocalVideo = $(&#x27;#localVideo&#x27;); // 本地视频domconst domRoom = $(&#x27;#room&#x27;); // 获取房间号输入框dom/** * 连接 */btnConnect.click(() =&gt; &#123;  const roomid = domRoom.val(); // 获取用户输入的房间号  if (!roomid) &#123;    alert(&#x27;房间号不能为空&#x27;);    return;  &#125;;  //启动摄像头  if (localStream == null) &#123;    openCamera().then(stream =&gt; &#123;      localStream = stream; // 保存本地视频到全局变量      pushStreamToVideo(domLocalVideo[0], stream);      connect(roomid); // 成功打开摄像头后，开始创建或者加入输入的房间号    &#125;).catch(e =&gt; alert(`getUserMedia() error: $&#123;e.name&#125;`));  &#125;&#125;);/** * 挂断 */btnLogout.click(() =&gt; &#123;  closeCamera(domLocalVideo[0]);  logout(roomId); // 退出房间    //移除远程视频  $(&#x27;#remoteDiv&#x27;).empty();&#125;)\n编辑sdk.js，添加logout()方法，监听他人退出房间socket.on('exit')：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 挂断（退出房间） * @param &#123;string&#125; roomid 房间号 */const logout = roomid =&gt; &#123;  // 构建数据  const data = &#123;    from: socketId, // 全局变量，我方的socketId    room: roomid, // 全局变量，当前房间号  &#125;;  // 向信令服务器发出退出信号，让其转发给房间里的其他用户  socket.emit(&#x27;exit&#x27;, data);  // 数据重置  socketId = &#x27;&#x27;;  roomId = &#x27;&#x27;;  // 关闭每个peer连接  for (let i in rtcPeerConnects) &#123;    let pc = rtcPeerConnects[i];    pc.close();    pc = null;  &#125;  // 重置RTCPeerConnection连接  rtcPeerConnects = &#123;&#125;;  // 移除本地视频  localStream = null;&#125;/** * 监听signal server转发过来的exit消息，和退出房间的客户端断开连接 */socket.on(&#x27;exit&#x27;, data =&gt; &#123;  // data: [from,room]  console.log(&#x27;exit: &#x27;, data);  // 获取RTCPeerConnection  const pc = rtcPeerConnects[data.from];  if (typeof (pc) == &#x27;undefined&#x27;) &#123;    return;  &#125; else &#123;    // RTCPeerConnection关闭    getWebRTCConnect(data.from).close;    // 删除peer对象    removeRtcConnect(data.from)    console.log($(&#x27;#&#x27; + data.from))    // 移除video    $(&#x27;#&#x27; + data.from).remove();  &#125;&#125;)\n4.3.7 完整代码\nhttps://github.com/Chef5/WebRTC-demo/tree/main/webrtc-client\n五、总结\n现在，我们已经基本入门WebRTC了。可能前3章的协议、服务器、API的学习让我们感觉很枯燥，知识很杂乱。我想，大家通过第四章的实战开发，将之前的知识点串通起来，是不是有一点感觉了。其实前两章在现在看来，是可以不必着重学习的。没有这些协议和服务器的支持，不懂他们的连接原理，后面的学习应该会更加疑惑吧。\n前面的实战开发，是一个很简单的Web端的例子，没有涉及到安卓、iOS端如何进行WebRTC通信，如果需要继续深入学习，下一步可以往移动端WebRTC上学习，比如移动端打开摄像头都和Web不同。\n如果暂时没有深入WebRTC的学习话，可以基于这个实战项目进行横向的扩展。这个实战项目虽然看起来很简单，但是你可以给它加出很多功能来，会看起来很高大尚！比如：\n\n在线电话：咱们现在只是通过房间号进行连接，我们可以设置一个登陆页面，将用户的id作为房间号，每个用户登陆后直接创建一个房间。我们想要给某个用户打音视频电话的话，我们可以加入他的房间，对方也能检测到房间是否有人进来，这样对方可以做成收到来电了，对方接听后，我们就进行WebRTC连接，实现拨打电话的功能。\n视频会议：我们开发好注册登录功能，创建会议就相当于创建一个房间，只不过这个房间号是由我们系统来自动分配，别人登录后，通过该房间号就可以加入，即可实现视频会议功能。当然还可以扩展分享屏幕、白板等功能。\n\n本次WebRTC入门学习到此结束了，非常感谢您耐心地看完本篇长文。若有描述不对的地方，欢迎指出！\n对以下文章、项目和视频的作者们，表示非常感谢！感谢您们辛苦的成果！\n参考文章、文献、规范、项目、视频：\n\nWebRTC协议介绍：https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols\nWebRTC中文社区：https://webrtc.org.cn/\nRTC开发者社区：https://rtcdeveloper.com/\n又拍云WebRTC实时通信服务实践：https://segmentfault.com/a/1190000010339671\nP2P通信原理：https://zhuanlan.zhihu.com/p/26796476\nSTUN协议详细介绍：https://zhuanlan.zhihu.com/p/26797664\nTURN协议详细介绍：https://zhuanlan.zhihu.com/p/26797422\nICE协议详细介绍：https://zhuanlan.zhihu.com/p/26857913\nWebRTC PeerConnection建立连接过程：https://aggresss.blog.csdn.net/article/details/106832965\nSTUN/TURN服务器（C语言）：https://github.com/coturn/coturn\nSTUN服务器（node）https://github.com/enobufs/stun\nBuild Zoom Clone Video Chat Web App in Node.js Express and Socket.io Using WebRTC and PeerJS Library：https://www.youtube.com/watch?v=MX_r3Wm_BLE\nhttps://codingshiksha.com/javascript/build-zoom-clone-video-chat-web-app-in-node-js-express-and-socket-io-using-webrtc-and-peerjs-library/\nBuild Video Chat Web App From Scratch in 40 mins：https://www.youtube.com/watch?v=KLCcCTFivhM\ncoturn服务器搭建：https://www.jianshu.com/p/915eab39476d\ncoturn服务器搭建：https://meetrix.io/blog/webrtc/coturn/installation.html\ncoturn服务器搭建：https://ourcodeworld.com/articles/read/1175/how-to-create-and-configure-your-own-stun-turn-server-with-coturn-in-ubuntu-18-04\nWebRtcRoomServer（信令服务器node）：https://github.com/qdgx/WebRtcRoomServer\nMDN Web Docs：https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API\nwebRTC API之RTCPeerConnection：https://www.cnblogs.com/suRimn/p/11314914.html\nRTP与RTCP协议介绍：https://blog.51cto.com/zhangjunhd/25481\n\n","thumbnail":"images/20210728/cover.jpg","plink":"https://blog.jschef.com/Learning/eab52ad62fb2/"},{"title":"使用Let's Encrypt给node.js项目添加SSL证书","date":"2021-03-08T15:04:03.000Z","date_formatted":{"ll":"Mar 8, 2021","L":"03/08/2021","MM-DD":"03-08"},"updated":"2023-11-14T12:07:06.466Z","content":"使用Let’s Encrypt给node.js启动的项目配置。Nginx + node.js + Let’s Encript.\n\n本文是自己在网上各种查询，并成功配置后记录的详细步骤。\n一、环境准备\n\nnginx: 可参考 Ubuntu 16.04搭建lnmp环境\nCertbot: 可参考 Nginx用certbot获取Let’s Encrypt SSL证书\nnode.js\n\n二、配置步骤\n首先，先将你的node.js项目传到服务器，npm i安装好依赖，保证项目能启动起来，然后可以开始以下步骤了。\n2.1 创建辅助文件\n首先，假设你的项目目录是 /home/server/，进入项目目录：\n1cd /home/server\n创建一个文件 a.js:\n123456789// a.jsconst express = require(&#x27;express&#x27;);const app = express();app.use(express.static(__dirname, &#123; dotfiles: &#x27;allow&#x27; &#125; ));app.listen(5000, () =&gt; &#123;  console.log(&#x27;HTTP server running on port 5000&#x27;);&#125;);\n创建一个目录.well-known/acme-challenge:\n1mkdir -p .well-known/acme-challenge\n添加-p可以同时创建两个目录，其中acme-challenge是.well-known的子目录。\n2.2 编辑nginx配置文件\n1vim /etc/nginx/conf.d/youdomain.com.conf\n编辑你项目的nginx配置文件：\n12345678910111213server &#123;  listen 80;  server_name youdomain.com; # 设置你的域名  location / &#123;    proxy_pass http://127.0.0.1:5000;  &#125;  location ^~ /.well-known/acme-challenge/ &#123;    default_type &quot;text/plain&quot;;    root     /home/server/; # 你的项目路径  &#125;&#125;\n保存nginx配置文件，并重启nginx服务：\n1systemctl restart nginx\n2.3 开始获取证书\n先启动辅助文件：\n1node /home/server/a.js\n新开一个窗口，通过cerbot启动下面命令：\n1certbot certonly --manual -d youdomain.com\n遇到(Y)es/(N)o的时候，输入Y，回车，然后你会看到类似这样的描述：\n1234567891011121314151617181920212223NOTE: The IP of this machine will be publicly logged as having requested thiscertificate. If you&#x27;re running certbot in manual mode on a machine that is notyour server, please ensure you&#x27;re okay with that.Are you OK with your IP being logged?- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(Y)es/(N)o: Y- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Create a file containing just this data:hoo8qxxxxxxxxxxxxxxxxxxxxxxxxxxxxBBJ2A.LTb3xxxxxxxxxxxxxxxxxxxxxxxxxxxxxoHysAnd make it available on your web server at this URL:http://youdomain.com/.well-known/acme-challenge/hoo8qxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxBBJ2A- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Press Enter to Continue\n这时候，暂时不要继续了，不要继续了！不要继续了！\n保持这个窗口，我们新开一个命令行窗口，创建文件：\n1vim /home/server/.well-known/acme-challenge/hoo8qxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxBBJ2A\n内容请复制获取证书时给的一串字符串，比如我这是这样的：\n1hoo8qxxxxxxxxxxxxxxxxxxxxxxxxxxxxBBJ2A.LTb3xxxxxxxxxxxxxxxxxxxxxxxxxxxxxoHys\n保存好文件后，先用浏览器访问一下http://youdomain.com/.well-known/acme-challenge/hoo8qxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxBBJ2A，看能否正常输出内容。\n如果不能正常输出，请检查之前的步骤。\n如果正常，回到之前的窗口，按回车继续获取证书，通常成功你就看到如下内容：\n123456789101112131415IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at:   /etc/letsencrypt/live/youdomain.com/fullchain.pem   Your key file has been saved at:   /etc/letsencrypt/live/youdomain.com/privkey.pem   Your cert will expire on 2021-06-06. To obtain a new or tweaked   version of this certificate in the future, simply run certbot   again. To non-interactively renew *all* of your certificates, run   &quot;certbot renew&quot; - If you like Certbot, please consider supporting our work by:   Donating to ISRG / Let&#x27;s Encrypt:   https://letsencrypt.org/donate   Donating to EFF:                    https://eff.org/donate-le\n至此，证书已经成功获取，证书保存在：/etc/letsencrypt/live/youdomain.com目录下。\n2.4 给你项目配置证书\n编辑你项目的app.js，添加以下内容:\n12345678910111213const https = require(&#x27;https&#x27;);const fs = require(&#x27;fs&#x27;);const options = &#123;  key: fs.readFileSync(&#x27;/etc/letsencrypt/live/youdomain.com/privkey.pem&#x27;),  cert: fs.readFileSync(&#x27;/etc/letsencrypt/live/youdomain.com/fullchain.pem&#x27;),&#125;;// 创建https服务https.createServer(options, function (req, res) &#123;  res.writeHead(200);  res.end(&quot;hello world\\n&quot;);&#125;).listen(8443); // 端口号任意\n保存后，启动你的项目。\n2.5 重新配置nginx\n编辑/etc/nginx/conf.d/youdomain.com.conf:\n1234567891011121314server &#123;  listen 443; # 将原来的80换成443  server_name youdomain.com; # 设置你的域名  location / &#123;    proxy_pass http://127.0.0.1:8443; # 端口号和项目端口号保持一致  &#125;  # 以下内容可以删除了  location ^~ /.well-known/acme-challenge/ &#123;    default_type &quot;text/plain&quot;;    root     /home/server/;  &#125;&#125;\n保存配置，并重启。\n2.6 测试\n完成上面的步骤，不出问题，应该可以使用https访问node项目了。\n浏览器访问：\n1https://youdomain.com","plink":"https://blog.jschef.com/Learning/b06654da20be/"},{"title":"Nest.js大法-上","date":"2021-02-16T11:08:40.000Z","date_formatted":{"ll":"Feb 16, 2021","L":"02/16/2021","MM-DD":"02-16"},"updated":"2023-11-14T12:07:06.466Z","content":"Nest大法分为上、中、下三部，完成此三部大法，成就全栈大能！修炼吾之《Nest.js大法》三部，行走江湖，亦可和后端交手而不败！\n\n\n上册：快速入门教程\n中册：Nest.js详解\n下册：大型实战开发-在线面试系统\n\n上册主要是一路到底，通过掌握简单的知识点快速入门，建立一个立体的知识认知，最后完成一个完整的简单的后端实例。\n如果有前端的Angular框架经验，或者后端的Spring、Laravel的框架基础，修炼本大法也许会更容易理解。\n本人就曾在毕设的时候，自学的Laravel框架，这个框架的结构和命令都和Nest.js比较像。\n一、环境准备\n\nMySQL\nnode.js &gt;= 10.13.0\nNest Cli\nNavicat\nPostman\n\n本文以MySQL数据库为例，并使用了Mavicat数据库可视化工具、Postman接口测试工具，请提前准备。\n\n由于笔者对mongodb暂时还不是很理解，本文暂时先只写MySQL的例子。\n\n1.1 MySQL\n安装：\n1brew install mysql\n启动/关闭：start/stop\n1mysql.server start\n设置密码：\n123mysql -u rootalter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;密码&#x27;;exit;\n1.2 mongodb(弃)\n本节请跳过，我搞明白了mongodb再继续写\n安装：\n12brew tap mongodb/brewbrew install mongodb-community\n启动/关闭：start/stop\n1brew services start mongodb-community\n1.3 Nest cli\n1npm i -g @nestjs/cli\n二、搭建项目\n2.1 创建项目\n123nest new mynest-democd mynest-demonpm run start:dev\n通过Nest cli命令新建一个名为mynest-demo的项目。\n最后，浏览器打开http://localhost:3000/可以看到经典的Hello World!，就表示成功了。\n2.2 安装依赖\nNest提供了TypeORM库，用于操作MySQL数据库：\n1npm i --save @nestjs/typeorm typeorm mysql2\n三、编写代码\n后端，通常就是对数据库进行增删改查（CRUD）操作，当然还有其他不少的活。本文就主要对一个用户”表“user进行CRUD，一起完整的操作一下数据库操作。\n3.1 创建 Module\n1nest g module user server\nNest cli会自动在src/server/user文件夹下创建一个user.module.ts，这是Nest的模块文件，Nest用它来组织整个应用程序的结构。\n12345// user.module.tsimport &#123; Module &#125; from &#x27;@nestjs/common&#x27;;@Module(&#123;&#125;)export class UserModule &#123;&#125;\n同时还会Nest cli会自动在根模块app.module.ts中引入我们刚刚创建的UserModule这个模块。\n123456789101112// app.module.tsimport &#123; Module &#125; from &#x27;@nestjs/common&#x27;;import &#123; AppController &#125; from &#x27;./app.controller&#x27;;import &#123; AppService &#125; from &#x27;./app.service&#x27;;import &#123; UserModule &#125; from &#x27;./server/user/user.module&#x27;; // 自动引入的@Module(&#123;  imports: [UserModule], // 自动引入的  controllers: [AppController],  providers: [AppService],&#125;)export class AppModule &#123;&#125;\n3.2 创建 Controller\n1nest g controller user server\n在Nest中，controller是我们写Nest程序的主要战场之一（还有一个provider）。它负责处理客户端传入的请求和服务端返回的响应。\n举个例子，我们如果要通过http://localhost:3000/user/getUserInfo获取用户的信息：\n123456789101112131415// user.controller.tsimport &#123; Controller, Get &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;user&#x27;)export class UserController &#123;  @Get(&#x27;getUserInfo&#x27;)  getAll(): string &#123;    // 暂时代替所有用户的数据    const users = [      &#123; name: &#x27;Tom&#x27;, age: 19 &#125;,      &#123; name: &#x27;Jerry&#x27;, age: 16 &#125;,    ];    return JSON.stringify(users);  &#125;&#125;\n这里，user.controller.ts负责处理了客户端传入的getUserInfo请求，并将所有用户的数据通过JSON字符串形式进行响应。\n\n3.3 创建 Provider\n1nest g service user server\nprovider我们可以简单地从字面意思来理解，就是服务的提供者。\n我们的controller接收到了一个用户的查询请求，我们不直接在controller中去查询数据库并返回，而是要将查询请求交给provider来处理，这里我们创建了一个UserService，就是用来提供数据库操作服务的。\n12345// user.service.tsimport &#123; Injectable &#125; from &#x27;@nestjs/common&#x27;;@Injectable()export class UserService &#123;&#125;\n当然，provider不一定只能用来提供数据库的操作服务，还可以用来做一些用户校验，放到provider中。provider也是我们写Nest程序的主要战场（还有一个controller）。\n总而言之，provider是为模块module提供相应服务的。\n\nmodule控制路由，管理请求响应，负责挥棒指挥。provider听从module的调遣，是module的虾兵蟹将。\n\n有必要提的一件事是，前面通过Nest cli创建controller和provider的时候，自动咱们的user.module.ts中引入了：\n12345678910// user.module.tsimport &#123; Module &#125; from &#x27;@nestjs/common&#x27;;import &#123; UserController &#125; from &#x27;./user.controller&#x27;; // 自动引入import &#123; UserService &#125; from &#x27;./user.service&#x27;; // 自动引入@Module(&#123;  controllers: [UserController], // 自动引入  providers: [UserService] // 自动引入&#125;)export class UserModule &#123;&#125;\n这就是使用Nest cli的好处了，其实这些文件我们也可以自己手动创建，然后在指定地方引入，也是一样的效果。这就是脚手架的美丽，它会官方提供的一个便捷工具。\n四、连接数据库[MySQL]\n4.1 创建实体entity\n先创建一个放实体文件的文件夹：src/entities，然后在这个文件夹下创建一个user.entity.ts文件，定义一个数据表的格式：\n1234567891011121314// user.entity.tsimport &#123; PrimaryGeneratedColumn, Column, Entity &#125; from &#x27;typeorm&#x27;;@Entity()export class Users &#123;  @PrimaryGeneratedColumn() // 自增主键  id: number;  @Column(&#123; length: 45 &#125;) // 姓名  name: string;  @Column(&#x27;int&#x27;) // 年龄  age: number;&#125;\n4.2 根模块引入\n在这之前，我们先打开Navicat数据库可视化工具，连接本地数据库，创建一个名为nest_demo的数据库。\n\n连接数据库之前，我们需要先在根模块app.module.ts中引入一些模块，并配置：\n1234567891011121314151617181920212223242526272829// app.module.tsimport &#123; Module &#125; from &#x27;@nestjs/common&#x27;;import &#123; AppController &#125; from &#x27;./app.controller&#x27;;import &#123; AppService &#125; from &#x27;./app.service&#x27;;import &#123; UserModule &#125; from &#x27;./server/user/user.module&#x27;;import &#123; TypeOrmModule &#125; from &#x27;@nestjs/typeorm&#x27;; // 引入TypeORMimport &#123; Connection &#125; from &#x27;typeorm&#x27;; // 引入Connection@Module(&#123;  imports: [    UserModule,    // 配置数据库连接参数    TypeOrmModule.forRoot(&#123;      type: &#x27;mysql&#x27;,      host: &#x27;127.0.0.1&#x27;,      port: 3306,      username: &#x27;root&#x27;,      password: &#x27;root&#x27;,      database: &#x27;nest_demo&#x27;,      entities: [__dirname + &#x27;/**/*.entity&#123;.ts,.js&#125;&#x27;],      synchronize: true,    &#125;),  ],  controllers: [AppController],  providers: [AppService],&#125;)export class AppModule &#123;  constructor(private readonly connection: Connection) &#123;&#125; // 初始化连接器Connection&#125;\n数据库连接参数：\n\ntype 表明使用MySQL数据库；\nhost 是本地数据库地址；\nport 是数据库默认端口；\nusername 数据库用户名；\npassword 数据库密码;\ndatabase 本程序使用的数据库名称；\nentities 实体（这里是直接全局查找所有*.entity.ts或*.entity.js文件），可以手动import并加入这个数组内；\nsynchronize 实体会自动映射表结构（数据库中不存在某实体的表时，会自动根据实体创建）\n\n我们这时候保存代码，打开Navicat，查看nest_demo数据库，可以发现，Nest自动根据user.entity.js创建了一个名为users的表。\n4.3 子模块引入\n修改分模块user.module.ts：\n12345678910111213import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;import &#123; UserController &#125; from &#x27;./user.controller&#x27;;import &#123; UserService &#125; from &#x27;./user.service&#x27;;import &#123; TypeOrmModule &#125; from &#x27;@nestjs/typeorm&#x27;; // 引入TypeORMimport &#123; Users &#125; from &#x27;../../entities/user.entity&#x27;; // 引入实体@Module(&#123;  imports: [TypeOrmModule.forFeature([Users])], // 应用实体  controllers: [UserController],  providers: [UserService],&#125;)export class UserModule &#123;&#125;\n到此为止，数据库连接配置，数据表设计都准备完成，下一步开始后端核心操作增删改查CRUD了。\n五、增删改查CRUD[MySQL]\n5.1 在provider中写数据库操作\n我们打开user.service.ts文件，给UserService类添加一个构造函数，让其在实例化的时候能够接收到数据库Model，这样才能在类中的方法里操作数据库。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// user.service.tsimport &#123; Injectable &#125; from &#x27;@nestjs/common&#x27;;import &#123; InjectRepository &#125; from &#x27;@nestjs/typeorm&#x27;; // TypeORM依赖注入import &#123; Users &#125; from &#x27;../../entities/user.entity&#x27;; // 操作的实体import &#123; DeleteResult, InsertResult, Repository, UpdateResult &#125; from &#x27;typeorm&#x27;; // 引入TypeORM模块@Injectable()export class UserService &#123;  constructor(    @InjectRepository(Users)    private readonly userRepository: Repository&lt;Users&gt;,  ) &#123;&#125;  // [增] 添加一个用户  async add(user: Users): Promise&lt;InsertResult&gt; &#123;    return await this.userRepository.insert(user);  &#125;  // [改] 编辑一个用户  async edit(id: number, user: Users): Promise&lt;UpdateResult&gt; &#123;    return await this.userRepository.update(id, user);  &#125;  // [删] 删除一个用户  async remove(id: number): Promise&lt;DeleteResult&gt; &#123;    return await this.userRepository.delete(id);  &#125;  // [查] 查询所有用户  async find(): Promise&lt;Users[]&gt; &#123;    const users = await this.userRepository.find();    return users;  &#125;  // [查] 查询所有用户: query SQL方法  async findAll(): Promise&lt;Users[]&gt; &#123;    return await this.userRepository.query(&#x27;select * from users&#x27;);  &#125;  // [查] 条件查询  async findById(id: number): Promise&lt;Users[]&gt; &#123;    return await this.userRepository.find(&#123; id &#125;);  &#125;  // [查] 条件查询  async findByName(name: string): Promise&lt;Users[]&gt; &#123;    return await this.userRepository.find(&#123; name &#125;);  &#125;&#125;\n数据库操作都是异步的，这里全部使用的async函数来处理异步的过程。\n5.2 在controller中写路由、简单业务\n我们先通过Navicat手动在nest_demo数据库中的users表中创建两条数据。\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import &#123;  Body,  Controller,  Delete,  Get,  Param,  Post,  Put,  Query,&#125; from &#x27;@nestjs/common&#x27;; // nest模块import &#123; UserService &#125; from &#x27;./user.service&#x27;;import &#123; Users &#125; from &#x27;../../entities/user.entity&#x27;; // 引入实体import &#123; DeleteResult, InsertResult, UpdateResult &#125; from &#x27;typeorm&#x27;; // TypeORM部分模块interface UserResponse&lt;T = unknown&gt; &#123;  code: number;  data?: T;  message: string;&#125;@Controller(&#x27;user&#x27;)export class UserController &#123;  constructor(private readonly userService: UserService) &#123;&#125;  // [查] 查询所有用户 http://localhost:3000/user/getAll  @Get(&#x27;getAll&#x27;)  getAll(): Promise&lt;Users[]&gt; &#123;    return this.userService.findAll();  &#125;  // [查] 查询指定用户名 /user/findByName?name=Tom  @Get(&#x27;findByName&#x27;)  async findByName(@Query(&#x27;name&#x27;) name: string): Promise&lt;Users[]&gt; &#123;    return await this.userService.findByName(name);  &#125;  // [查] 查询指定id /user/id/1  @Get(&#x27;id/:id&#x27;)  async findById(@Param(&#x27;id&#x27;) id: number): Promise&lt;Users[]&gt; &#123;    return await this.userService.findById(id);  &#125;  // [增] 增加用户（GET方式） /user/add?name=Bob&amp;age=11  @Get(&#x27;add&#x27;)  async add(@Query() user: Users): Promise&lt;UserResponse&gt; &#123;    const result = await this.userService.add(user);    if (result.raw?.insertId) &#123;      return &#123;        code: 200,        data: await this.userService.findById(result.raw.insertId),        message: &#x27;操作成功&#x27;,      &#125;;    &#125;    return &#123;      code: 500,      message: &#x27;操作失败&#x27;,    &#125;;  &#125;  // [增] 增加用户（POST方式） /user/add  // @Post(&#x27;add&#x27;)  // async add(@Body() user: Users): Promise&lt;UserResponse&gt; &#123;  //   const result = await this.userService.add(user);  //   if (result.raw?.insertId) &#123;  //     return &#123;  //       code: 200,  //       data: await this.userService.findById(result.raw.insertId),  //       message: &#x27;操作成功&#x27;,  //     &#125;;  //   &#125;  //   return &#123;  //     code: 500,  //     message: &#x27;操作失败&#x27;,  //   &#125;;  // &#125;  // [改] 修改用户（GET方式） /user/edit?id=1&amp;name=Tom1  @Get(&#x27;edit&#x27;)  async edit(    @Query(&#x27;id&#x27;) id: number,    @Query() user: Users,  ): Promise&lt;UserResponse&gt; &#123;    const result = await this.userService.edit(id, user);    if (result.affected === 1) &#123;      return &#123;        code: 200,        message: &#x27;操作成功&#x27;,      &#125;;    &#125;    return &#123;      code: 500,      message: &#x27;操作失败&#x27;,    &#125;;  &#125;  // [改] 修改用户（PUT方式） /user/edit  // @Put(&#x27;edit&#x27;)  // async edit(  //   @Param(&#x27;id&#x27;) id: number,  //   @Body() user: Users,  // ): Promise&lt;UserResponse&gt; &#123;  //   const result = await this.userService.edit(id, user);  //   if (result.affected === 1) &#123;  //     return &#123;  //       code: 200,  //       message: &#x27;操作成功&#x27;,  //     &#125;;  //   &#125;  //   return &#123;  //     code: 500,  //     message: &#x27;操作失败&#x27;,  //   &#125;;  // &#125;  // [删] 删除用户（GET方式） /user/remove?id=3  @Get(&#x27;remove&#x27;)  async remove(@Query(&#x27;id&#x27;) id: number): Promise&lt;UserResponse&gt; &#123;    const result = await this.userService.remove(id);    if (result.affected === 1) &#123;      return &#123;        code: 200,        message: &#x27;操作成功&#x27;,      &#125;;    &#125;    return &#123;      code: 500,      message: &#x27;操作失败&#x27;,    &#125;;  &#125;  // [删] 删除用户（DELETE方式） /user/delete/3  // @Delete(&#x27;delete/:id&#x27;)  // async remove(@Param(&#x27;id&#x27;) id: number): Promise&lt;UserResponse&gt; &#123;  //   const result = await this.userService.remove(id);  //   if (result.affected === 1) &#123;  //     return &#123;  //       code: 200,  //       message: &#x27;操作成功&#x27;,  //     &#125;;  //   &#125;  //   return &#123;  //     code: 500,  //     message: &#x27;操作失败&#x27;,  //   &#125;;  // &#125;&#125;\n上面，写了一些常用路由以及请求方式。我这里为增删改查CRUD分别都写了GET方式，目的就是方便在浏览器上直接测试。\n\n可能上面的代码中，可能有一些不懂的部分，比如@Get、@Post、@Query、@Body、@Param等装饰器，不过不打紧，大家可以放心大胆的去想像和猜测，也许正如你所想。这些概念和知识点将在《Nest.js大法-中》给大家详细讲解。\n六、总结\n本篇文章仅简单带大家使用Nest.js操作了一下数据库，立体的的了解了Nest.js框架的大致结构。\n完整的后端可不是这么简单的，比如我们这里没有对客户端传入的参数进行校验和过滤、状态管理，也没有处理数据库的异常和报错。\n不过不用着急，下一篇文章《Nest.js大法-中》将详细介绍Nest.js的常用的基础概念，常见业务逻辑的实现。而且最后还有《Nest.js大法-下》，手把手带你完整的写出一个大型应用。\n修炼吾之《Nest.js大法》三部，行走江湖，亦可和后端交手而不败！\n参考文档/文献/文章/教程：\n\nhttps://nestjs.bootcss.com/\n\n\nhttps://www.itying.com/nestjs/\n\n\nhttps://juejin.cn/post/6885751452015263758#heading-18\n\n","plink":"https://blog.jschef.com/Learning/3534afa74a70/"},{"title":"正则表达式","date":"2021-01-29T12:43:40.000Z","date_formatted":{"ll":"Jan 29, 2021","L":"01/29/2021","MM-DD":"01-29"},"updated":"2023-11-14T12:07:06.466Z","content":"正则表达式语法学习，常用正则表达式设计（视频讲解）\n\nPPT：https://cloud.189.cn/t/AnAR3uF3UJN3（访问码：ay78）\n视频回放地址：https://www.bilibili.com/video/BV1Ft4y1B768/\n\n \n\n\n以下内容为基本语法，详细请见PPT\n\n一、 界定符\n定义：表示一个正则表达式的开始和结束\n在JavaScript中，界定符以斜线（/）开始和结束：\n1const reg = /正则表达式/;\n可以这样理解：字符串是通过单引号或者双引号界定，那么正则的界定就好理解了吧。\n二、 原子\n定义：正则表达式中最小的匹配单位\n分为：可见原子、不可见原子（空格、换行符等）\n123const reg = /A/;const reg = /,/;const reg = / /;\n以上正则表达式中，均只有一个原子。\n可以这样理解：一篇文章的最小单位是一个文字或者一个单词，他们组合在一起就是一篇文章，正则表达式也是有原子组合而来的。\n三、 元字符\n定义：一系列原子的集合\n作用：定义原子的筛选方式；对某一类原子归类缩写；\n有三种筛选方式：\n123原子|原子    // 表示：或（匹配其中一个原子即可）[原子原子...]  // 表示：任一（匹配括号里的任一一个原子即可，原子之间不用竖线）[^原子原子...] // 表示：除此之外（和前一种情况相反）\n中括号中，如果原子是连续的（ASCII码），那么可以用横线（-）表示连续：\n12[0123456789] = [0-9][abcdefghijklmn] = [a-n]\n内置原子集合：\n\n\n元字符\n解释\n等价于\n\n\n\n\n.\n除换行符之外任意一个字符\n\n\n\n\\d\n匹配任意一个十进制数\n[0-9]\n\n\n\\D\n匹配任意一个非十进制数\n[^0-9]\n\n\n\\s\n匹配一个不可见原子\n[\\f\\n\\r\\t\\v]\n\n\n\\S\n匹配一个可见原子\n[^\\f\\n\\r\\t\\v]\n\n\n\\w\n匹配任意一个数字、字母、下划线\n[0-9a-zA-Z_]\n\n\n\\W\n匹配任意一个非数字、字母、下划线\n[^0-9a-zA-Z_]\n\n\n可以这样理解：单词可以组成一句话，文章是由很多句话组成。元字符也是对一类原子组成的一小段，最终这些元字符汇聚就可以组成正则表达式。\n四、 量词\n定义：描述原子连续出现的次数\n用法：\n123原子&#123;n&#125;      // 表示要前面紧邻的这个原子要匹配n次原子&#123;n,&#125;     // 表示要前面紧邻的这个原子要匹配大于等于n次：半开半闭区间 [n, +无穷)原子&#123;n,m&#125;    // 表示要前面紧邻的这个原子要匹配大于等于n次，小于等于m次：[n, m]\n特殊量词：\n\n\n特殊量词\n解释\n等价于\n\n\n\n\n*\n匹配&gt;=0次之前的原子（可存在）\n{0,}\n\n\n+\n匹配1次或多次之前的原子（存在）\n{1,}\n\n\n?\n匹配0次或1次之前的原子（可有可无）\n{0,1}\n\n\n示例：\n12/ES\\d&#123;4&#125;/     // 可以匹配到：ES000 ES2015 ES2020等/go&#123;2,&#125;gle/   // 可以匹配到：google gooooooogle等\n五 边界控制\n定义：对目标位置的控制，以^表示开始，以$表示结束。\n用法：\n1234/go&#123;2,&#125;gle/   // &quot;This is google website!&quot;  可以匹配/^go&#123;2,&#125;gle/  // &quot;This is google website!&quot;  匹配失败              // &quot;google&quot;  可以匹配\n此外边界控制还有模式单元()，小括号的作用可以将整体作为一个原子。\n12[Dd]  // 2个原子(D|d) // 1个原子\n六 修正模式\n定义：给正则表达式的匹配过程设定一种模式\n\n\n修正表达式\n解释\n\n\n\n\ni\n忽略字母大小写\n\n\ng\n执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）\n\n\nm\n执行多行匹配。\n\n\n用法：\n1/正则表达式/i\n七 贪婪模式和懒惰模式\n定义：\n贪婪模式：在条件允许的范围内，利益最大化（得寸进尺）\n懒惰模式：达到最低标准即可（不思进取）\n用法：量词后面加？表示懒惰模式\n12tasssssk   /s+/  匹配结果：sssss  (贪婪模式，可以匹配1个以上的s，那就全匹配)tasssssk   /s+?/ 匹配结果：s      (懒惰模式，可以匹配1个以上的s，那最低标准1个s)\n\n\n贪婪模式\n懒惰模式\n解释\n\n\n\n\n?\n??\n匹配0个或1个\n\n\n+\n+?\n匹配1个或多个\n\n\n*\n*？\n匹配0个或多个\n\n\n{n}\n{n}?\n匹配n个\n\n\n{n,m}\n{n,m}?\n匹配n个或者m个\n\n\n{n,}\n{n,}?\n匹配n个或者多个\n\n\n八 神奇的问号?\n正向断言：(?=原子) 表示后面必须接正向断言的原子，且匹配结果不包括该原子\n负向断言：(?!原子)表示后面不能接正向断言的原子，匹配结果不包括该原子\n12/string(?=s)/   可以匹配：strings (匹配结果：stirng)  不可以匹配：stringS stringa/string(?!s)/   可以匹配：stringS (匹配结果：string)  不可以匹配：strings\n?:产生无编号分组：\n12正则：/(ab)c(ba)/   /(?:ab)c(ba)/  /((a)(b))(c)/编号：   1    2               1         1    2\n","thumbnail":"/images/20210129/cover.png","plink":"https://blog.jschef.com/Learning/e08f36f1337d/"},{"title":"函数式编程范式","date":"2020-10-13T02:16:47.000Z","date_formatted":{"ll":"Oct 13, 2020","L":"10/13/2020","MM-DD":"10-13"},"updated":"2023-11-14T12:07:06.466Z","content":"函数式编程是一种编程范式\n\n讲解视频：https://www.bilibili.com/video/BV1vV411a7kH/\n\n \n\n一、函数式编程概念\n1.1 定义\n函数式编程（Functional Programming: FP）是一种编程范式（指计算机中编程中的典范模式或方法，就是一种思维方式），属于结构化编程，用于描述数据（函数）之间的映射关系。\n特别需要注意的是，函数式编程中的函数不是指程序中的函数（方法），而是数学中的函数（映射关系），如：y = f(x)，指x和y之间的关系。\n常见的编程范式有：过程化（命令式）编程、面向对象编程、声明式编程等。\n\n过程化编程：最原始的传统编程，将问题抽象为一系列步骤，然后通过编程方式将这些步骤转换为程序指令集，这些指令集按照一定顺序排列。人们把支持过程化编程范式的编程语言称为过程化编程语言，常见的有机器语言、汇编语言、BASIC、C、FORTRAN等。过程化语言特别适合解决线性（或者说按部就班）的算法问题。\n\n\n面向对象编程：将待解决问题抽象为面向对象的程序中的对象，利用封装使每个对象都拥有个体的身份。程序就是成堆的对象，彼此通过信息的传递，请求其它对象进行工作。面向对象包括三个基本概念：封装性、继承性、多态性。常见的面向对象语言有Java、C、C++、JavaScript。\n\n\n声明式编程：以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。SQL 语句就是最明显的一种声明式编程的例子，我们只需要定义好该如何处理数据，不需要指定具体实现，就可以查询到我们需要的数据。\n\n现代编程语言的发展趋势是支持多种范式，如C#、Java 8+、Kotlin、ES6+。\n编程范式和设计模式的区别：\n\n编程范式：是指从事软件工程的一类典型的编程风格（此概念好比“战略”），体现编写程序的人如何看待程序设计的“哲学观”；\n程序设计模式：设计模式是软件设计中常见问题的典型解决方案（此概念好比“战术”），是解决一系列实际问题的“方法学”。\n\n1.2 特性\n\n\n代码简洁：函数式编程使用了大量的函数，减少了代码的重复；\n\n\n接近自然语言，易于理解：\n123let result = （1 + 2）* 3 - 4; // 普通表达式let result = subtract(multiply(add(1, 2), 3), 4); // 函数式编程\n\n\n函数是“第一等公民”：函数与其他数据类型一样，处于平等地位，可以赋值给其它变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值；\n\n\n闭包和高阶函数：函数式编程会使用较多的闭包和高阶函数；\n\n\n没有“副作用”，方便与代码管理和单元测试：副作用 指函数内部与外部互动(最典型的情况，就是修改全局变量量的 值)，产⽣运算以外的其他结果。函数式编程强调没有&quot;副作用&quot;，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他⾏为，尤其是不得修改外部变量的值；\n\n\n引用透明：函数的运行不依赖于外部变量或&quot;状态&quot;，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。\n\n\n1.3 基本概念\n①函数式编程的思维方式：\n把现实世界的事物和事物之间的联系（映射关系）抽象到程序世界（对运算过程进行抽象）\n12// 比如买单价为0.5元的白菜，买了两斤，需要支付多少块钱（白菜与货币的联系）let money = multiply(0.5, 2); // 即两斤白菜 -&gt; 1元（money）\n②程序的本质：\n根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数。\n③函数y = f(x)：\nx → f(映射) → y\n图1 从x到y的函数关系\n\n图2 从x到y不是函数关系\n\n④纯函数：相同的输入始终要得到相同的输出\n⑤函数式编程是用来描述数据（函数）之间的映射\n1.4 学习指南\n函数式编程范式只是一种对程序编程思维的一种概论，而具体的实现则通过柯里化（第5章）、函数组合（第6章）、函子等来实现。\n在学习如何实现前，需要先了解三个小知识点：头等函数（第2章），闭包（第3章），纯函数（第4章）。\n二、头等函数\n2.1 函数是一等公民\n函数是一等公民？通俗来讲在某些编程语言中，函数是不能够：\n\n函数可以存储在变量中\n函数可以作为参数（2.2.1）\n函数可以作为返回值（2.2.2）\n\nJavaScript对待不同的数据结构具有同等级别的支持，函数可以享受以上几种待遇，所以在JavaScript中，函数是一等公民。\n函数可以存储在变量中：\n1234567891011121314151617181920// 把函数赋值给变量const fn = () =&gt; &#123;  console.log(&#x27;2.1 函数可以存储在变量中&#x27;);&#125;;fn();// 属性赋值示例const objController = &#123;  getKeys(obj) &#123; // ES6属性简写，等同于getKeys: getKeys(obj)    return Object.keys(obj);  &#125;,&#125;;// 优化：上面代码中getKeys方法和内部调用Object.keys方法的参数和返回值一样，所以可以改写成下面const objController = &#123;  getKeys: Object.keys,&#125;;console.log(objController);const my = &#123; name: &#x27;Patrick Jun&#x27;, constellation: &#x27;Virgo&#x27; &#125;;console.log(objController.getKeys(my));\n2.2 高阶函数\n如果一个函数以下面任一方式使用，那么这个函数就可以称为高阶函数。\n\n参数是一个函数\n返回值是一个函数\n\n\nPatrick Jun：可以操作函数的函数就是高阶函数。这就跟高数里的求导（二阶及以上的求导称之为高阶求导）一样，可以对已导函数的求导就是高阶求导。\n\n2.2.1 函数作为参数\n将函数作为参数最常见的就是咱们经常用的回调函数。\n12345678910111213141516171819202122232425// 遍历（模拟数组的forEach方法）function forEach(arr, fn) &#123;  for (let i = 0; i &lt; arr.length; i++) &#123;    fn(arr[i], i); // 将每一项传入回调fn处理  &#125;&#125;// 筛选，返回符合条件的元素组成的新数组function filter(arr, fn) &#123;  const results = [];  for (const item of arr) &#123;    if (fn(item)) &#123;      results.push(item);    &#125;  &#125;  return results;&#125;const colors = [&#x27;#FF0000&#x27;, &#x27;#00FF00&#x27;, &#x27;blue&#x27;];forEach(colors, (item, index) =&gt; &#123;  console.log(index + 1, item);&#125;);console.log(  filter(colors, (item) =&gt; item.length === 7),);\n2.2.2 函数作为返回值\n1234567891011121314151617181920212223242526function makeFn() &#123;  const msg = &#x27;hello function&#x27;;  return function () &#123;    console.log(msg);  &#125;;&#125;const fn = makeFn(); // makeFn()执行后返回一个匿名函数，赋值给fnfn();// makeFn()()// 模拟lodash中的once函数 对一个函数只执行一次的函数(例如支付,不管用户点击多少次按钮，都只执行一次)function once(func) &#123;  let done = false; // 定义一个状态done，判断是否已执行支付  return function () &#123;    if (!done) &#123;      done = true; // 更改闭包作用域中的done为已支付      func.apply(this, arguments);    &#125;  &#125;;&#125;const pay = once((money) =&gt; &#123;  // 传入一个函数，通过输出模拟支付过程和结果  console.log(`支付$&#123;money&#125;元`);&#125;);pay(20);  // 支付20元pay(30);pay(40);\n2.2.3 使用高阶函数意义\n\n\n抽象可以帮我们屏蔽细节，只需要关注我们的目标\n比如前面的例子：不用在乎如何遍历，只需要关注我们怎么出处理数据。不用在乎用户会不会多次点击，只需要关注如何处理支付后的流程。\n\n\n高阶函数用来抽象通用的问题\n比如前面抽象遍历问题\n\n\n2.2.4 常用高阶函数模拟\n\nmap 通过指定函数处理数组的每个元素，并返回处理后的数组。\n\n1234567891011function map(arr, fn) &#123;  const res = [];  for (const val of arr) &#123;    res.push(fn(val)); // 将回调fn()处理好的元素存入新数组  &#125;  return res;&#125;let arr = [1, 2, 3, 4, 5];arr = map(arr, (item) =&gt; item * item);console.log(arr); //[ 1, 4, 9, 16, 25 ]\n\nevery 用于检测数组所有元素是否都符合指定条件\n\n123456789101112131415161718function every(arr, fn) &#123;  let res = true; // 定义一个flag  for (const val of arr) &#123;    res = fn(val); // fn判断    if (!res) &#123; // 只要有一个元素不满足，就结束循环      break;    &#125;  &#125;  return res;&#125;const arr1 = [1, 2, 3, 4, 5];const arr2 = [4, 5, 6, 7];const res1 = every(arr1, (item) =&gt; item &gt; 3);console.log(res1);  // falseconst res2 = every(arr2, (item) =&gt; item &gt; 3);console.log(res2);  // true\n\nsome 判断数组中是否至少有一个元素满足条件\n\n123456789101112131415161718function some(arr, fn) &#123;  let res = false; // 定义一个flag  for (const val of arr) &#123;    res = fn(val); // fn判断    if (res) &#123; // 只要有一个元素满足，就结束循环      break;    &#125;  &#125;  return res;&#125;const arr1 = [1, 2, 3, 4, 5];const arr2 = [1, 3, 5, 7];const res1 = some(arr1, (item) =&gt; item % 2 === 0);console.log(res1);  // trueconst res2 = some(arr2, (item) =&gt; item % 2 === 0);console.log(res2);  // false\n\nfind 返回数组中满足提供的测试函数的第一个元素的值，如果未找到，则返回undefined\n\n123456789101112131415function find(arr, fn) &#123;  for (const item of arr) &#123;    if (fn(item)) &#123; // 找到满足条件的第一个元素      return item;    &#125;  &#125;  return undefined; // 未找到返回undefined&#125;const arr1 = [1, 2, 3, 4, 5];const res1 = find(arr1, (item) =&gt; item % 2 === 0);console.log(res1);  // 2const res2 = find(arr1, (item) =&gt; item === 8);console.log(res2);  // undefined\n\nfindIndex 找到满足条件的第一个元素，返回其位置，如果未找到，则返回-1\n\n123456789101112131415function findIndex(arr, fn) &#123;  for (let i = 0; i &lt; arr.length; i++) &#123;    if (fn(arr[i])) &#123; // 找到满足条件的第一个元素位置      return i;    &#125;  &#125;  return -1; // 未找到返回-1&#125;const arr1 = [1, 2, 3, 4, 5];const res1 = findIndex(arr1, (item) =&gt; item % 2 === 0);console.log(res1);  // 1const res2 = findIndex(arr1, (item) =&gt; item === 8);console.log(res2);  // -1\n三、闭包\n3.1 定义\n函数和其周围的状态的引用捆绑在一起形成的闭包。\n\n可以在另一个作用域中调用一个函数内部的函数并访问到该函数的作用域中的成员；\n闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕后会从执行栈上删除，但是堆上作用域成员因为被外部引用而不能被释放，因此内部函数依然可以访问到作用域的成员；\n\n特性：\n\n\n函数嵌套函数（高阶函数）\n\n\n函数内部可以引用函数外部的参数和变量\n\n\n参数和变量不会被垃圾回收机制回收\n\n\n3.2 案例\n12345678910111213141516171819202122232425262728function makePower(power) &#123;  return function (number) &#123;    return number ** power;  // number为底数，power为指数  &#125;;&#125;// 平方：number**2const power2 = makePower(2);// 立方：number**3const power3 = makePower(3);console.log(power2(5));console.log(power2(2));console.log(power3(4));function makeSalary(base) &#123;  return function (performance) &#123;    return base + performance;  &#125;;&#125;// 底层打工人const level1 = makeSalary(1000);// 高级打工人const level2 = makeSalary(10000);console.log(level1(100));  // 1100console.log(level1(120));  // 1120console.log(level2(30000));  // 40000\n打开Chrome开发者工具 &gt; Sources ：\n\nCall Stack(函数调用栈)\nScope(作用域) ： Global(var 全局) 、 Local(局部) 、 Closure(闭包) 、 Script(let 作用域)\n\n\n仅看一看演示一下，具体细节之后专门分享 ^_^\n\n12345678910111213// 查看函数栈和闭包作用域成员的访问function makeSalary() &#123;  let base = 1000;  return function (performance) &#123;    // debugger;    base += 1;    return base + performance;  &#125;;&#125;const sallary = makeSalary();console.log(sallary(100));console.log(sallary(200));\n四、纯函数\n4.1 概念\n相同的输入永远会等到相同的输出，没有任何可观察的副作用\n\nslice 和 splice 分别：纯函数和不纯函数\nslice 返回数组中的指定部分，不会改变原数组\nsplice 对数组进行操作返回该数组，会改变原数组\n\n12345678910111213141516171819// 纯函数 slice(start, end)const numbers = [1, 2, 3, 4, 5];console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]// 不纯函数 splice(index, howmany, ...items)console.log(numbers.splice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.splice(0, 3)); // [ 4, 5 ]console.log(numbers.splice(0, 3)); // []// 最简单的纯函数示例function getSum(a, b) &#123;  return a + b;&#125;console.log(getSum(1, 2)); // 3console.log(getSum(1, 2)); // 3console.log(getSum(1, 2)); // 3\n4.2 lodash\n官网：lodash\nlodash是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法。\n123456789101112131415const _ = require(&#x27;lodash&#x27;);const arr = [&#x27;Tom&#x27;, &#x27;Jon&#x27;, &#x27;Kate&#x27;];console.log(_.first(arr));console.log(_.last(arr));console.log(_.toUpper(_.last(arr)));console.log(_.reverse(arr));console.log(_.first(arr));_.each(arr, (item, index) =&gt; &#123;  console.log(item, index);&#125;);const value = [];_.isEmpty(value); // 判断一个value 是否是empty(null,[],&#123;&#125;....)\n4.3 纯函数的好处\n\n可缓存：因为纯函数相同的输入永远会等到相同的输出，所以可以把纯函数结果缓存\n\n1234567891011121314151617181920212223242526272829// 记忆函数const _ = require(&#x27;lodash&#x27;);function getArea(r) &#123;  console.log(`执行getArea计算，r = $&#123;r&#125;`);  return Math.PI * r * r;&#125;// 这里使用lodash中的记忆函数const getAreaWithMemory = _.memoize(getArea);console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(4)); // 不会再次计算console.log(getAreaWithMemory(5));// js模拟 memoize 方法的实现function memoize(f) &#123;  const cache = &#123;&#125;;  return function () &#123;    const key = JSON.stringify(arguments);    cache[key] = cache[key] || f.apply(f, arguments);    return cache[key];  &#125;;&#125;const getAreaWithMemory = memoize(getArea);console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(5));\n\n可测试：纯函数让测试更加方便，对单元化测试很友好\n并行处理：在多线程环境下并行操作共享的内存数据很可能会出现意外情况，纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker）\n\n4.4 副作用\n纯函数：指相同的输入永远会得到相同的输出，而且没有可观察的副作用，而副作用让一个函数变的不纯，纯函数根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。\n1234567891011// 不纯的函数let min = 18;function checkAge(age) &#123;  return age &gt;= min; // 依赖外部的min状态&#125;// 纯函数function checkAge2(age) &#123;  let min = 18; // 硬编码，可通过闭包或者柯里化解决  return age &gt;= min;&#125;\n副作用的来源：\n\n\n配置文件\n\n\n数据库\n\n\n获取用户的输入：\n所有的外部交互都有可能带来副作用，副作用也会使方法通用性下降、不适合扩展，同时副作用会给程序中带来安全隐患给程序员带来不确定性，但是副作用不可能完全禁止，尽可能控制他们在可控范围内发生。\n12345678910111213141516171819// 有副作用let result = 0;function sum() &#123;  const a = $(&#x27;.input-1&#x27;).val();  const b = $(&#x27;.input-2&#x27;).val();  result = a + b;&#125;// &lt;button onclick=&quot;sum()&quot;&gt;求和&lt;/button&gt;// 避免副作用function sum(a, b) &#123;    return a + b;&#125;$(&#x27;button&#x27;).bind(&quot;click&quot;, () =&gt; &#123;   const a = $(&#x27;.input-1&#x27;).val();  const b = $(&#x27;.input-2&#x27;).val();  result = sum(a, b);&#125;);// &lt;button&gt;求和&lt;/button&gt;\n\n\n五、柯里化\n柯里化（curry：咖喱）可以把多元函数转化成一元函数\n\n当一个函数有多个参数的时候，先传递一部分参数调用它（这部分参数以后永远不变）\n然后返回一个新的函数接受剩余的参数，直达参数接收完毕才返回结果\n\n5.1 柯里化示例(问题回顾)\n解决上面硬编码问题：\n1234567// 普通纯函数的方式解决function checkAge(age, min) &#123;  return age &gt;= min;&#125;console.log(checkAge(20, 18));  // trueconsole.log(checkAge(17, 18));  // falseconsole.log(checkAge(24, 22));  // true\n上面代码可以发现当基准值时18时，18是重复的 使用之前所学的闭包处理\n1234567891011121314// 闭包的方式解决（简单的柯里化）function checkAge(min) &#123;  return function (age) &#123;    return age &gt;= min;  &#125;;&#125;const checkAge18 = checkAge(18);const checkAge22 = checkAge(22);console.log(checkAge18(17)); // falseconsole.log(checkAge18(20)); // trueconsole.log(checkAge22(20)); // falseconsole.log(checkAge22(30)); // true\n使用ES6改造上面checkAge函数：\n1let checkAge = min =&gt; age =&gt; age &gt;= min;\n5.2 lodash.curry(fn)\n\n_.curry(fn)\n\n文档：https://www.lodashjs.com/docs/lodash.curry\n功能：创建一个函数，该函数接受fn的参数。如果fn所需的参数都被提供则执行fn并返回结果，否则继续返回该函数并等待接收剩余的参数。\n\n\n\n\n需要注意：传参先后顺序不能变\n\n1234567891011const _ = require(&#x27;lodash&#x27;)function getSum(a, b, c) &#123;    return a + b + c&#125;const curried = _.curry(getSum);console.log(curried(2, 3, 4));  // 9console.log(curried(2)(3)(4));  // 9console.log(curried(2)(3, 4));  // 9console.log(curried(2, 3)(4));  // 9\n\n案例\n\n1234567891011121314151617181920212223242526const _ = require(&#x27;lodash&#x27;);const match = _.curry((reg, str) =&gt; &#123;  return str.match(reg);&#125;);// 匹配所有数字const hasSpace = match(/\\s+/g);// 匹配所有空白字符const hasNumber = match(/\\d+/g);console.log(hasSpace(&#x27;helloword&#x27;)); // nullconsole.log(hasNumber(&#x27;123213 123&#x27;)); // [&quot;123213&quot;, &quot;123&quot;]console.log(hasNumber(&#x27;helloword&#x27;)); // null// 再扩展：筛选数组中指定条件的元素const filter = _.curry((func, array) =&gt; &#123;  return array.filter(func);&#125;);console.log(filter(hasSpace, [&#x27;Patrick Jun&#x27;, &#x27;Patrick_Jun&#x27;])); // [&quot;Patrick Jun&quot;]// 分步使用 = filter(hasSpace)([&#x27;Patrick Jun&#x27;, &#x27;Patrick_Jun&#x27;])const findSpace = filter(hasSpace);console.log(findSpace([&#x27;Patrick Jun&#x27;, &#x27;Patrick_Jun&#x27;])); // [&quot;Patrick Jun&quot;]\n\n\n模拟lodash中的curry方法\n小知识点：fn = (a, b, c, d, e) =&gt; &#123;&#125;;，那么fn.length = 5;\n\n\n1234567891011121314151617181920function curry(func) &#123;  return function curriedFn(...args) &#123;    // 判断形参和实参的个数    if (args.length &lt; func.length) &#123;      return function () &#123;        // 将...args与...arguments拼接传递给curriedFn        return curriedFn(...args, ...arguments);      &#125;;    &#125;    return func(...args);  &#125;;&#125;function getSum(a, b, c) &#123;  return a + b + c;&#125;const curried = curry(getSum);console.log(curried(2, 3)(4)); // 9console.log(curried(2)(3, 4)); // 9\n图解步骤：\n\n5.3 总结\n\n柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数\n这是一种对函数参数的“缓存”（闭包）\n让函数变的更灵活，让函数的粒度更小\n可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能\n\n六、函数组合\n6.1 概念\n函数组合(compose)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数。\n\n函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果\n函数组合默认是从右到左执行\n函数组合后只接受一个参数\n\n123456789101112131415161718// 函数组合演示function reverse(array) &#123;  return array.reverse();&#125;function first(array) &#123;  return array[0];&#125;function compose(f, g) &#123;  return function (value) &#123;    return f(g(value));  &#125;;&#125;const last = compose(first, reverse);console.log(last([1, 2, 3, 4])); // 4\n6.2 lodash组合函数\n6.2 lodash组合函数\nlodash中组合函数flow()或者flowRight()，他们都可以组合多个函数\nflow和flowRight会创建一个函数，返回结果是调用提供函数的结果。提供函数会连续调用，每个提供函数传入的参数都是前一个函数返回的结果。\n\nflow()是从左到右运行\nflowRight()是从右到左运行，使用的更多一些\n\n123456789const _ = require(&#x27;lodash&#x27;);const reverse = (arr) =&gt; arr.reverse();const first = (arr) =&gt; arr[0];const toUpper = (s) =&gt; s.toUpperCase();const f = _.flowRight(toUpper, first, reverse);console.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]));  // ???\n模拟lodash中的flowRight()方法：\n\n数组中的reduce() ：对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\n12345678910function compose(...args) &#123;  return function (val) &#123;    return args.reverse().reduce((acc, fn) =&gt; &#123;      return fn(acc);    &#125;, val);  &#125;;&#125;// ES6// const compose = (...args) =&gt; (val) =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), val);\n图解步骤：\n\n6.3 结合律\n函数的组合要满足结合律。\n例如compose(f,g,h)，我们既可以先把f和g组合在一起，还可以先把g和h组合：\n123456789101112console.log(compose(compose(f, g), h) == compose(f, compose(g, h))); //trueconsole.log(compose(f, g, h) == compose(f, compose(g, h))); //trueconst _ = require(&#x27;lodash&#x27;)// 下面三种写法结果运行一样const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse); // 前两个组合const f1 = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse)); // 后两个组合const f2 = _.flowRight(_.toUpper, _.first, _.reverse); // 不组合console.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]) === f1([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])); // trueconsole.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]) === f2([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])); // trueconsole.log(f1([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]) === f2([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])); // true\n6.4 实战\n题目：将NEVER SAY DIE 转换为 never-say-die;\n思路：小写，分割，join\n'NEVER SAY DIE'.toLowerCase().split(' ').join('-');\n分析：\n12345678910111213141516171819202122232425262728293031323334const _ = require(&#x27;lodash&#x27;);// 第一步：_.toLower()// 第二步：_.split()// 因为我们需要传入str变量，所以str放在最后面传入，以下同理const split = _.curry((symbol, str) =&gt; _.split(str, symbol));// 第三步：._joinconst join = _.curry((symbol, array) =&gt; _.join(array, symbol));// log用来检测数据管道中，哪部分值有错误const log = (v) =&gt; &#123;  console.log(v);  // 继续返回值给下一个fn  return v;&#125;;const f = _.flowRight(join(&#x27;-&#x27;), log, split(&#x27; &#x27;), log, _.toLower);console.log(f(&#x27;NEVER SAY DIE&#x27;)); // never-say-die// // 考虑到数据管道很长的情况，如果多次log，打印的数据不够直观，于是改造log// const _ = require(&#x27;lodash&#x27;);// const trace = _.curry((tag, v) =&gt; &#123;//   console.log(tag, v);//   return v;// &#125;);// const split = _.curry((symbol, str) =&gt; _.split(str, symbol));// const join = _.curry((symbol, arr) =&gt; _.join(arr, symbol));// const f = _.flowRight(join(&#x27;-&#x27;), trace(&#x27;after split：&#x27;), split(&#x27; &#x27;), trace(&#x27;after toLower：&#x27;), _.toLower);// console.log(f(&#x27;NEVER SAY DIE&#x27;));\n6.5 lodash/fp\nlodash/fp\nThe lodash/fp module promotes a more functional programming (FP) friendly style by exporting an instance of lodash with its methods wrapped to produce immutable auto-curried iteratee-first data-last methods.\n\n\nlodash中的fp模块提供了实用的对函数式编程友好的方法\n\n\n提供了不可变auto-curried(自动柯里化) iteratee-first data-last的方法\n\n\n12345678910111213// lodash 模块  数据优先 函数滞后const _ = require(&#x27;lodash&#x27;);_.map([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], _.toUpper); // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]_.map([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]); // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]_.split(&#x27;Hello World&#x27;, &#x27; &#x27;); // [&quot;Hello&quot;, &quot;World&quot;]const fp = require(&#x27;lodash/fp&#x27;);fp.map(fp.toUpper, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]); // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]fp.map(fp.toUpper)([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]); // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]fp.split(&#x27; &#x27;, &#x27;Hello World&#x27;); // [&quot;Hello&quot;, &quot;World&quot;]fp.split(&#x27; &#x27;)(&#x27;Hello World&#x27;); // [&quot;Hello&quot;, &quot;World&quot;]\n上面代码可以看出，lodash方法数据优先 函数滞后 ，而lodash/fp模块方法 函数优先 数据滞后 使用lodash/fp改造之前写的代码\n1234const fp = require(&#x27;lodash/fp&#x27;);const f = fp.flowRight(fp.join(&#x27;-&#x27;), fp.map(fp.toLower), fp.split(&#x27; &#x27;));console.log(f(&#x27;NEVER SAY DIE&#x27;));\nmap方法的区别：\n\nlodash中的map函数返回3个参数给callback函数\nlodash/fp中的map函数只返回1个参数给callback函数\n\n1234567const _ = require(&#x27;lodash&#x27;);const fp = require(&#x27;lodash/fp&#x27;);// (value, index|key, collection)_.map([&#x27;6&#x27;, &#x27;8&#x27;, &#x27;10&#x27;], parseInt); // [6, NaN, 2]// (value)fp.map(parseInt)([&#x27;6&#x27;, &#x27;8&#x27;, &#x27;10&#x27;]); // [6, 8, 10]\n6.6 Point Free\n我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要简单的把运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数\n\n不需要指明处理的数据\n只需要合成运算过程\n需要定义一些辅助的基本运算函数\n\n非 Point Free 模式\n1234// function f(word) &#123;  return word.toLowerCase().replace(/\\s+/g, &#x27;_&#x27;);&#125;\nPoint Free 模式\n1234const fp = require(&#x27;lodash/fp&#x27;);const f = fp.flowRight(fp.replace(/\\s+/g, &#x27;-&#x27;), fp.toLower);console.log(f(&#x27;HELLO   WORD&#x27;)); // hello-word\n案例：\n把一个字符串的首字母提取并转换成大写，使用.作为分隔符\n1234567// &#x27;word wild web  =&gt; W.W.W// const f = fp.flowRight(fp.join(&#x27;.&#x27;), fp.map(fp.first), fp.map(fp.toUpper), fp.split(&#x27; &#x27;))const fp = require(&#x27;lodash/fp&#x27;);// 解决了上面两次mapconst f = fp.flowRight(fp.join(&#x27;.&#x27;), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(&#x27; &#x27;));console.log(f(&#x27;word wild web&#x27;)); // W.W.W\n6.7 Functor(函子)\n6.7.1 函子概念\n为什么要学函子？\n到目前为止已经已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。\n什么是函子？\n作用：控制函数式编程的副作用，异常处理，异步操作等。\n\n容器：包含值和值的变形关系(这个变形关系就是函数)\n函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理(变形关系)\n\n1234567891011121314// 函子class Container &#123;  constructor(value) &#123;    this._value = value;  &#125;  map(fn) &#123;    return new Container(fn(this._value));  &#125;&#125;const r = new Container(5)  .map((x) =&gt; x + 1)  .map((x) =&gt; x * x);console.log(r); // Container &#123; _value: 36 &#125;\n函数式编程思想，避免出现new关键字：\n12345678910111213141516171819202122class Container &#123;  static of(value) &#123;    return new Container(value);  &#125;  constructor(value) &#123;    this._value = value;  &#125;  map(fn) &#123;    return Container.of(fn(this._value));  &#125;&#125;const r = Container.of(5)  .map((x) =&gt; x + 1)  .map((x) =&gt; x * x);console.log(r);// Container &#123; _value: 36 &#125;// 演示 null undefined 的问题// 副作用，因为没有返回值，所以null使fn函数变得不纯Container.of(null)  .map((x) =&gt; x.toUpperCase());\n总结：\n\n函数式编程的运算不直接操作值，而是由函子完成\n函子就是一个实现了 map 契约的对象\n我们可以把函子想象成一个盒子，这个盒子里封装了一个值\n想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理\n最终 map 方法返回一个包含新值的盒子（函子）\n\n6.7.2 Maybe函子\n\n我们在编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理\nMayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）\n\n12345678910111213141516171819202122232425// Maybe函子class Maybe &#123;  static of(value) &#123;    return new Maybe(value);  &#125;  constructor(value) &#123;    this._value = value;  &#125;  map(fn) &#123;    return this.isNothing() ? Maybe.of(null) : Maybe.of(fn(this._value));  &#125;  isNothing() &#123;    return this._value === null || this._value === undefined;  &#125;&#125;// let r = Maybe.of(&#x27;hello word&#x27;)//     .map(x =&gt; x.toUpperCase())// console.log(r)//Maybe &#123; _value: &#x27;HELLO WORD&#x27; &#125;const r = Maybe.of(null)  .map((x) =&gt; x.toUpperCase());console.log(r); // Maybe &#123; _value: null &#125;\nMaybe函子虽然解决了空值问题，不会出现异常。但当多次调用map时，不能确定哪次出现了空值\n1234const r = Maybe.of(&#x27;hello word&#x27;)  .map((x) =&gt; null)  .map((x) =&gt; x.toUpperCase());console.log(r); // Maybe &#123; _value: null &#125;  不确定哪出现了null\n6.7.3 Either函子\n\nEither 两者中的任何一个，类似于 if…else…的处理\n异常会让函数变的不纯，Either 函子可以用来做异常处理\n\n12345678910111213141516171819202122232425262728293031// Either 函子class Left &#123;  static of(val) &#123;    return new Left(val);  &#125;  constructor(value) &#123;    this._value = value;  &#125;  map(fn) &#123;    return this;  &#125;&#125;class Right &#123;  static of(val) &#123;    return new Right(val);  &#125;  constructor(value) &#123;    this._value = value;  &#125;  map(fn) &#123;    return Right.of(fn(this._value));  &#125;&#125;const r1 = Left.of(12).map((x) =&gt; x + 2);const r2 = Right.of(12).map((x) =&gt; x + 2);console.log(r1, r2); // Left &#123; _value: 12 &#125; Right &#123; _value: 14 &#125;\nLeft函子可以记录错误信息处理异常，Right函子对参数处理\n1234567891011121314function parseJSON(str) &#123;  try &#123;    return Right.of(JSON.parse(str));  &#125; catch (e) &#123;    return Left.of(&#123;      error: e.message,    &#125;);  &#125;&#125;const r = parseJSON(&#x27;&#123;&quot;name&quot;:&quot;tom&quot;&#x27;);console.log(r); // Left &#123; _value: &#123; error: &#x27;Unexpected end of JSON input&#x27; &#125; &#125;const r3 = parseJSON(&#x27;&#123;&quot;name&quot;:&quot;tom&quot;&#125;&#x27;)  .map((x) =&gt; x.name.toUpperCase());console.log(r3); // Right &#123; _value: &#x27;TOM&#x27; &#125;\n6.7.4 IO函子\n\nIO函子中的 _value 是一个函数，这里是把函数作为值来处理\nIO函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作（惰性执行），包装当前的纯操作\n把不纯的操作交给调用者来处理\n\n1234567891011121314151617181920212223242526// IO 函子const fp = require(&#x27;lodash/fp&#x27;);class IO &#123;  static of(value) &#123;    return new IO((() =&gt; value));  &#125;  constructor(fn) &#123;    this._value = fn;  &#125;  map(fn) &#123;    return new IO(fp.flowRight(fn, this._value));  &#125;&#125;// 调用// 这里的p就是proccess// 返回了一个新的IO，并将p.execPath的返回存储为r._valuelet r = IO.of(process).map((p) =&gt; p.execPath);// 为了更好的理解： fp.upperCase(str01) 的值作为p，传入fp.reverse(p),然后将fp.reverse(p)的值传入r._valuer = IO.of(fp.upperCase(&#x27;patrick jun&#x27;)).map((p) =&gt; fp.reverse(p));// console.log(r)console.log(r._value());\nIO函子控制了副作用在可控范围内发生\n1234567891011121314151617181920212223242526272829303132333435// IO 函子的问题const fs = require(&#x27;fs&#x27;); // node.js require(&#x27;fs&#x27;)const fp = require(&#x27;lodash/fp&#x27;);console.log(fs);class IO &#123;  static of(value) &#123;    return new IO((() =&gt; value));  &#125;  constructor(fn) &#123;    this._value = fn;  &#125;  map(fn) &#123;    return new IO(fp.flowRight(fn, this._value));  &#125;&#125;const readFile = function (filename) &#123;  return new IO((() =&gt; fs.readFileSync(filename, &#x27;utf-8&#x27;)));&#125;;const print = function (x) &#123;  return new IO((() =&gt; &#123;    console.log(x);    return x;  &#125;));&#125;;const cat = fp.flowRight(print, readFile);// IO(IO(x))// 第一个_value是printd的执行结果readFile，第二个才是我们想要的最终结果const r = cat(&#x27;../../package.json&#x27;)._value()._value();console.log(r);\n6.7.5 Task异步执行\n\n\n异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示\n\n\nfolktale 一个标准的函数式编程库\n\n\n\n和 lodash、ramda 不同的是，他没有提供很多功能函数\n只提供了一些函数式处理的操作，例如：compose、curry 等，一些函子 Task、Either、MayBe 等\n\n\n\n123456789101112131415const &#123;    compose,    curry&#125; = require(&#x27;folktale/core/lambda&#x27;)const &#123;    toUpper,    first&#125; = require(&#x27;lodash/fp&#x27;)let f = curry(2,(x,y)=&gt;x+y)console.log(f(1,2))//3console.log(f(1)(2))//3let f1 = compose(toUpper, first)console.log(f1([&#x27;one&#x27;, &#x27;tow&#x27;]))//ONE\n使用folktale中的Task函子执行异步任务\n1234567891011121314151617181920212223242526const fs = require(&#x27;fs&#x27;)const &#123;    task&#125; = require(&#x27;folktale/concurrency/task&#x27;)function readFile(filePath) &#123;    return task(resolver =&gt; &#123;        fs.readFile(filePath, &#x27;utf-8&#x27;, (err, data) =&gt; &#123;            if (err) &#123;                resolver.reject(err)            &#125;            resolver.resolve(data)        &#125;)    &#125;)&#125;readFile(&#x27;../package.json&#x27;)    .map(data =&gt; JSON.parse(data))    .map(data =&gt; data.version)    .run().listen(&#123;        onRejected: err =&gt; &#123;            console.log(err)        &#125;,        onResolved: data =&gt; &#123;            console.log(data)        &#125;    &#125;)\n6.7.6 Pointed函子\n\nPointed 函子是实现了 of 静态方法的函子\nof 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文Context（把值放到容器中，使用 map 来处理值）\n\n1234567891011121314class Container &#123;    static of (value) &#123;        return new Container(value)    &#125;    constructor(value) &#123;        this._value = value    &#125;    map(fn) &#123;        return new Container(fn(this._value))    &#125;&#125;let r =Container.of(2)        .map(x =&gt; x + 5)console.log(r)//Container &#123; _value: 7 &#125;\n6.7.7 Monad函子\n\nMonad 函子是可以变扁的 Pointed 函子，IO（IO（x））\n一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个Monad\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// IO Monadconst fs = require(&#x27;fs&#x27;)const fp = require(&#x27;lodash/fp&#x27;)class IO &#123;  static of (value) &#123;    return new IO(function () &#123;      return value    &#125;)  &#125;  constructor (fn) &#123;    this._value = fn  &#125;  map (fn) &#123;    return new IO(fp.flowRight(fn, this._value))  &#125;  join () &#123;    return this._value()  &#125;  flatMap (fn) &#123;    return this.map(fn).join()  &#125;&#125;let readFile = function (filename) &#123;  return new IO(function () &#123;    return fs.readFileSync(filename, &#x27;utf-8&#x27;)  &#125;)&#125;let print = function (x) &#123;  return new IO(function () &#123;    console.log(x)    return x  &#125;)&#125;//为解决IO函子的问题，这样更符合函数式编程！let r = readFile(&#x27;package.json&#x27;)          // .map(x =&gt; x.toUpperCase())          .map(fp.toUpper)          //因为readFile返回一个IO函子，所以调用flatMap          .flatMap(print)          //因为flatMap返回一个函子，所以调用join，返回_value          .join()console.log(r)\n七、总结\n\n函数式编程是一种强调以函数使用为主的软件开发风格；\n纯函数指没有副作用的函数，相同的输入有相同的输出；\n在函数式编程里面，将多个不同函数组合是一个非常非常非常重要的思想；\n函数式编程将函数视为积木，通过一些高阶函数来提高代码的模块化和可重用性。\n\n\n理解：柯里化是”因式分解“，将参数分解开；函数组合是”结合律“，函数可以组合使用。\n\n参考文章：\n\n概念定义特点：https://juejin.im/post/6858129115598635015\n\n\n函数式编程讲解：https://juejin.im/post/6844903743117361165\n\n\n函数式编程讲解：https://juejin.im/post/6844903655397654535\n\n\n拉勾教育大前端训练营笔记： https://zhuanlan.zhihu.com/p/162839608\n\n\nwhat are “first class objects”：https://stackoverflow.com/questions/245192/what-are-first-class-objects\n\n","thumbnail":"/images/20201013/cover.jpg","plink":"https://blog.jschef.com/Learning/86cd6788d8fb/"},{"title":"JavaScript新特性","date":"2020-08-07T13:49:12.000Z","date_formatted":{"ll":"Aug 7, 2020","L":"08/07/2020","MM-DD":"08-07"},"updated":"2023-11-14T12:07:06.466Z","content":"一、前言\n我这里总结了一下ES6+中，一些比较实用的新特性。我们日常开发应该尽快使用这些新特性，能极大地提高我们的开发效率。\n我刚开始实习的时候，对ES6都不太怎么了解，工作后学习并渐渐运用起来，越用越爽，两个字：简洁方便高效。\n提一句：只要用了babel，所有的新特性请放心大胆地用。\n二、你得尽快用上的“新特性”\n\n为什么加引号，因为现在这些都不是多新的特性了，ES6是2015年就出了，到现在已经5年了。\n\n2.1 模板字符串\n模版字符串：用 `（反引号）标识，用 ${} 将变量括起来\nold：\n场景：通常我们在自定义一些echarts或者地图上添加东西时，我们常会拼接一些html代码\n1var html = &#x27;&lt;div style=&quot;color: &#x27; + color + &#x27;;&quot;&gt;&#x27; + str + &#x27;&lt;div&gt;&#x27;\n传统做法需要使用大量的“”（引号）和 + 来拼接才能得到我们需要的模版\nnew：\n1let html = `&lt;div style=&quot;color: $&#123;color&#125; ;&quot;&gt; $&#123;str&#125; &lt;div&gt;`\n$&#123;&#125; 里可以放任意的JavaScript表达式，也可以调用函数：\n123456789const count = 8, price = 10;console.log(`加购一个后数量：$&#123;++count&#125;, 总价：$&#123;count*price&#125;`);   // 加购一个后数量：9, 总价：90console.log(`输出个字符串：$&#123;&#x27;cool&#x27;&#125;`); // 输出个字符串：coolfunction myLove() &#123;    return &quot;as you love!&quot;;&#125;console.log(`I love $&#123;myLove()&#125;`);   // I love as you love!\n需要注意的几个问题：\n\n\n当需要在字符串里使用反引号的时候，需要转义；\n1console.log(`模版字符串：用 \\`（反引号）标识`);\n\n\n如果$&#123;&#125;中的变量不是字符串类型，那么会按照一般的规则转化为字符串；\n12const obj = &#123;a:1, b:2&#125;;console.log(`a = $&#123;obj&#125;`);   // a = [object Object]\n\n\n模板字符串会保留所有的空格、缩进和换行；\n12345let str = `I know   \t, you know!`;console.log(str);//  I know   //\t , you know!\n解决方案：使用\\解决换行符；使用+换行拼接；使用正则替换；使用变量替换；\n1234567891011121314151617let str = `I know   \\\t, you know!`;console.log(str);  // I know   \t, you know!str = `I know   `\t+ `, you know!`;console.log(str); // I know   , you know!str = (`I know\t, you know!`).replace(/\\s+/gm, &#x27; &#x27;);console.log(str); // I know , you know!const N = &#x27;&#x27;;str = (`I know$&#123;\t\tN&#125;, you know$&#123;\t\tN&#125;, all we know!`);console.log(str); // I know, you know, all we know!\n\n\n扩展了解：\n实现原理（未验证）：通过正则匹配，替换原字符串中的变量。包括常见的{{}}, &lt;%=xx%&gt;等\n12345function replace(str)&#123;    return str.replace(/\\$\\&#123;([^&#125;])\\&#125;/g,function(matched,key)&#123;          return eval(key)    &#125;)&#125;\n2.2 属性简写\nold：\n一个属性名对应一个值\n12345const pageIndex = 0, pageSize = 10;const params = &#123;    pageNum: pageIndex,    pageSize: pageSize&#125;\nnew：\n属性名和变量名保持一致，变量名尽量迎合属性名；\n12345678910const pageNum = 0, pageSize = 10, password = &#x27;123123&#x27;;const params = &#123;    pageNum,    pageSize,    password: encrypt(password)  // 属性简写和键值对可以混写&#125;// const params = &#123;//     pageNum: pageNum,//     pageSize: pageSize// &#125;\nquestion：\n\n\n如果我们的需要的值不是一个单独变量，而是从某个对象取出属性\n123456const pageNum = 0, pageSize = 10, user = &#123;uid: 100000, password: &#x27;123123&#x27;&#125;;const params = &#123;    pageNum,    pageSize,    user.password  ????&#125;\n答案：见第四章\n\n\n2.3 方法属性\nold：\n一个属性名对应一个值\n12345let math = &#123;  add: function(a,b) &#123; return a + b; &#125;,  sub: function(a,b) &#123; return a - b; &#125;,   multiply: function(a,b) &#123; return a * b; &#125;&#125;\nnew：\n自动识别方法名称作为属性名\n12345let math = &#123;  add(a,b) &#123; return a + b; &#125;,  sub(a,b) &#123; return a - b; &#125;,  multiply(a,b) &#123; return a * b; &#125;&#125;\n取函数名为属性名称\n微信小程序page结构：\n1234567891011121314151617Page(&#123;    data: &#123;        isShowloading: true    &#125;,    onLoad(options) &#123;            &#125;,    onReady () &#123;    &#125;,        handleTap(event) &#123;            &#125;&#125;)// 给page传入一个对象，这个对象的所有函数都可以进行属性名简写\nquestion:\n下面两个表达式都正确吗？\n1234567let obj1 = &#123;    fn1()&#123;&#125;.bind() &#125;let obj2 = &#123;    fn2: function()&#123;&#125;.bind() &#125;\n2.4 箭头函数\n箭头函数表达方式：=&gt;，因为像个箭头，所以叫箭头函数。\nold：\n123var f = function (v) &#123;  return v;&#125;;\nnew：\n12345// 写法let f = v =&gt; v;// 完整写法let f = (v) =&gt; &#123; return v; &#125;;\n如上，当函数只有一个形参时，=&gt;左侧可以省略()；\n当函数返回值可以用一句简单表达式表示时，=&gt;右侧可以省略&#123;&#125;和return；\n1234567let f = () =&gt; 5;   // ()不可省略let sum = (num1, num2) =&gt; num1 + num2;//var sun = function(num1, num2)&#123;return num1 + num2;&#125;;this.httpUtil.get(&#x27;xxxxxx.vm&#x27;, params, true, res =&gt; &#123;  console.log(res)&#125;);\nquestion:\n以下会输出什么？\n12let getTempItem = () =&gt; &#123; id: &#x27;s8309a82n&#x27;, name: &quot;Temp&quot; &#125;;getTempItem();\n2.5 “你懂的”运算符\nSpread operator，这个中文名称有好几种说法（扩展运算符、延展操作符、展开运算符等等），而我给它起的名字就叫你懂的运算符。它表示方法前面见过了...，作用是可以将数组、字符串、对象等在语法层面上展开。\n秘诀：给我“解压”到这里\n\n\n“解压”数组\n12345678const rgb = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];const colors = [...rgb]; // 巴啦啦魔仙变，给我把rgb解压到这个数组里// 结果： [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]const colorList = [&#x27;yellow&#x27;, ...rgb]; // [&#x27;yellow&#x27;, &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]console.log([...colors, ...colorList]);  // ????\n\n\n“解压”对象\n123456789let you = &#123;    name: &#x27;DJ&#x27;,    age: 16&#125;you = &#123;    ...you,    school: &#x27;DLPU&#x27;&#125;// &#123;name: &quot;DJ&quot;, age: 16, school: &quot;DLPU&quot;&#125;\n\n\n“解压”字符串\n1234567let myCountry = &#x27;China&#x27;;console.log([...myCountry]);  // [&quot;C&quot;, &quot;h&quot;, &quot;i&quot;, &quot;n&quot;, &quot;a&quot;]// 等同于：console.log(myCountry.split(&#x27;&#x27;))cosnt resStr = &#123;...myCountry&#125;;console.log(resStr);  // &#123;0: &quot;C&quot;, 1: &quot;h&quot;, 2: &quot;i&quot;, 3: &quot;n&quot;, 4: &quot;a&quot;&#125;// 问题：怎么取值呢？  resStr[0]\n\n\nquestion:\n以下分别会输出什么？\n123456789let obj = &#123;a: 1, b: 2&#125;;console.log(&#123;a: 0, ...obj&#125;); ????let arr = [2,3,4];console.log(&#123;...arr&#125;)????console.log([...obj]);????\n扩展了解：见下一章\n2.6 解构赋值\nold:\n获取对象中的值\n123456789// res = &#123;status: 200, data: &#123;uid: &#x27;ed9fa0&#x27;, name: &#x27;DJ&#x27;, time: &#x27;1596808152&#x27;&#125;&#125;this.thsService.getLog().then(res=&gt;&#123;    const status = res.status;    const data = res.data;    const name = res.data.name;    const time = res.data.time;        console.log(status, data, name, time);&#125;)\nnew:\n123456789101112this.thsService.getLog().then(res=&gt;&#123;    const &#123; status, data &#125; = res;        const &#123; status, data, data: &#123; name, time &#125; &#125; = res;        // console.log(status, data, name, time);&#125;)// 还可以这样写this.thsService.getLog().then(&#123; status, data &#125;=&gt;&#123;    console.log(status, data);&#125;)\n数组：\n123let arr = [1, 2, 3, 4];let [a, b, c] = arr;     // a=1, b=2, c=3let [a, b, , d] = arr;\t // a=1, b=2, d=4\n默认值：\n12const &#123; status = 500, data = null &#125; = res;let [a=0, b=0, c=0, d=0, e=0] = arr;\n扩展了解：\n剩余运算符（ES2018）\n秘诀：“剩下的”都是我的\n\n\n“剩下的”属性\n1234let obj = &#123;a: 1, b: 2, c: _ =&gt; _&#125;;let &#123;b, ...rest&#125; = obj;  // rest说：b属性你拿走吧，剩下的全是我的b   \t\t// 2rest\t\t// &#123;a: 1, c: ƒ&#125;\n\n\n“剩下的”参数\n12345let restParam = (p1, p2, ...p3) =&gt; &#123;  // p3说：前两个参数你们拿走，剩下的都是我的了    console.log(p1, p2, p3);&#125;;restParam(1,2,3,4,5);   // p1 = 1, p2 = 2, p3 = [3, 4, 5]\n\n\n2.7 数组新方法\n\nfind(): any：返回找到满足条件的第一项，否则返回undefined\nfindIndex(): number：找到满足条件的一项的索引\nincludes(): boolean：是否包含一个值\n\n在ES6之前，要判断一个数组中是否包含一个元素，是通过indexOf()返回不等于-1\nES6之后，相继扩充一些方法：\nfind( fn(item, [index], [arr]) ):\n1234let arr = [&#123; id: 1, checked: true &#125;, &#123; id: 2 &#125;, &#123; id: 2 &#125;, 3, 4, NaN];arr.find( item =&gt; item.id === 1 );  // &#123; id: 1, checked: true &#125;arr.find( item =&gt; Object.is(NaN, item) );  // NaN\nfind会将每一个元素挨个去运行回调函数，找到了第一项之后就不会再执行了；\nfindIndex( fn(item, [index], [arr]) ):\n12arr.findIndex( item =&gt; item.id === 1 );  // 0arr.findIndex( item =&gt; Object.is(NaN, item) );  // 5\nincludes(value, fromIdx):\n12345678arr.includes(3);         // truearr.includes(NaN);       // truearr.includes(&#123; id: 2 &#125;)  // falselet a1 = &#123;id: 2&#125;, a2 = &#123;id: 2&#125;;a1 == a2;          // falselet a = [a1, a2];  // [&#123;id: 2&#125;, &#123;id: 2&#125;]a.includes(a2);    // true\n字符串同样存在includes方法：'Made in China'.includes('o'), false\nsome( fn(item, [index], [arr]) )：是否存在满足条件的一项，和includes是同样的作用。\n区别（优缺点）：some传入的是回调函数，具有更强大的可操性；includes传入参数是具体的值，书写简便。\nquestion:\nfind()只能取出满足条件的一项，那如何取出数组中满足条件的所有项呢？\n12let arr = [&#123; id: 1, checked: true &#125;, &#123; id: 2 &#125;, &#123; id: 2 &#125;, 3, 4, NaN];// ???? \n扩展：数组所有方法参考手册\n2.8 Promise、async/await\n\n\n回调地狱：“无限”（大量）地使用嵌套回调函数，好像掉进了18层地狱\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 一个动画的回调地狱例子animate(ball1, 100, function () &#123;  animate(ball2, 200, function () &#123;    animate(ball3, 300, function () &#123;      animate(ball1, 200, function () &#123;        animate(ball3, 200, function () &#123;          animate(ball2, 180, function () &#123;            animate(ball2, 220, function () &#123;              animate(ball2, 200, function () &#123;                console.log(&quot;over&quot;);              &#125;)            &#125;)          &#125;)        &#125;)      &#125;)    &#125;)   &#125;)&#125;);// promise优化后promiseAnimate(ball1, 500)    .then(function () &#123;      return promiseAnimate(ball2, 200);    &#125;)    .then(function () &#123;      return promiseAnimate(ball3, 300);    &#125;)    .then(function () &#123;      return promiseAnimate(ball1, 200);    &#125;)    .then(function () &#123;      return promiseAnimate(ball3, 200);    &#125;)    .then(function () &#123;      return promiseAnimate(ball2, 180);    &#125;)    .then(function () &#123;      return promiseAnimate(ball2, 220);    &#125;)    .then(function () &#123;      return promiseAnimate(ball2, 200);    &#125;)// async/await优化后async play() &#123;    await animate(ball1, 500);    await animate(ball2, 200);    await animate(ball3, 300);    await animate(ball1, 200);    await animate(ball4, 200);    await animate(ball2, 180);    await animate(ball2, 220);    await animate(ball2, 200);&#125;\n\n\nPromise:\n基本用法：\n12345678910111213141516171819202122232425262728293031function getUserData() &#123;    return new Promise((resolved, rejected) =&gt; &#123;        $.ajax(&#123;            type : &quot;get&quot;,            url : &quot;api.com&quot;,            success : res =&gt; &#123;                if(res.isSuccess) &#123;                    resolved(res.data);                &#125;else &#123;                    rejected(&#123;msg: &#x27;服务器错误&#x27;, info: res.errmsg&#125;);                &#125;            &#125;,            error: err =&gt; &#123;                rejected(&#123;msg: &#x27;网络错误&#x27;, info: err&#125;);            &#125;        &#125;);    &#125;)&#125;getUserData().then(data =&gt; &#123;    console.log(&#x27;success:&#x27;, data);&#125;).catch(err =&gt; &#123;    console.log(err.msg, err.info);&#125;)// 此外介绍一个方法，并行跑promise es2020有个新方法Promise.allSettledPromise.all([promise1, promise2, ...]).then(res =&gt; &#123;    console.log(res); // 由promise1,promise2正确执行结果组成的数组&#125;).catch(err =&gt; &#123; \tconsole.log(err);&#125;)\nasync/await：\n是对Promise的优化，为Promise服务。一句话：用同步的风格写异步代码。\n基础用法：https://www.zzboy.cn/post/1589841597\n需要注意：\n\nasync/await 就是一对“海尔兄弟”，缺一不可。async声明一个函数（函数返回会处理成一个Promise），函数里面必须要有await，await标识一个需要等一会（异步）的操作。函数内部使用了await，那么该函数就必须用async声明。\nawait、return和return await的陷阱：https://jakearchibald.com/2017/await-vs-return-vs-return-await/\n\n2.9 Modules\n模块化是ES6比较重要的特性，在此之前JS是不支持原生的模块化的，需要通过第三方库实现如RequireJS。\n\n了解更多模块化：JavaScript模块化\n\n模块化由export 和  import 组成，ES6视一个文件为一个模块，文件内通过export对外暴露接口，其他文件通过import引入使用。\nexport：可导出变量、常量和函数\n12345678910111213141516171819// utils/test.js// 单个导出export let name = &#x27;Patrick Jun&#x27;;export const pi = Math.PI;export function whoIAm() &#123;    console.log(&quot;I&#x27;m a FE coder!&quot;);&#125;// 等同于（会将export作为一个对象导出）let name = &#x27;Patrick Jun&#x27;;const pi = Math.PI;const whoIAm = () =&gt; console.log(&quot;I&#x27;m a FE coder!&quot;);export &#123; name, pi, whoIAm &#125;;// this is an object, so.export &#123; name: name, PI: pi, iAm: whoIAm &#125;;\nimport：导入\n123456// home.jsimport &#123; name, pi, whoIAm &#125; from &#x27;./utils/test.js&#x27;;console.log(name, pi);whoIAm();// Patrick Jun 3.141592653589793      main.js:2 // I&#x27;m a FE coder!                    test.js:11  \n\nnode无法直接运行module：https://nodejs.org/dist/latest-v10.x/docs/api/esm.html\n\ndefault：只能有一个\n123456789// math.jsexport function add(a,b) &#123; return a + b; &#125;export function sub(a,b) &#123; return a - b; &#125;export default (a,b) =&gt; a * b;// main.jsimport mult, &#123; add, sub &#125; from &#x27;./math&#x27;;\n三、你可以尝试的新特性\n3.1 对象新方法\n\n\nObject.values(obj): 返回由对象zhogn suozhi 组成的数组；\n\n\nObject.entries(obj): 返回对象的每个属性建和值组成的数组：[[key, value],[key, value]]\n\n\n之前通过Object.keys()，可以获取到对象的所有的key，而要获得value值的时候：\n123456let obj = &#123;id: 1, value: &#x27;123&#x27;, data: &#123;code: &#x27;EC109&#x27;&#125;&#125;;Object.keys(obj); // [&quot;id&quot;, &quot;value&quot;, &quot;data&quot;]Object.keys(obj).forEach((key) =&gt;&#123;    console.log(obj[key]); // [1, &quot;123&quot;, &#123;code: &#x27;EC109&#x27;&#125;]&#125;);\nObject.values()：无需先获取键名，直接可以拿到所有值\n1Object.values(obj); // [1, &quot;123&quot;, &#123;code: &#x27;EC109&#x27;&#125;]\nObject.entries():\n12345Object.entries(obj).forEach(([key, value]) =&gt;&#123;      console.log(key + &quot;: &quot; + value);&#125;)// id: 1// value: 123\n3.2 **\n指数操作符：类似数学的书写方式进行指数计算，可以看做是Math.pow()的简写\n1let a = 7 ** 3;   // a = 343，等同于 a = Math.pow(7, 3)\n3.3  ??\n当我们查询某个属性时，经常会给没有该属性就设置一个默认的值，比如下面两种方式：\n12let c = a ? a : b // 方式1let c = a || b // 方式2\n这两种方式有个明显的弊端，它都会覆盖所有的假值，如(0, ‘’, false)，这些值可能是在某些情况下有效的输入。\n空位合并操作符，用 ?? 表示。如果表达式在??的左侧运算符求值为 undefined 或 null，就返回其右侧默认值。\n12let c = a ?? b;// 等价于let c = a !== undefined &amp;&amp; a !== null ? a : b;\n3.4 padStart/padEnd\n用于在字符串开头或结尾添加填充字符串（ES2017）\n\npadStart(maxLength, [fillString])：从前面补充字符\npadEnd(maxLength, [fillString])：从后面补充字符\n\n1234567891011&#x27;es8&#x27;.padStart(2);          // &#x27;es8&#x27;&#x27;es8&#x27;.padStart(5);          // &#x27;  es8&#x27;&#x27;es8&#x27;.padStart(6, &#x27;woof&#x27;);  // &#x27;wooes8&#x27;&#x27;es8&#x27;.padStart(14, &#x27;wow&#x27;);  // &#x27;wowwowwowwoes8&#x27;&#x27;es8&#x27;.padStart(7, &#x27;0&#x27;);     // &#x27;0000es8&#x27;&#x27;es8&#x27;.padEnd(2);          // &#x27;es8&#x27;&#x27;es8&#x27;.padEnd(5);          // &#x27;es8  &#x27;&#x27;es8&#x27;.padEnd(6, &#x27;woof&#x27;);  // &#x27;es8woo&#x27;&#x27;es8&#x27;.padEnd(14, &#x27;wow&#x27;);  // &#x27;es8wowwowwowwo&#x27;&#x27;es8&#x27;.padEnd(7, &#x27;6&#x27;);     // &#x27;es86666&#x27;\n应用场景：\n1234567891011const dt = new Date();console.log(    `$&#123;dt.getFullYear()+&#x27;&#x27;&#125;-`    +`$&#123;(dt.getMonth()+1+&#x27;&#x27;).padStart(2, &#x27;0&#x27;)&#125;-`    +`$&#123;(dt.getDate()+&#x27;&#x27;).padStart(2, &#x27;0&#x27;)&#125;`);// 2020-08-07let timestamp = &#x27;1596808152&#x27;;timestamp = +String(timestamp).padEnd(13, &#x27;0&#x27;);// 1596808152000\n四、答案\n2.2 question:\n1234567const pageNum = 0, pageSize = 10, user = &#123;uid: 100000, password: &#x27;123123&#x27;&#125;;const params = &#123;    pageNum,    pageSize,    ...user&#125;// &#123;pageNum: 0, pageSize: 10, uid: 100000, password: &quot;123123&quot;&#125;\n2.3 question:  obj1错误，obj2正确。简写方法的属性名总是变量本身作为字符串使用，bind函数本身返回一个函数，从解析器角度来说，这个返回的函数叫什么名字并没有办法确定，而第二种写法，是确定好了fn2\n2.4 question:\n123Uncaught SyntaxError: Unexpected token &#x27;:&#x27;let getTempItem = id =&gt; (&#123; id, name: &quot;Temp&quot; &#125;);\n2.5 question:\n123456&#123;a: 1, b: 2&#125;&#123;0: 2, 1: 3, 2: 4&#125;   // result.0 ????VM37:1 Uncaught TypeError: obj is not iterable    at &lt;anonymous&gt;:1:17\n2.7 question:\n1arr.filter( item =&gt; item.id === 2 );  // [&#123;id: 2&#125;, &#123;id: 2&#125;]\n五、参考资料\n\n\nModern JavaScript, 10 things you should be using, starting today - DEV\n\n\n\n\n盘点ES7、ES8、ES9、ES10新特性\n\n\n\n\nES6，ES7，ES8，ES9，ES10新特性一览\n\n\n\n\nES2020新特性\n\n\n\n\n种草 ES2020 新特性\n\n\n\n\n异步Promise及Async/Await可能最完整入门攻略\n\n\n刘哥金句：给别人讲述知识时可以发现自己掌握的是否牢固透彻，写的过程不断发现自己的不足，然后通过一些方式来解决问题，这也是一种学习过程；当然，给别人分享，也要从学习者的角度出发，考虑他们想要从你的分享中获得什么，还有就是你想表达些什么给他们。\n","thumbnail":"/images/20200807/cover.jpg","plink":"https://blog.jschef.com/Learning/75dfaa707e38/"},{"title":"毕业设计-“跑鸭”微信小程序","date":"2020-06-17T01:13:40.000Z","date_formatted":{"ll":"Jun 17, 2020","L":"06/17/2020","MM-DD":"06-17"},"updated":"2023-11-14T12:07:06.466Z","content":"这是我的毕业设计：一款基于校园运动的社交小程序\n功能：跑步 + “仿朋友圈” + 在线活动\n技术栈：前端 JS / Less / Vant-Weapp / Iview-Weapp、后端 PHP7 / Laravel / MySQL\n\n一、写前BB\n毕业设计我有两个想法，另外一个是人生经验树想法，难点在于UI的设计，通过技术调研发现echarts是无法实现的，只能通过D3，我对于交互美化这块在指定时间内能完成心里没有个底，所以放弃了那个想法。下面是这个想法的具体内容：\n\n点击查看我另一个想法\n人一生会经历很多选择，不同人选择走不同的路因此有了不同的人生。\n我想做一个大家可以共同参与编辑的一个颗人生经验树，以某个时间点为根，按照自己选择的方向建立分支；\n在支点填下自己选择的理由，在枝丫上记录之后的学习经验或者失败经验；\n之后在下一次新的选择时，就在这个枝丫上建立分支，依次细分下去；\n这样可以为以后有做出同样选择的人参考，看看部分成功人士的每一次选择以及做法，也可以记录自己的成长，导出自传。\n程序分三大块：世界经验树、个人经历时间轴、个人中心\n（1）世界经验树(类似地图设计)：\n一棵大树，展现部分枝丫，枝丫尖展现点赞和评论较多的人名。可以放大查看，即展现视区点赞较高的人；\n个人快速定位，可进行编辑分支；\n顶部关键词搜索，查看想看的人的人生轨迹；\n（2）个人经历时间轴：供自己参考个人历史，让自己时常反思\n（3）个人中心：设置\n难点：UI交互、数据库设计\n\n最终选择的这个想法是在我大二的时候就有的了，就是做一款跑步程序，难点在于任务量太多（事实证明，工作量确实大，大概花了3个月实现，期间还有一个小姐姐帮我分担了两个页面）。\n二、功能设计\n”跑鸭“微信小程序的核心功能就是：跑步+社交+活动，详细划分如下：\n（1）跑步（首屏）：当前位置地图、排行榜（周榜、月榜）、运动路径、实时数据（里程、配速）、随机一言。\n（2）动态圈子：打卡分享、发布分享、热门推荐、点赞评论、消息通知。\n（3）活动广场：线上活动（报名、完赛条件、奖励）、跑步教程。\n（4）个人中心：运动管理、动态管理、设置（通用设置、隐私设置）、勋章墙、等级称号、个人主页、资料编辑。\n三、数据库设计\n根据功能分析，一共规划出11个实体，形成E-R图：\n\n由E-R图，共转换成16张表（每张表均含有创建时间和更新时间，以下没有列出）：\n\n展开查看详细列表\n（1）用户表（r_users）：（编号（主键）,微信openid，昵称，校区，性别，头像，职业，个人签名）；\n（2）运动记录表（r_runs）：（编号（主键），用户编号（外键），里程，卡路里，最高配速，最低配速，平均配速，开始时间，结束时间，运动时间，起点维度，起点经度，终点经度，终点维度，分享）；\n（3）称号表（r_honors）：（编号（主键），称号描述，称号名称）；\n（4）勋章表（r_medals）：（编号（主键），标识符，类型，名称，简介，图标）；\n（5）动态表（r_moments）：（编号（主键），用户编号（外键），动态内容，动态类型，动态位置，位置经度，位置维度）；\n（6）活动表（r_activitys）：（编号（主键），勋章编号（外键），封面图编号（外键），标题，简述，活动内容，达成条件，截止时间）；\n（7）教程表（r_courses）：（编号（主键），标题，内容）；\n（8）隐私设置表（r_settings）：（用户编号（外键），职业设置，校区设置，运动设置）；\n（9）系统信息表（r_notices）：（编号（主键），发出者编号（外键），接收者编号（外键），类型，已读，内容）；\n（10）图片表（images）：（编号（主键），标识符，标识编号，原名称，存储名称，后缀，图片格式，大小，宽，高，压缩宽，压缩高，原图地址，压缩图地址，压缩错误码）；\n（11）称号获得表（link_u_hs）：（用户编号（外键），称号编号（外键））；\n（12）勋章获得表（link_u_ms）：（编号（主键），用户编号（外键），勋章编号（外键））；\n（13）点赞表（link_u_like_ms）：（动态编号（外键），用户编号（外键））；\n（14）评论表（comments）：（编号（主键），用户编号（外键），动态编号（外键），评论内容）；\n（15）活动参加表（link_u_as）：（用户编号（外键），活动编号（外键），完成）；\n（16）每日一言（hitokotos）：（一言编号（主键），类型，来源，作者）；\n\n数据模型图：\n\n四、开发前的准备\n4.1 技术调研\n前端：\n没商量，使用微信小程序开发（因为我要为我的其他项目去深入学习小程序开发），但是UI框架上从Vant、Wux和iView中最终选择了Vant为主（因为它比较规范）。\n\n但是可能最开始没有说清楚，那个小姐姐最开始使用的iView开发，为了减少任务量，使用的iView那块继续保持着，没有替换成Vant\n\n后端：\n后端我考虑了node+MongoDB、Java+MySQL、PHP+MySQL三种。\n我首先考虑的是node开发，先去考察了node的框架：express、koa、koa2、egg，最终选择了koa2学习。\n我首先看了一遍廖雪峰老师写的node文章，然后简单编写了一个请求的demo并成功部署到服务器，发现它的编写需要导入很多库，而且我不太清楚有哪些库，为了加一个token验证的库，我去koa的github上找了半天，也没有实现，所以放弃了。\n然后想了想Java，其实之前会的，但是我刚开始配置Java环境和配置Spring时就直接放弃了，配置太难搞了！！\n最后还是选择PHP吧，几乎不需要配置，然后框架使用的是大二一直没有学会的Laravel，我按照Laravel官网的方法，直接安装了composer，使用最新的Laravel版本，学习是看的视频，视频讲了个大概，更多的还是看的官网的文档（看不懂的时候才用的翻译）。\nAPI管理：\nAPI管理是我在拓尔思实习的时候了解到一个YApi平台，公司那时还没有正式全面使用，前端这边就提了一下，但是我却下来认真研究了一下，并自己部署了一个，已经投入到自己的项目管理，给学弟托管大创接口。\n产品原型：\n产品原型就相当于是开发前“打草稿”，我使用的是墨刀，主要是开发前期，对程序页面进行了大致绘制，防止在开发过程中太过随意发挥了。\n开发手册：\n开发手册其实就是打算用来记录一些前公用方法、公共组件等，我使用的是语雀，其实就是一个在线协作文档。（期间也就最开始记录了一下公共组件、js模块，后来就没怎么记录了，主要是没时间，其实那些公共的方法模块一时还能记住）\n4.2 规范制定\n前端：\n（1）凡是能多次使用的方法均需放在app.js里，或者整理成模块放在utils目录下；\n（2）每个方法必须要有注释；\n（3）凡是能重复的使用的页面模块，均需写成组件，保存在components目录下，组件目录命名xxx-xxx，组件文件命名为index；\n（4）git提交：完成某个功能点，或者修复某个问题需要commit一次；\n后端：\n（1）接口路由按模块分组，api/run/a， api/run/b；\n（2）git提交：完成一个接口提交一次，调整某些功能提交一次；\n（3）接口返回格式json：\n12345&#123;  &#x27;isSuccess&#x27;: true,  &#x27;msg&#x27;: &#x27;操作成功&#x27;,  &#x27;data&#x27;: &#123;&#125;&#125;\n（4）接口tag设置：\n\n未设置：还在开发中\n已部署：已同步至开发环境，前端可用\n已上线：同步至正式环境，测试和演示可用（前端也可用）\n暂不实现：因种种原因，暂不实现或后期实现\n\n4.3 工具和环境\n环境：\nPHP7.2，MySQL-8.0.19\n前端：\n\n\n微信开发者工具：用于运行和调试程序\n\n\nVS code：小程序编码\n\n安装EasyLess插件，编写less，导出后缀设置为.wxss\n安装wechat-snippet插件，微信小程序代码快捷插入\n\n\n\n后端：\n\n\nVS code：PHP编码\n\n安装laravel-goto-controller，快速跳转到控制器\n安装Laravel Snippets，语法提示\n安装Laravel Artisan，运行artisan命令\n\n\n\nNavicat Premium 15：数据库可视化管理，数据模型，激活\n\n\n绘图：\n\nVisio 2016：绘制E-R图，流程图\nXmind8：功能梳理\n\n论文：\n\nWord 2016\n\n五、项目代码介绍\n5.1 前端\n5.1.1 仓库地址\nhttps://github.com/Chef5/PopRun\n5.1.2 目录结构\n1234567891011121314151617181920212223242526├─.vscode           #VS Code配置，含&#x27;EasyLess&#x27;插件配置├─components        #自定义公共组件├─dist              #iVew-Weapp库├─imgs              #图标、默认图片├─pages│  ├─run            #跑步（首页）│  │  └─sharePage        #分享到动态圈子页│  ├─moments        #动态圈子│  │  ├─messages         #消息盒子│  │  └─newMoment        #新建动态│  ├─pub            #活动广场│  │  ├─blockDetail      #教程详细│  │  ├─blockMore        #教程列表│  │  ├─listDetail       #活动详细│  │  └─listMore         #活动列表│  └─user           #个人中心│      ├─edit            #个人资料编辑│      ├─modals          #勋章墙│      ├─myMoments       #我的动态│      ├─myRuns          #我的运动│      ├─privacy         #隐私设置│      ├─setting         #通用设置│      └─userPage        #个人主页├─theme             #主题定制├─utils             #公共模块└─voice             #音频文件\n5.1.3 部分核心代码\ntabbar红点数字提示：\n1234567891011121314151617181920/**   * 设置tabbar状态   * index: 第几个tab，0~3   * value: &#123; dot:boolean, number:number &#125;   */setTabbar: function(index, value)&#123;    if(!value.number)&#123;        wx.removeTabBarBadge(&#123; index &#125;)        if(value.dot)&#123;            wx.showTabBarRedDot(&#123; index &#125;)        &#125;else&#123;            wx.hideTabBarRedDot(&#123; index &#125;)        &#125;    &#125;else&#123;  //设置数字        wx.setTabBarBadge(&#123;            index,            text: value.number+&#x27;&#x27;,        &#125;)    &#125;&#125;\n动态单多图处理：\n1234567891011121314151617attached: function() &#123;    this.setData(&#123;        data: that.properties.moment,        user: user    &#125;);    this._initData(that.data.data.imgs.thumbnail,that)&#125;,methods: &#123;    _initData: (d,e)=&gt;&#123;        if(d.length == 1)&#123;            e.setData(&#123;                imageWidth: Math.floor(d[0].width*420/d[0].height),                imageHeight: 420            &#125;)        &#125;    &#125;&#125;\n1234567891011121314151617181920212223242526&lt;view class=&quot;content-img&quot;&gt;    &lt;!-- 多图 --&gt;    &lt;view           wx:if=&quot;&#123;&#123;data.imgs.thumbnail.length &gt; 1&#125;&#125;&quot;          class=&quot;image-wrap&quot;           wx:for=&quot;&#123;&#123;data.imgs.thumbnail&#125;&#125;&quot;          wx:for-item=&quot;item&quot;          wx:for-index=&quot;index&quot;          wx:key=&quot;item&quot;          style=&quot;width: calc(calc(100% / &#123;&#123;data.imgs.thumbnail.length &gt; 3 ? 3 : data.imgs.thumbnail.length&#125;&#125;) - 20rpx);&quot;&gt;        &lt;view               class=&quot;image&quot;              catchtap=&quot;showBigimg&quot;              data-url=&quot;&#123;&#123;data.imgs.original[index].url&#125;&#125;&quot;              style=&quot;background-image:url(&#123;&#123;item.url&#125;&#125;);&quot;&gt;        &lt;/view&gt;    &lt;/view&gt;    &lt;!-- 单图 --&gt;    &lt;view           wx:if=&quot;&#123;&#123;data.imgs.thumbnail.length == 1&#125;&#125;&quot;          class=&quot;image-wrap-single&quot;           catchtap=&quot;showBigimg&quot;          data-url=&quot;&#123;&#123;data.imgs.original[0].url&#125;&#125;&quot;          style=&quot;width:&#123;&#123;imageWidth&#125;&#125;rpx;height:&#123;&#123;imageHeight&#125;&#125;rpx;background-image:url(&#123;&#123;data.imgs.thumbnail[0].url&#125;&#125;);&quot;&gt;    &lt;/view&gt;&lt;/view&gt;\n分享图绘制：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546/**  * 绘制分享图 ：动态圈子&amp;右上角 500*400  朋友圈 500*600（加了200显示小程序码） * nodeID: canvas id * run: 运动数据   *      自定义背景：run.bg=Image或者run.color=&#123;from, to, direction:0-7左上角顺时针（）&#125; * iswx: 是否分享到朋友圈[可选]，默认false * user: 用户数据[可选](分享到朋友圈时需要)：小程序码 user.ercode=Image */draw(nodeID, run, iswx, user) &#123;    if(!run)&#123;        Dialog.alert(&#123;            message: &#x27;数据异常&#x27;        &#125;)        return;    &#125;    return new Promise((resolved, rejected)=&gt;&#123;        //画图        Share.getCanvasWX6B(nodeID, this).then(canvas=&gt;&#123;            //分享背景图            let bg = canvas.createImage();            bg.src = &#x27;../../imgs/default/sharebg.png&#x27;;            run.bg = bg;            if(iswx)&#123;                //小程序码                let ercode = canvas.createImage();                ercode.src = &#x27;../../imgs/ercode.jpg&#x27;;                user.ercode = ercode;            &#125;            Share.makeShareImg(canvas, run, iswx, user);            setTimeout(()=&gt;&#123;                if(iswx) &#123;                    Share.getFileWX6B(monID, this, iswx).then(imgurl=&gt;&#123;                        this.setData(&#123; monImg: imgurl &#125;);                    &#125;)                &#125;else &#123;                    Share.getFileWX6B(nonID, this, iswx).then(imgurl=&gt;&#123;                        this.setData(&#123; nonImg: imgurl &#125;);                    &#125;)                &#125;            &#125;,300) //延迟防止绘制未完成            resolved(canvas);        &#125;).catch(err=&gt;&#123;            rejected(err);        &#125;)    &#125;)&#125;\n5.2 后端\n5.2.1 仓库地址\nhttps://github.com/Chef5/PopRun-b\n5.2.2 目录结构\n123456789101112131415161718192021222324252627282930├─.vscode               #VS Code配置├─app                   #app目录│  ├─Console                #【核心】控制台：定时任务│  │  └─Commands                #命令：定时任务要执行的操作│  ├─Exceptions         #异常抛出类│  ├─Http               #Http控制│  │  ├─Controllers         #【核心】控制器│  │  │  └─Auth                 #控制器里进行分类：认证│  │  └─Middleware      #中间件：过滤请求和响应│  ├─Lib                #公共方法：主要写了一个返回参数格式化│  └─Providers\t\t\t├─config                #配置文件：主要改了数据库编码配置，支持emoji├─database              #数据库│  ├─factories│  ├─migrations             #【核心】数据库迭代生成│  └─seeds├─public                #公共资源│  ├─css│  ├─js│  ├─layui                  #layui引入│  └─resources              #资源│      ├─images                 #图片│      │  ├─2020-01-31              #图片按上传日期分目录管理│      ├─medals                 #勋章图片│      └─userImgs               #用户头像├─resources├─routes                #【核心】路由├─storage├─tests└─vendor                #Laravel依赖\n5.2.3 部分核心代码\n排行榜：\n123456789101112131415161718192021222324252627282930313233343536373839/**  * 获取排行榜：周榜，月榜合并接口 type:0周榜 1月榜 */public function getRanking(Request $request)&#123;    if($request-&gt;has(&#x27;team&#x27;))&#123;        //默认月榜        $timeStart = date(&quot;Y-m-01&quot;).&quot; 00:00:00&quot;;        $timeEnd = date(&#x27;Y-m-d&#x27;, strtotime(&quot;$timeStart +1 month -1 day&quot;)).&quot; 23:59:59&quot;;        if($request-&gt;has(&#x27;type&#x27;) &amp;&amp; $request-&gt;type == 0)&#123;  //0周榜            $timeStart = date(&#x27;Y-m-d&#x27;, strtotime(&quot;this week&quot;)).&quot; 00:00:00&quot;;            $timeEnd = date(&#x27;Y-m-d&#x27;, strtotime(&quot;+1 week -1 day&quot;, strtotime(&quot;this week&quot;))).&quot; 23:59:59&quot;;        &#125;        try &#123;            $top100 = RRuns::join(&#x27;r_users&#x27;, &#x27;r_users.rid&#x27;, &#x27;=&#x27;, &#x27;r_runs.rid&#x27;)                -&gt;where(&#x27;r_users.team&#x27;, $request-&gt;team)                -&gt;where(&#x27;r_runs.distance&#x27;, &#x27;&lt;&gt;&#x27;, null) //排除未完成运动                -&gt;whereBetween(&#x27;r_runs.created_at&#x27;, [$timeStart, $timeEnd])                -&gt;select(                DB::raw(                    &#x27;r_users.rid,                     r_users.nickname,                     r_users.img,                     r_users.team,                     cast(sum(r_runs.distance) as decimal(15,2)) as sumD,                    sum(r_runs.time_run) as sumT,                     cast(avg(r_runs.speed) as decimal(15,2)) as avgS&#x27;                ))                -&gt;groupBy(&#x27;r_runs.rid&#x27;)                -&gt;orderBy(&#x27;sumD&#x27;, &#x27;desc&#x27;)                -&gt;limit(100)                -&gt;get();            return returnData(true, &quot;操作成功&quot;, $top100-&gt;toArray());        &#125; catch (\\Throwable $th) &#123;            return returnData(false, $th);        &#125;    &#125;else&#123;        return returnData(false, &#x27;缺少team校区&#x27;);    &#125;&#125;\n单次里程成就和活动成就检测：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 单次里程成就：5km, 10km, 15km, 20km, 半马(21.0975=21.09), 全马(42.195=42.19), 50km, 100km * 活动成就：r_activitys.distance */private function checkMedals($rid, $distance)&#123;    // 单次里程成就    $distances = [5, 10, 15, 20, 21.09, 42.19, 50, 100];    $medalkeys = [&#x27;star_1_act&#x27;,&#x27;star_2_act&#x27;,&#x27;star_3_act&#x27;,&#x27;star_4_act&#x27;,&#x27;star_5_act&#x27;,&#x27;star_6_act&#x27;,&#x27;star_7_act&#x27;,&#x27;star_8_act&#x27;];    if($distance&gt;=5)&#123;        $index = 0;  //        for($i=0; $i&lt;count($distances); $i++)&#123;            if($distance&gt;=$distances[$i]) $index = $i;            else break;        &#125;        $medal = RMedals::where(&#x27;mkey&#x27;, $medalkeys[$index])-&gt;first();        $isAchieved = LinkUMs::where(&#x27;rid&#x27;, $rid)-&gt;where(&#x27;meid&#x27;, $medal-&gt;meid)-&gt;get();        if(count($isAchieved)==0)&#123;  //未获取过，可以进行授予            $me = new LinkUMs();            $me-&gt;fill([                &#x27;rid&#x27; =&gt; $rid,                &#x27;meid&#x27; =&gt; $medal-&gt;meid            ]);            $me-&gt;save();            System::systemNotice([                &#x27;to&#x27; =&gt; $rid,                 &#x27;msg&#x27; =&gt; &quot;你新获得一枚勋章&lt;&quot;.$medal-&gt;name.&quot;&gt;&quot;            ]);        &#125;    &#125;        // 活动成就    $timeNow = date(&#x27;Y-m-d H:i:s&#x27;);    $theLastestFinished = LinkUAs::join(&#x27;r_activitys&#x27;, &#x27;link_u_as.acid&#x27;, &#x27;=&#x27;, &#x27;r_activitys.acid&#x27;)        -&gt;select(&#x27;link_u_as.rid&#x27;, &#x27;link_u_as.acid&#x27;, &#x27;link_u_as.isfinished&#x27;, &#x27;r_activitys.title&#x27;, &#x27;r_activitys.distance&#x27;, &#x27;r_activitys.period&#x27;, &#x27;r_activitys.meid&#x27;)        -&gt;where(&#x27;r_activitys.period&#x27;, &#x27;&gt;&#x27;, $timeNow)  //有效期内的活动        -&gt;where(&#x27;link_u_as.rid&#x27;, $rid)  //已报名的活动        -&gt;where(&#x27;link_u_as.isfinished&#x27;, 0) //未完成的活动        -&gt;where(&#x27;r_activitys.distance&#x27;, &#x27;&lt;=&#x27;, $distance)  //达到挑战条件        -&gt;orderBy(&#x27;r_activitys.period&#x27;, &#x27;asc&#x27;)  //升序        -&gt;first();  //获取最近将要过期的    if($theLastestFinished)&#123;        $medal = RMedals::where(&#x27;meid&#x27;, $theLastestFinished-&gt;meid)-&gt;first();        try &#123;            DB::beginTransaction();            // 更新记录为已完成            LinkUAs::where(&#x27;rid&#x27;, $theLastestFinished-&gt;rid)                -&gt;where(&#x27;acid&#x27;, $theLastestFinished-&gt;acid)                -&gt;update([&#x27;isfinished&#x27;=&gt;1]);            // 勋章授予            $me = new LinkUMs();            $me-&gt;fill([                &#x27;rid&#x27; =&gt; $theLastestFinished-&gt;rid,                &#x27;meid&#x27; =&gt; $theLastestFinished-&gt;meid            ]);            $me-&gt;save();            DB::commit();            System::systemNotice([                &#x27;to&#x27; =&gt; $theLastestFinished-&gt;rid,                &#x27;msg&#x27; =&gt; &quot;恭喜您挑战完成活动《&quot;.$theLastestFinished-&gt;title.&quot;》，获得一枚勋章&lt;&quot;.$medal-&gt;name.&quot;&gt;&quot;            ]);        &#125; catch (\\Throwable $th) &#123;            DB::rollback();        &#125;    &#125;&#125;\n称号等级：\n123456789101112131415161718192021222324252627282930313233343536373839404142// 初始数据-等级称号protected $honors = [&#x27;赤脚&#x27;, &#x27;草鞋&#x27;, &#x27;棉鞋&#x27;, &#x27;布鞋&#x27;, &#x27;板鞋&#x27;, &#x27;高跟鞋&#x27;, &#x27;球鞋&#x27;, &#x27;运动鞋&#x27;, &#x27;跑鞋&#x27;];/** * Execute the console command. * @return mixed */public function handle()&#123;    //统计每个用户的运动次数    $userRuns = RUsers::join(&#x27;r_runs&#x27;, &#x27;r_users.rid&#x27;, &#x27;=&#x27;, &#x27;r_runs.rid&#x27;)        -&gt;where(&#x27;r_runs.distance&#x27;, &#x27;&lt;&gt;&#x27;, null) //排除未完成运动        -&gt;select(        DB::raw(            &#x27;r_users.rid, count(r_runs.ruid) as count&#x27;        )    )        -&gt;groupBy(&#x27;r_runs.rid&#x27;)        -&gt;get();    foreach($userRuns as $user)&#123;        $hoid = 1;        if($user-&gt;count &lt;= 1) $hoid = 1;        else if($user-&gt;count &lt; 10) $hoid = 2;        else if($user-&gt;count &lt; 50) $hoid = 3;        else if($user-&gt;count &lt; 100) $hoid = 4;        else if($user-&gt;count &lt; 200) $hoid = 5;        else if($user-&gt;count &lt; 400) $hoid = 6;        else if($user-&gt;count &lt; 800) $hoid = 7;        else if($user-&gt;count &lt; 1000) $hoid = 8;        else $hoid = 9;        //先查询是否已存在相同等级的称号        $linkHonors = LinkUHs::where(&#x27;rid&#x27;, $user-&gt;rid)-&gt;where(&#x27;hoid&#x27;, &#x27;=&#x27;, $hoid)-&gt;first();        if(!$linkHonors)&#123; //如果不存在，则可以进行称号进阶授予            LinkUHs::where(&#x27;rid&#x27;, $user-&gt;rid)                -&gt;update([&#x27;hoid&#x27; =&gt; $hoid ]);            System::systemNotice([                &#x27;to&#x27; =&gt; $user-&gt;rid,                &#x27;msg&#x27; =&gt; &quot;你已累计运动 $user-&gt;count 次，授予您新的的称号: lv&quot;.($hoid-1).&#x27; &#x27;.$this-&gt;honors[$hoid-1]            ]);        &#125;    &#125;&#125;\n六、结束\n总结：其实写到后面我不知道怎么写了，我的目的就是想给学弟学妹们做毕设时可以参考我的过程。\n就大概写这些吧，\n烂尾了，\n差评！🤪\n","plink":"https://blog.jschef.com/Learning/3029bde5b8fc/"},{"title":"JSHint的使用和配置","date":"2020-05-06T07:09:26.000Z","date_formatted":{"ll":"May 6, 2020","L":"05/06/2020","MM-DD":"05-06"},"updated":"2023-11-14T12:07:06.466Z","content":"一、前言\n为什么要代码质量检测？\n对于前端开发人员来说，使用最多的肯定就是JavaScript，起初JavaScript被开发出来的目的只是用于一些web的简单交互，但随着互联网的发展，网站内容变得丰富，交互变得更加复杂，再加上JavaScript本身设计上有很多缺陷，代码不够严谨就很可能导致一些莫名其妙的错误。有了代码检测工具，可以提示开发者检测代码中潜在的问题，帮助开发者开发出高稳健性的程序。\n目前有很多代码质量检测工具，比如JSHint、JSLint、ESLint等等，其中大部分是以lint结尾的。Lint最初是贝尔实验室开发的一款C语言静态代码分析工具，主要作用是检测C程序中的潜在错误，这也就是大部分代码质量检测工具的命名由来。Hint的中文意思是暗示，也许这就是JSHint的命名由来。\n二、 JSHint简介\nJSHint是JavaScript语法和风格的检查工具，是基于JSLint开发的，它可检测到错误和潜在风险告知给开发者。\n2.1 JSLint、JSHint、ESLint区别\n发展历程：\n\nJSLint是第一款JavaScript代码检测工具，但是它最大的问题是几乎不可配置，几乎所有的代码风格和规则都是内置的，很多会导致程序无法继续运行下去；\nJSHint是基于JSLint开发的，它最大的特点就是可配置，对开发者比较友好，团队编码风格可以很好的体现出来；\nESLint的特点在于可扩展，它不仅可扩展规则，还能扩展解析器，其扩展特点让ESLint在ES5发布后得到蓬勃发展；\n\n优缺点：\n\n\n-\n-\n-\n\n\n\n\nJSLint\n优点：\n开箱即用，规则已经内置好了\n\n\n\n缺点：\n有限配置选项，很多规则不能禁用\n\n\n\n\n规范严格，凡是不符合JSLint认为的风格，皆会警告\n\n\n\n\n扩展性能差\n\n\n\n\n无法根据错误定位到对应规则\n\n\nJSHint\n优点：\n有较多参数可配置\n\n\n\n\n支持配置文件，易于在大型项目中使用\n\n\n\n\n支持一些常用框架和库\n\n\n\n\n支持基本的ES6\n\n\n\n缺点：\n不支持自定义规则\n\n\n\n\n无法根据错误定位到对应规则\n\n\nESLint\n优点：\n默认规则包含了JSLint和JSHint的规则，易于从JSLint和JSHint迁移过来\n\n\n\n\n支持插件扩展\n\n\n\n\n可以自定义规则\n\n\n\n\n可以根据错误定位到对应的规则\n\n\n\n\n支持ES6\n\n\n\n\n唯一一个支持JSX的工具\n\n\n\n缺点：\n运行慢\n\n\n\n\n需要进行一些自定义配置\n\n\n\n参考自：https://www.sitepoint.com/comparison-javascript-linting-tools/\n\n三、安装及其使用方式\n3.1 工程上使用（推荐）\n步骤：\n（1）安装开发依赖：（如果package.json中已存在，npm install即可）\n1npm install jshint --save-dev\n（2）项目根目录新建文件，命名为 .jshintrc（如果项目中已存在该文件，此步骤略过）\n以下是我给公司angularJS项目制定的规则：\n1234567891011121314151617181920&#123;    &quot;globals&quot;: &#123;  //全局变量声明：部分框架自带特殊关键词，jshint无法识别可能会报未定义等错误        &quot;$&quot;: true,         &quot;angular&quot;: true,        &quot;UE&quot;: true,        &quot;LazyLoad&quot;: true    &#125;,    &quot;asi&quot;: true,           //取消：无分号警告    &quot;bitwise&quot;: true,       //禁止使用位运算符&amp;，通常是&amp;&amp;错写成&amp;    &quot;browser&quot;: true,       //暴露浏览器属性全局定义，如window,document    &quot;curly&quot;: true,         //循环或者条件语句必须使用花括号括起来    &quot;esversion&quot;: 5,        //代码必须撰写的ESCMScript版本    &quot;freeze&quot;: true,        //禁止重写对象原型    &quot;moz&quot;: true,           //告知JSHint代码是兼容Mozilla的，而非专门为其设计    &quot;nonbsp&quot;: true,        //不换行的空格警告    &quot;strict&quot;: true,        //必须使用use strict    &quot;undef&quot;: true,         //变量未定义警告    &quot;unused&quot;: true,        //变量定义未使用警告    &quot;jquery&quot;: true         //暴露jQuery库&#125;\n注意：\n\n\nJSHint默认配置项有这些：https://github.com/jshint/jshint/blob/master/examples/.jshintrc\n\n\njshint模块会自动读取.jshintrc文件，如果没有生效，可以通过命令：jshint -c /path/to/.jshintrc设置\n\n\n通常情况下，作用于当前目录文件及其所有子目录文件，不会作用于父级目录\n\n\n需要参考项目上使用的框架进行配置，部分框架有jshint相关配置说明，如angular.js\n\n\n\n（3）使用方法：\n12jshint xxx/a/       #检测xxx目录下的a目录下所有js文件（注意检测目录必须以 / 结尾，否则会被当做文件处理）jshint xxx/a.js     #检测xxx目录下的a.js\n（4）给本地编辑器安装jshint相应插件（开发人员可选）\n完成前几步后，就可以使用jshint工具对项目代码进行检测了，为了更加方便，建议开发人员在本地编辑器安装jshint相应插件（编辑器自带就不用了），插件会帮助我们自动检测打开的文件，并在Problems生成报告\n\nVS Code插件：jshint\nSublime插件：\nWebStorm：\n\n3.2 本地自测\n步骤：\n（1）安装：\n1npm install -g jshint\n（2）使用：\n12jshint xxx/a/       #检测xxx目录下的a目录下所有js文件（注意检测目录必须以 / 结尾，否则会被当做文件处理）jshint xxx/a.js     #检测xxx目录下的a.js\n（3）配置：\n完成前面两步后，可以使用jshint的默认配置对项目进行检测了，如果需要自定义一些检测规则，可以在项目根目录下新建一个配置文件 .jshintrc，在里面写入自定义规则，自定义规则详细参见 3.1 (2)的推荐配置 和 第四章详细配置列表\n通常jshint模块会自动寻找项目中的.jshintrc文件，若是没有自定义规则文件未生效，可通过以下命令将自定义规则添加到jshint里\n注意：如果项目上不需要.jshintrc，且仅是本地自测，请一定要将该文件添加至.gitignore里，避免污染项目\n1jshint -c .jshintrc\n3.3 编辑器方式（适用于本地）\n这里以VS code为例说明\n（1）安装：\n\n\n插件市场搜索jshint并安装\n\n\n安装jshint模块：\n\n\n1npm install -g jshint\n（2）使用：\n安装完成后自动启用，会检测当前所有窗口打开的所有文件，在Problems里输出提示\n（3）配置：\n正常安装完成后检测规则为 jshint默认项\n以下是jshint在vs code编辑器中配置：setting.json\n\n提示：插件安装后，在setting.json里输入 js 会有自动提示键入\n\n123456789101112131415161718192021222324&#123;\t/**\t* 以上是其他配置，以下为jshint配置\t*/    &quot;jshint.enable&quot;: true,  //是否启用jshint插件\t&quot;jshint.config&quot;: null,  //包含jshint配置选项的文件路径，如果存在就会覆盖jshint.options和所有.jshintrc文件    &quot;jshint.options&quot;: &#123;     //jshint配置项\t\t&quot;globals&quot;: &#123;\t\t\t&quot;$&quot;: true,\t\t\t&quot;angular&quot;: true\t\t&#125;,\t\t&quot;asi&quot;: true,\t\t&quot;strict&quot;: true,\t\t&quot;jquery&quot;: true\t\t//此处省略一大堆\t&#125;,   \t&quot;jshint.exclude&quot;: &#123;&#125;,            //忽略匹配的文件和目录    &quot;jshint.excludePath&quot;: null,      //指定exclude文件路径，如果存在将覆盖jshint.exclude和所有.jshintignore文件\t&quot;jshint.html&quot;: false,            //是否检测嵌入html中的JavaScript脚本    &quot;jshint.nodePath&quot;: &quot;&quot;,           //插件默认会在当前目录或者全局包中查找jshint模块，如果在其他位置，这里需要指定    &quot;jshint.packageManager&quot;: &quot;npm&quot;,  //指定当前使用的包管理工具    &quot;jshint.reportWarningsAsErrors&quot;: false,   //将警告类型Warning报告显示为Error错误形式 【该设置不会影响程序正常运行，grunt任务正常】    &quot;jshint.trace.server&quot;: &quot;off&quot;     //检测VS code 和jshint linter服务之间的通信 【未了解】&#125;\n配置注意：如果项目里存在.hshintrc文件，该插件会自动读取，并且默认是.jshintrc文件优先，setting.json里设置的options在存在.jshintrc文件时无效。这里建议，本地检测所有配置都写在编辑器配置里，不要写.jshintrc配置文件\n（4）插件常见报错处理\n\n\nRequest initialize failed with message: missing ) after argument list\n参见：https://github.com/Microsoft/vscode-jshint/issues/63\n解决办法：\n\n\n先确认是否安装了jshint依赖模块，插件必须配合jshint模块才能正常使用，安装完成后，插件会自动查询jshint模块位置并配置；\n\n\n如果还有问题，请确认jshint模块的安装位置，并在setting.json中配置jshint.nodePath，手动指定jshint模块位置。\n\n\n\n\n3.4 打包工具检测（跟随项目）\n3.4.1 Grunt\n安装：\n1npm install grunt-contrib-jshint --save-dev\nGruntfile.js配置：\n123456789101112131415161718192021222324252627282930313233grunt.loadNpmTasks(&#x27;grunt-contrib-jshint&#x27;);    //加载jshintgrunt.initConfig(&#123;\t\t//...前面省去一大段其他任务代码        //初始化，定义任务        jshint: &#123;            options: &#123;            //配置项                globals: &#123;&#125;            &#125;,\t\t\tjshintrc: false,      //设置为true后，会自动在项目里搜索.jshintrc文件，并.jshintrc文件优先\t\t\ttaskA: &#123;              //需要检测的子任务，例如taskA任务，检测xxx/a/目录                src: [&#x27;xxx/a/&#x27;]            &#125;,\t\t\t//示例任务            editingCenter: &#123;                src: [&#x27;app/editingCenter/editingCenterRouter.js&#x27;]            &#125;,            websiteAll: &#123;                src: [&#x27;app/editingCenter/website/all/&#x27;]            &#125;        &#125;,\t\t//...后面省去一大段其他任务代码&#125;)//加入默认任务//注意：整体执行时，jshint任务最好排在最前面，避免不必要的等待，因为该任务失败会直接终止整个grunt任务grunt.registerTask(&#x27;default&#x27;, [ \t\t&#x27;jshint&#x27;, &#x27;copy&#x27;, &#x27;bower&#x27;, &#x27;lessTask&#x27;, &#x27;concat:js&#x27;, &#x27;ngAnnotate&#x27;, &#x27;concat:libjs&#x27;, &#x27;concat:libcss&#x27;, &#x27;replace&#x27;, &#x27;uglify&#x27;, &#x27;cssmin&#x27; /* &#x27;watch&#x27;*/]);//自定义任务组合    grunt.registerTask(&#x27;jshintTask&#x27;, [        &#x27;jshint:editingCenter&#x27;,  //示例：执行editingCenter子任务        &#x27;jshint:websiteAll&#x27;,     //示例：执行websiteAll子任务]);\n执行：\n123grunt jshint                #执行jshint的所有任务grunt jshintTask            #执行jshintTask中包含的任务grunt jshint:editingCenter  #示例：单独执行jshint中的一个子任务\n​\t示例执行结果：\n​\t\n​\t\n备注：该方式如果检测出有潜在问题会直接终止grunt\n3.4.2 Gulp【待补充】\n待补充\n3.4.3 Webpack【待补充】\n待补充\n四、配置选项详细列表\n本节有些说明项中写的代码示例，因为在markdown表格里无法友好的显示，可以下载查看文末的我的doc原稿\n内容参考自 JSHint Options ，可能部分转述不准确，欢迎纠正。\n以下严格类、宽松类、环境变量仅为将规则分组区分，在写入规则时均为同级，无差别\n其中部分即将被废弃的选项转移到了 JSCS 项目，该项目可以实现代码检测和自动规范成设定的风格。\n选项中 **加粗项 **表示常用项\n参数中 **加粗 **表示默认值  全部默认值：https://github.com/jshint/jshint/blob/master/examples/.jshintrc\n没有默认值的最好自行补充，官方文档不太同步，具体设置未知\n4.1 严格类（加限制）\n说明：以下选项通常设置true时表示启用，当false表示禁用，严格选项通俗讲就是添加更多更严苛的规则，给检测增加难度的，设置后会出现较多的警告\n\n\n选项\n参数\n说明\n\n\n\n\nbitwise\ntrue/false\n禁用位运算符（&amp;），在JS里不常使用&amp;，这里是防止把&amp;&amp;写成&amp;\n\n\ncamelcase\ntrue/false\n该选项即将被JSHint废除：强制变量名称为驼峰写法或者大写字母下划线写法（UPPER_CASE）\n\n\ncurly\ntrue/false\n循环或条件语句必须使用花括号括起来。循环或者条件语句省略花括号时是执行之后的一句，某些情况下可能会被误认为而导致问题\n\n\neqeqeq\ntrue/false\n禁止使用 == 和 !=，强制使用 === 和 !==\n\n\nesversion\n3/4/5/6/7/8/9/10\n代码必须遵循指定的ESCMScript版本  技巧：如果设置3，可以检测项目代码在IE 6/7/8/9等老浏览器版本环境上执行情况\n\n\nforin\ntrue/false\n要求for in循环必须过滤对象item属性，因为遍历一个对象所有属性名称会包含通过原型链继承过来的属性，通常如以下这么做  for (key in obj) { if (obj.hasOwnProperty(key)) &#123;  // 这样我们就能确定obj中key这个属性时属于obj的，而不是继承而来的 &#125;}`\n\n\nfreeze\ntrue/false\n禁止重写原生对象的原型，比如重写了Array、Date等可能会在未来导致一些不可预料的问题  // jshint freeze:trueArray.prototype.count = function (value) &#123; return 4; &#125;;// -&gt; Warning: Extending prototype of native object: ‘Array’.`\n\n\nfuturehostile\ntrue/fasle\n当使用了在未来JavaScript版本中定义的标识符号，会警告。虽然在当前版本中不会对程序造成影响，但是之后升级版本可能会产生问题\n\n\nglobals\n{}\n声明全局变量。这里主要是声明一些特有的全局变量，如angular这个词jshint是不会识别的，需要如下设置才不会警告andular is  undefined  “globals”: {  “angular”: true }  https://jshint.com/docs/#inline-configuration\n\n\nimmed\ntrue/false\n该选项即将被JSHint废除：需要直接调用的函数必须用括号包围 function(){}()\n\n\nindent\n数字\n该选项即将被JSHint废除：设置代码缩进长度\n\n\nlatedef\nture/false/“nofunc”\n禁止在定义之前使用变量。如果设置为&quot;nofunc&quot;，则表示在true时，可以允许函数可以在定义之前使用\n\n\nleanswitch\ntrue/false\n禁止在switch语句中使用不必要的判断\n\n\nmaxcomplexity\ntrue/false\n设置代码文件独立直线路径最大复杂度检测\n\n\nmaxdepth\n数字\n设置代码最大嵌套深度\n\n\nmaxerr\n数字\n设置JSHint最大警告数，默认50\n\n\nmaxlen\n数字\n该选项即将被JSHint废除：设置最大行数\n\n\nmaxparams\n数字\n允许函数形参的最大数量\n\n\nmaxstatements\n数字\n允许每个函数内最大的声明数，声明包括变量和函数声明\n\n\nnewcap\ntrue/false\n该选项即将被JSHint废除：要求所有的构造器使用 new F() 形式\n\n\nnoarg\ntrue/false\n禁止使用arguments.caller和arguments.callee，因为这两个方法将被弃用，在ES5严格模式下已经禁止了callee\n\n\nnocomma\ntrue/false\n禁止使用逗号操作符，因为如果使用不当，可能会模糊语句值而引起错误\n\n\nnoempty\ntrue/false\n该选项即将被JSHint废除：空代码块警告\n\n\nnonbsp\ntrue/false\n不换行的空格警告。在mac电脑上开发容易产生一些不间断空格字符而破坏非utf-8的网页\n\n\nnonew\ntrue/false\n禁止使用new构造器函数。有些人喜欢调用构造函数，但并没有赋值给任何边变量  new MyConstructor();``这是没有任何好处的去声明一个构造器函数而不使用`\n\n\nnoreturnawait\ntrue/false\n禁止异步函数在try/catch块外返回await表达式。https://jakearchibald.com/2017/await-vs-return-vs-return-await/  async function foo() {   try {   return await waitAndMaybeReject();   }   catch (e) {   return ‘caught’;   }   }\n\n\npredef\ntrue/false\n允许扩展隐式全局变量\n\n\nquotmark\ntrue/false/“single”/“double”\n该选项即将被JSHint废除：     ture：禁止单双引号混用（可用任何一种）   false：什么都不处理   “single”：只允许用单引号   “double”：只允许用双引号\n\n\nregexpu\ntrue/false\n对于不包含“u”标识的正则表达式进行警告，因为u标识扩展了对Unicode的支持，还启用了更加严格的解析规则。\n\n\nshadow\ntrue/false/“inner”/“outer”\n检查变量重复定义     true：允许变量覆盖   false/“inner”：只检查是否在相同的作用域重复定义   “outer”：检查外部作用域\n\n\nsingleGroups\ntrue/false\n禁止使用非必要的分组操作符  // jshint singleGroups: true``delete(obj.attr); // Warning: Unnecessary grouping operator. 使用 delete obj.attr即可，分组操作是不必要的`\n\n\nstrict\ntrue/false/“global”/“implied”\n要求代码以ES5严格模式运行     true：必须使用“use strict”，检测到函数级别   false：关闭严格模式下的警告   “global”：在全局层面必须有一个“use strict”   “implied”：在文件里面使用“use strict”\n\n\ntrailingcomma\ntrue/false\n在数组或者对象最后一项后没有逗号时警告。在ES5起，鼓励使用逗号结尾\n\n\nundef\ntrue/false\n变量未定义\n\n\nunused\ntrue/false\n变量定义了未使用\n\n\nvarstmt\ntrue/false\n禁止使用var声明变量，需使用let或者const代替\n\n\n4.2 宽松类（取消限制）\n说明：宽松选项设置（true）后会放松检测，取消某些检测，会减少警告量\n\n\n选项\n参数\n说明\n\n\n\n\nasi\ntrue/false\n禁止缺少分号警告\n\n\nboss\ntrue/false\n禁止比较表达式没有达到预期的警告  通常情况下 if (a=10){} 这样使用时错误的，但也有部分情况需要这样使用，如  for ( var i=0,person; person=people[i]; i++ )  取消这样的警告，可以这样处理：  for ( var i=0,person; (person=people[i]); i++ )\n\n\ndebug\ntrue/false\ntrue忽略debugger代码\n\n\nelision\ntrue/false\n告知JSHint代码使用ES3数组省略元素或者空元素（[1,4,8]）\n\n\neqnull\ntrue/false\n取消 ==null 比较  警告，通常这样的比较可以检查变量是否null或者undefined\n\n\nevil\ntrue/false\n取消 使用了eval的 警告。eval容易使代码受到各种注入攻击，并且是JS解析器很难进行某些优化\n\n\nexpr\ntrue/false\n取消 使用表达式 警告。一般函数调用，而非表达式，但是现在规范并没有明确禁止这样用。\n\n\nfuncscope\ntrue/false\n取消 结构内声明的变量在结构外使用的 警告。虽然var声明有变量提升，但是这样使用的不利于开发者调试程序的。  function test() { if (true) &#123;  var x = 0; &#125; x += 1; // Default: ‘x’ used out of scope.     // 当funcscope:true时，JSHint不会发出警告}`\n\n\niterator\ntrue/false\n取消 使用__iterator__属性的 警告。并不是所有浏览器都支持此属性，需要谨慎使用。\n\n\nlastsemic\ntrue/false\n取消 一行代码最后声明后面的分号遗漏 警告。\n\n\nlaxbreak\ntrue/false\n该选项即将被JSHint废除：取消 不安全的折行 警告。\n\n\nlaxcomma\ntrue/false\n该选项即将被JSHint废除：取消 检测逗号在代码行最前面的编程风格  var obj = {  name: 'Anton' , handle: ‘valueof’ , role: 'SW Engineer'};`\n\n\nloopfunc\ntrue/false\n取消 内部循环 警告。  var nums = [];for (var i = 0; i &lt; 10; i++) &#123; nums[i] = function (j) {  return i + j; };&#125;nums0; // 会输出12而非2这类问题使用立即函数进行定义就可以规避var nums = [];for (var i = 0; i &lt; 10; i++) &#123; (function (i) {  nums[i] = function (j) &#123;    return i + j;  &#125;; }(i));``}`\n\n\nmoz\ntrue/false\n告知JSHint代码是兼容Mozilla。如果专门为Firefox web浏览器开发则不需要此项\n\n\nmultistr\ntrue/false\n该选项即将被JSHint废除：取消 多行字符串 警告。多行字符串在JS里是错误的，如果加\\说明时，在后面多了空格也是会导致整个字符串错误的  // jshint multistr:true var text = &quot;Hello`World&quot;; // 这样没有问题`` ``text = &quot;Hello``World&quot;; // Warning, no escape character.`` ``text = &quot;Hello\\ ``World&quot;; // Warning, there is a space after \\\n\n\nnotypeof\ntrue/false\n取消 typeof比较不合理的typeof值 警告。  // typeof合理值应该是 ‘function’， if (typeof a == “fuction”) { // Invalid typeof value ‘fuction’ // ...}\n\n\nnoyield\ntrue/false\n取消 函数生成器没有yield声明 警告。\n\n\npulsplus\ntrue/false\n禁止使用 一元递增或递减运算符。有些人认为这个会降低编码样式的质量\n\n\nproto\ntrue/false\n取消 关于__proto__属性的 警告。\n\n\nscripturl\ntrue/false\n取消 使用了脚本定向的url 警告。如 javascirpt: …\n\n\nsub\ntrue/false\n该选项即将被JSHint废除：取消  检测属性使用 [] 的警告，可以用 . 替代。如 person[‘name’] = pserson.name\n\n\nsupernew\ntrue/false\n取消 检测怪异结构的 警告。如 new function(){ … }和new Object\n\n\nvalidthis\ntrue/false\n取消 在非构造函数中使用this的 警告。\n\n\nwithstmt\ntrue/false\n取消 检查with使用的声明。with声明语句可以引起全局变量定义之间的混乱。\n\n\n4.3 环境变量选项\n说明：这些选项可以告知JSHint一些预先定义好的全局变量\n\n\n选项\n参数\n说明\n\n\n\n\nbrowser\ntrue/false\n暴露浏览器属性的全局定义，如window,document\n\n\nbrowserify\ntrue/false\n全局定义，可用Browserify工具建立一个项目\n\n\ncouch\ntrue/false\n全局暴露CouchDb。CouchDB是一个面向文档的数据库，可以查询和索引MapReduce的方式使用JavaScript\n\n\ndevel\ntrue/false\n定义常用于日志调试的console,alert等变量\n\n\ndojo\ntrue/false\n全局暴露的Dojo  Toolkit\n\n\njasmine\ntrue/false\n全局暴露jasmine的单元测试框架\n\n\njquery\ntrue/false\n全局暴露的jQuery库\n\n\nmocha\ntrue/false\n全局暴露的“BDD”和“TDD”的ui mocha单元测试框架\n\n\nmodule\ntrue/false\n告诉JSHint,输入代码描述了一个ECMAScript 6模块。所有模块的代码解释为严格模式代码\n\n\nmootools\ntrue/false\n全局暴露的MooToolsJavaScript框架\n\n\nnode\ntrue/false\n告知你的代码运行在node环境\n\n\nnonstandard\ntrue/false\n告知非标准但广泛采用全局定义等 escape和 unescape\n\n\nphantom\ntrue/false\n告知你的代码运行在PhantomJS环境\n\n\nprototypejs\ntrue/false\n全局暴露的prototypejs框架\n\n\nqunit\ntrue/false\n全局暴露QUnit单元测试框架\n\n\nrhino\ntrue/false\n告知你的代码运行在rhino环境\n\n\nshelljs\ntrue/false\n全局暴露ShellJS库\n\n\ntyped\ntrue/false\n全局定义数组类型构造函数\n\n\nworker\ntrue/false\n全局可以当你的代码运行在web worker。web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能  注：除IE外，所有主流浏览器均支持web worker\n\n\nwsh\ntrue/false\n告知你的代码运行在Windows  Script Host环境\n\n\nyui\ntrue/false\n全局暴露的yui框架\n\n\n五、常见问题及处理方法\n我整理了一些常见的E和W的错误和警告编号，示例、以及处理建议，但是图片太多了，我就不搬进这篇文章了，可以直接下载doc原稿查看。\n链接：https://pan.baidu.com/s/1k9wKJEUKrJe_R9aNQUfcSQ\n提取码：vq3k\n","plink":"https://blog.jschef.com/Learning/7737c2250f76/"},{"title":"TypeScript学习-数据类型","date":"2020-04-29T00:47:24.000Z","date_formatted":{"ll":"Apr 29, 2020","L":"04/29/2020","MM-DD":"04-29"},"updated":"2023-11-14T12:07:06.466Z","content":"1、\n","plink":"https://blog.jschef.com/Learning/d4c7cbf3ff66/"},{"title":"YApi平台以及pm2管理","date":"2020-04-10T23:05:02.000Z","date_formatted":{"ll":"Apr 11, 2020","L":"04/11/2020","MM-DD":"04-11"},"updated":"2023-11-14T12:07:06.466Z","content":"这是我做毕业设计时，特意单独用的一台服务器使用YApi平台管理接口。原来一直担心误删库，我的接口文档就全没了嘛，何况服务器上还托管了其他项目的接口。\n发现服务器突然宕机了！！！平台访问不了。吓死人了，我赶紧登上服务器，将YApi重启了，万幸数据都在！\n \n一、YApi安装和使用\n暂时不写使用教程\n以下复制粘贴的官网安装教程\n环境要求\n\nnodejs（7.6+)\nmongodb（2.6+）\ngit\n\n安装\n使用我们提供的 yapi-cli 工具，部署 YApi 平台是非常容易的。执行 yapi server 启动可视化部署程序，输入相应的配置和点击开始部署，就能完成整个网站的部署。部署完成之后，可按照提示信息，执行 node/{网站路径/server/app.js} 启动服务器。在浏览器打开指定url, 点击登录输入您刚才设置的管理员邮箱，默认密码为 ymfe.org 登录系统（默认密码可在个人中心修改）。\n12npm install -g yapi-cli --registry https://registry.npm.taobao.orgyapi server \n服务管理\n利用pm2方便服务管理维护。\n123456npm install pm2 -g  //安装pm2cd  &#123;项目目录&#125;pm2 start &quot;vendors/server/app.js&quot; --name yapi //pm2管理yapi服务pm2 info yapi //查看服务信息pm2 stop yapi //停止服务pm2 restart yapi //重启服务\n升级\n升级项目版本是非常容易的，并且不会影响已有的项目数据，只会同步 vendors 目录下的源码文件。\n1234cd  &#123;项目目录&#125;yapi ls //查看版本号列表yapi update //更新到最新版本yapi update -v &#123;Version&#125; //更新到指定版本\n二、MongoDB数据库备份\n暂时未详细研究\n备份：mongodump\n1mongodump -h &lt;hostname&gt;&lt;:port&gt; -d dbname -o &lt;path&gt;\n\n-h：MongDB所在服务器地址，如：127.0.0.1:27017\n-d：需要备份的数据库实例，如：test\n-o：输出目录，例如：/home/mongodb.bat/(该目录需要提前建立)，在备份完成/home/mongodb.bat/test/\n\n恢复：mongorestore\n1mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;\n\n\n-h：MongoDB所在服务器地址，默认为： localhost:27017\n\n\n-d：恢复数据库实例名称\n\n\n–drop：恢复的时候，先删除当前数据，然后恢复备份的数据\n\n\n：最后的一个参数，设置备份数据所在位置，例如：/home/mongodb.bat/test/\n\n–dir：指定备份的目录。你不能同时指定  和 --dir 选项。\n\n\n\n三、PM2对Node进程管理\n\n参考自：https://pm2.keymetrics.io/docs/usage/quick-start/\n\n安装：\n1npm install pm2@latest -g\n添加node应用：\n1pm2 start app.js --name &lt;app_name&gt; --watch\n\n例：pm2 start “vendors/server/app.js” --name yapi\n\n\n–name：给应用命名，可以不管\n–watch：相当于热更新，应用文件更新后会重启应用\n\n其他命令：\n123456pm2 [list|ls|status]  #查看所有应用pm2 info app_name         #查看服务信息pm2 restart app_name  #重启pm2 reload app_name   #重载pm2 stop app_name     #停止pm2 delete app_name   #从pm2移除\n\napp_name：可以用id代替，其中all表示所有进程\n\n","plink":"https://blog.jschef.com/Learning/f360ef90efef/"},{"title":"Laravel常用命令","date":"2020-04-07T06:28:19.000Z","date_formatted":{"ll":"Apr 7, 2020","L":"04/07/2020","MM-DD":"04-07"},"updated":"2023-11-14T12:07:06.466Z","content":"常用命令\n这些都是我在做毕业设计中，常用的命令，久了不用就忘，恼火\n我是一个小小的前端，这些个东西就不想记了，写下来，忘了就来复制粘贴\n\n安装依赖：composer install\n生成密钥：php artisan key:generate\n启动本地服务：php artisan serve\n创建\n\n创建数据表：php artisan make:migration r_users --create=r_users\n创建模型：php artisan make:model RUsers  -m 带数据表，-c 带控制器， -r 带路由\n创建控制器：php artisan make:controller RUsersController  --resource 带有Rest风格方法\n创建中间件：php artisan make:middleware filterTime\n\n\n生成数据表：php artisan migrate\n清空数据表：php artisan migrate:refresh  :reset 删除所有数据表\n部署启动：php artisan up\n\n备注：\nlaravel中的数据表都使用复数形式（users）\n默认CRUD检索id字段为id，因此尽量不自定义id字段\n\n更多 https://www.cnblogs.com/myzan/p/12000857.html\n\n数据表范例\n12345678910111213public function up()&#123;    Schema::create(&#x27;r_xxs&#x27;, function (Blueprint $table) &#123;        $table-&gt;increments(&#x27;id&#x27;);        $table-&gt;integer(&#x27;calorie&#x27;, false, false)-&gt;nullable()-&gt;comment(&#x27;卡路里&#x27;);        $table-&gt;bigInteger(&#x27;rid&#x27;)-&gt;foreign(&#x27;rid&#x27;)-&gt;references(&#x27;rid&#x27;)-&gt;on(&#x27;r_users&#x27;);        $table-&gt;tinyInteger(&#x27;sex&#x27;)-&gt;nullable()-&gt;comment(&#x27;性别:0位置1男2女&#x27;);        $table-&gt;string(&#x27;openid&#x27;, 50)-&gt;unique()-&gt;comment(&#x27;openid&#x27;);        $table-&gt;timestamp(&#x27;time_start&#x27;)-&gt;nullable()-&gt;comment(&#x27;开始时间&#x27;);         $table-&gt;timestamps(); //自动添加created_at和updated_at字段        // $table-&gt;primary([&#x27;rid&#x27;]);    &#125;);&#125;\n中间件范例\n1234567public function handle($request, Closure $next)&#123;       // 过滤掉时间    $request-&gt;offsetUnset(&#x27;created_at&#x27;);    $request-&gt;offsetUnset(&#x27;updated_at&#x27;);    return $next($request);&#125;\n1234567891011121314//Kernel.php中注册protected $routeMiddleware = [    &#x27;auth&#x27; =&gt; \\App\\Http\\Middleware\\Authenticate::class,    &#x27;auth.basic&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,    &#x27;bindings&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,    &#x27;cache.headers&#x27; =&gt; \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class,    &#x27;can&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class,    &#x27;guest&#x27; =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,    &#x27;signed&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,    &#x27;throttle&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,    &#x27;verified&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class,    // 自定义中间件    &#x27;filterTime&#x27; =&gt; \\App\\Http\\Middleware\\filterTime::class];\n1234//路由中使用Route::prefix(&#x27;user&#x27;)-&gt;group(function () &#123;\tRoute::post(&#x27;/doUpdate&#x27;, &#x27;RUsersController@doUpdate&#x27;)-&gt;middleware(&#x27;filterTime&#x27;);&#125;);\n","plink":"https://blog.jschef.com/Learning/05e70c5ba457/"},{"title":"Laravel后端问题整理","date":"2020-02-05T11:13:51.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2023-11-14T12:07:06.466Z","content":"PHP常用命令\n12345678910php test.php          #运行文件php -r &quot;phpinfo();&quot;   #运行语句php -m                #内置和Zend加载模块php -i                #phpinfo()php -i | grep php.ini #查看php配置文件加载路径php -i | grep -i extension_dir  #查看扩展加载路径php –ini              #查看php配置文件加载路径 php -v                #查看php版本 php –versionphp –re xx            #查看是否安装相应的扩展：php –re gdphp –help             #更多命令\nComposer源替换\n1234composer config -gl  #查看composer全局设置# 替换源，以下几个任选一个composer config -g repo.packagist composer https://packagist.phpcomposer.comcomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer\nLaravel自动维护时间字段\n123456789101112131415161718192021222324//MigrationSchema::create(&#x27;users&#x27;, function (Blueprint $table) &#123;    //...省略\t$table-&gt;timestamps();  //使关系表含有create_at和update_at字段&#125;)//Modelclass Users extends Model&#123;    // 可添加字段（白名单）    protected $fillable = [&#x27;name&#x27;, &#x27;sex&#x27;];    // 或者禁止某些字段（黑名单）    protected $guarded = [&#x27;uid&#x27;];&#125;//Controllerclass PublicController extends Controller&#123;    Users::insert();//这样是不会自动维护时间字段的    //以下可实现自动维护字段    $user = new Users(); //实例化user模型    $user-&gt;fillable([&#x27;name&#x27;, &#x27;sex&#x27;]); //给模型指定可填充的字段。（也可以在模型中实现，见Model）    $user-&gt;fill([&#x27;name&#x27;=&gt; &#x27;Tom&#x27;, &#x27;sex&#x27;=&gt;1]); //给实例填充数据，数据字段必须包含在fillable里    $user-&gt;save(); //保存到数据库    $user-&gt;id; //获取自增字段的id&#125;\nLaravel自定义全局公用函数\n\n首先在app下新建一个文件夹Lib，用于放公共函数的php文件，如我建的\n\n12345678910111213&lt;?php//当前路径：app\\Lib\\functions.php    /*** 格式化api返回*/function returnData($isSuccess, $msg, $data)&#123;    return [        &#x27;isSuccess&#x27; =&gt; $isSuccess,        &#x27;msg&#x27; =&gt; $msg,        &#x27;data&#x27; =&gt; $data    ];&#125;\n\n在根目录下，打开composer.json，找到autoload，在其中增加files，如：\n\n123456789101112&quot;autoload&quot;: &#123;    &quot;psr-4&quot;: &#123;        &quot;App\\\\&quot;: &quot;app/&quot;    &#125;,    &quot;classmap&quot;: [        &quot;database/seeds&quot;,        &quot;database/factories&quot;    ],    &quot;files&quot;: [        &quot;app/Lib/functions.php&quot;    ]&#125;,\n\n在终端，执行自动加载命令，即可生效在任何地方直接使用了\n\n1composer dump-autoload\nLaravel项目修改时区\n通常默认安装后，项目的时区不是中国的时区，导致自动维护字段等涉及到时间问题，总是和我们时间相差8小时，这里就需要配置时区了。\n\n打开app.php，找到’timezone’ =&gt; ‘UTC’\n\n12&#x27;timezone&#x27; =&gt; &#x27;UTC&#x27;,   //原来的默认设置&#x27;timezone&#x27; =&gt; env(&#x27;TIMEZONE&#x27;,&#x27;UTC&#x27;),   //修改为这样，通过.env文件配置\n\n打开.env，添加一行\n\n1TIMEZONE=Asia/Shanghai\nLaravel数据库事务\n\n自动：第一个参数为需要进行的数据库操作，第二个参数定义发生死锁时最大的重试次数\n\n12345DB::transaction(function () &#123;    //...    //需要执行的一系列数据库操作    //...&#125;, 5);\n\n手动使用事务\n\n1234567891011try&#123;    DB::beginTransaction();    //...    //需要执行的一系列数据库操作    //...    DB::commit();&#125;catch&#123;    DB::rollBack();&#125;\n.env配置了但无法读取数据\n12php artisan cache:clearphp artisan config:clear\n无法访问public下的资源文件\n\nhttps://laracasts.com/discuss/channels/laravel/my-css-fails-to-load-when-using-php-artisan-serve-to-host-on-my-computer\n\n更换启动方式：php -S localhost:8000 -t public\n","plink":"https://blog.jschef.com/Learning/ab11027998a1/"},{"title":"Nginx用certbot获取Let's Encrypt SSL证书","date":"2019-08-14T02:30:18.000Z","date_formatted":{"ll":"Aug 14, 2019","L":"08/14/2019","MM-DD":"08-14"},"updated":"2023-11-14T12:07:06.466Z","content":"一、本文环境\n\nLinux：Ubuntu 20.04\nNginx\n网站已经能http访问\n\n\n本文参考自Certbot官网 https://certbot.eff.org/lets-encrypt/ubuntuxenial-nginx\n\n\n二、关于Apache\n  之前弄过Apache，前面安装一切顺利，使用certbot时就出错，我修复这个错误，又冒出另外一个错误。然后又试了Let’s Encrypt原版安装，在Apache下也不行，也参考了许多文章，网上一大堆Apache下出现这样的问题的文章，怎么解决都不行，所以我放弃了。\n三、获取步骤\n3.1 确保网站能访问\n  浏览器能http访问，Let’s Encrypt下发证书时会验证的，不能访问是获取不了的。\n3.2 添加PPA源\n  依次执行下面命令，如遇到需要Y/N的就按Y，在第四条添加PPA时，需要按Enter键确认。\n\n命令均在root用户下执行，普通用户需前面加sudo指令\n\n12345apt-get updateapt-get install software-properties-commonadd-apt-repository universeadd-apt-repository ppa:certbot/certbotapt-get update\n3.3 安装Python3\n  先安装python3\n1apt-get install python3\n3.4 安装Certbot\n  执行以下命令，遇到需要确认就Y确认。\n1apt-get install certbot python3-certbot-nginx\n3.5 获取并安装证书\n\n执行命令 certbot --nginx ；\n执行过程中，需要输入你的邮箱，他们会向邮箱发一些更新和安全注意事件；\n之后就Agree/Yes吧；\nWhich names would you like to activate HTTPS for? 这里需要选择你要获取证书的域名，下面已经罗列出来了。\n\n选一个：输入域名对应数字；\n多选：输入对应数字，以逗号或者空格隔开；\n全选：不用输入，留空\n\n\nPlease choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.这一步是选择是否将http访问强制重定向到https，下面提供俩个选择，建议选择2 Redirect，下面输入数字2确认即可。选择2原因：曾经某次，我发现自己没用重定向https，当使用http访问网站时，php没解析，直接将源代码显示出来了。\nCongratulations! 恭喜，证书获取并安装完成了！证书有效期90天。\n最后，自己浏览器直接输域名试试吧。如果不能访问，请确认服务器安全规则443端口已打开。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758certbot --nginxSaving debug log to /var/log/letsencrypt/letsencrypt.logPlugins selected: Authenticator nginx, Installer nginxEnter email address (used for urgent renewal and security notices) (Enter &#x27;c&#x27; tocancel): xxxxxx@qq.comStarting new HTTPS connection (1): acme-v02.api.letsencrypt.org- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Please read the Terms of Service athttps://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You mustagree in order to register with the ACME server athttps://acme-v02.api.letsencrypt.org/directory- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(A)gree/(C)ancel: a- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Would you be willing to share your email address with the Electronic FrontierFoundation, a founding partner of the Let&#x27;s Encrypt project and the non-profitorganization that develops Certbot? We&#x27;d like to send you email about our workencrypting the web, EFF news, campaigns, and ways to support digital freedom.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(Y)es/(N)o: yStarting new HTTPS connection (1): supporters.eff.orgWhich names would you like to activate HTTPS for?- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: a.zzboy.cn2: b.zzboy.cn3: c.zzboy.cn4: d.zzboy.cn5: e.zzboy.cn6: f.zzboy.cn7: g.zzboy.cn- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Select the appropriate numbers separated by commas and/or spaces, or leave inputblank to select all options shown (Enter &#x27;c&#x27; to cancel): 5Obtaining a new certificatePerforming the following challenges:http-01 challenge for e.zzboy.cnWaiting for verification...Cleaning up challengesResetting dropped connection: acme-v02.api.letsencrypt.orgDeploying Certificate to VirtualHost /etc/nginx/conf.d/e.zzboy.cn.confPlease choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: No redirect - Make no further changes to the webserver configuration.2: Redirect - Make all requests redirect to secure HTTPS access. Choose this fornew sites, or if you&#x27;re confident your site works on HTTPS. You can undo thischange by editing your web server&#x27;s configuration.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Select the appropriate number [1-2] then [enter] (press &#x27;c&#x27; to cancel): 2Redirecting all traffic on port 80 to ssl in /etc/nginx/conf.d/e.zzboy.cn.conf- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Congratulations! You have successfully enabled https://e.zzboy.cn.....\n四、多个域名使用同一证书\n命令：\nsudo certbot certonly --cert-name example.com -d www.example.com,m.example.com\n  cert-name是指定证书的名称，可不加。-d则是该证书包含有效的域名。\n  多个域名可逗号隔开，也可以添加多个-d。\n五、手动安装域名\n  通过certbot certonly命令是仅仅获取SSL证书，需要自己手动安装。在站点配置文件/etc/nginx/conf.d/youdomain.com.conf的server里加一段。其中证书位置在/etc/letsencrypt/live/youdomain.com/目录下，可以自己先确认，也可以将证书移到其他位置。\n  配置完成后重载nginx：systemctl reload nginx\n123456789101112131415server&#123;  #  #前面省略一大段  #  #监听443端口  listen 443 ssl;  #fullchain证书位置  ssl_certificate /etc/letsencrypt/live/youdomain.com/fullchain.pem;  #私钥  ssl_certificate_key /etc/letsencrypt/live/youdomain.com/privkey.pem;  #letsencrypt为nginx的配置  include /etc/letsencrypt/options-ssl-nginx.conf;  ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;&#125;\nfullchain.pem： 是cert.pem（服务器证书本身）和chain.pem（Web浏览器为验证服务器证书）的中间证书，它包含这两个证书。\n\nLet’s Encrypt engineer: fullchain.pem is a concatenation of cert.pem and chain.pem\n\n六、Nginx手动配置http转https\n\n将站点配置文件监听80端口那行去掉；\n在站点配置文件最下方额外加一个server，内容如下：将访问域名301重定向到https路径。同时监听80端口，有强制http访问的返回404；\n配置完成后重载nginx：systemctl reload nginx\n\n1234567891011##前面省略一大段：原站点配置#server &#123;    if ($host = youdomain.com) &#123;        return 301 https://$host$request_uri;    &#125;    listen 80;    server_name youdomain.com;    return 404;&#125;\n\n如果该配置文件有多个域名，if语句块中要加break，否者会报错。\n\n12345678910111213141516##前面省略一大段：原站点配置#server &#123;    if ($host = www.youdomain.com) &#123;        return 301 https://$host$request_uri;        break;    &#125;    if ($host = blog.youdomain.com) &#123;        return 301 https://$host$request_uri;        break;    &#125;    listen 80;    server_name www.youdomain.com blog.youdomain.com;    return 404;&#125;\n七、到期更新\n命令：\ncertbot renew\n  需要证书到期前30内更新。\n八、到期自动更新\n  需要使用shell脚本，给系统加定时任务，可以百度一大堆，以下是我自己写的，可以输出更新日志：\n第一步：找个目录新建一个shell脚本文件，我这里是在/home目录下，建了一个renewCert.sh\n12345#!/bin/sh# 更新证书并记录echo `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &gt;&gt; /home/renewCert.logcertbot renew | grep -A 20 &quot;The following&quot; &gt;&gt; /home/renewCert.logecho -e &quot;\\n&quot; &gt;&gt; /home/renewCert.log\n第二步：创建linux自动任务\n执行命令：crontab -e  (初次使用选择vim-basic)\n找一行空白处，添加：\n12# 每周6凌晨30分更新证书30 0 * * 6 bash /home/renewCert.sh\n日志renewCert.log：\n12345678910112020-02-08 00:30:01The following certs are not due for renewal yet:  path/to/fullchain.pem expires on 2020-03-11 (skipped)No renewals were attempted.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -2020-02-15 00:30:01The following certs are not due for renewal yet:  path/to/fullchain.pem expires on 2020-05-10 (skipped)No renewals were attempted.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n九、附：Certbot命令\n\n参考自四个空格网：https://www.4spaces.org/certbot-command-line-tool-usage-document/\n\n9.1 用法\ncertbot [子命令] [选项] [-d 域名] [-d 域名]\n  Certbot工具用于获取和安装 HTTPS/TLS/SSL 证书。默认情况下，Certbot会尝试为本地网页服务器(如果不存在会默认安装一个到本地)获取并安装证书。最常用的子命令和选项如下:\n9.2 获取, 安装, 更新证书\n\n(默认) run：获取并安装证书到当前网页服务器；\ncertonly：获取或更新证书，但是不安装；\nrenew ：更新已经获取但快过期的所有证书；\n-d 域名列表：指定证书对应的域名列表，域名之间使用逗号分隔；\n–apache：使用Apache插件进行身份认证和安装\n–standalone：运行一个独立的网页服务器用于身份认证\n–nginx：用Nginx插件进行身份认证和安装\n–webroot：把身份认证文件放置在服务器的网页根目录下；\n–manual： 使用交互式或脚本钩子的方式获取证书；\n-n：非交互式运行；\n–test-cert：从预交付服务器上获取测试证书\n–dry-run：测试获取或更新证书，但是不存储到本地硬盘；\n\n9.3 证书管理\n\ncertificates:显示使用Certbot生成的所有证书的信息；\nrevoke：撤销证书(supply –cert-path)；\ndelete：删除证书；\n\n9.4 管理你的Let’s Encrypt账户\n\nregister：创建Let’s Encrypt ACME账户；\n–agree-tos：同意ACME服务器的订阅协议；\n-m EMAIL：接收有关账户的重要通知的邮箱地址；\n\n9.5 可选参数\n\n-h, –help： 显示帮助信息，然后退出；\n-c 配置文件, –config 配置文件：配置文件的路径 (默认: /etc/letsencrypt/cli.ini或 ~/.config/letsencrypt/cli.ini)；\n-v, –verbose：当前参数可以重复使用多次来增加输出信息的详细程度，例如 -vvv.(默认: -2)；\n-n, –non-interactive, –noninteractive：非交互式运行，即运行过程中不需要询问用户输入，但需要额外的命令行参数。当客户端发现参数缺失时会给出相应的说明。(默认: False)；\n–force-interactive：无论Certbot是否以命令行的方式运行，强制交互式运行。当前参数不能用于renew子命令。(默认: False)\n-d 域名列表, –domains 域名列表, –domain 域名列表：指定域名列表。如果有多个域名，可以多次使用-d参数，也可以在-d参数后使用逗号分隔的域名列表。(默认: 询问)；\n–cert-name 证书名称：指定证书名称。每次Certbot运行只使用一个证书名称。可以使用命令’certbot certificates’查看已生成的证书名称。当创建新的证书时，此选项用于指定证书的名称。(默认: 无)\n–dry-run：使用客户端执行一次试运行，获取测试证书(无效的证书)但不保存到磁盘。当前选项仅用于’certonly’和’renew’子命令。\n\n\n注: 尽管 –dry-run 选项试图阻止任何对系统的修改，但并不能做到完全避免: 如果使用类似apache或nginx网页服务器来认证插件，程序运行过程中，会尝试修改或恢复配置文件来获取测试证书，也会重启网页服务器来部署和回滚这些修改。如果定义了–pre-hook和–post-hook选项它们会被同时执行，这两个选项有助于更精确地模拟更新证书。–renew-hook 选项在这里不会被执行。(默认: False)\n\n\n–preferred-challenges PREF_CHALLS：A sorted, comma delimited list of the preferred challenge to use during authorization with the most preferred challenge listed first (Eg, “dns” or “tls-sni-01,http,dns”). Not all plugins support all challenges. See https://certbot.eff.org/docs/using.html#plugins for details. ACME Challenges are versioned, but if you pick “http” rather than “http-01”, Certbot will select the latest version automatically. (default: [])；\n–user-agent 用户代理：设置本客户端的用户代理信息。用户代理信息用于CA机构收集关于操作系统和插件的使用成功率。如果你希望隐藏此信息，设置此选项为””。(默认: CertbotACMEClient/0.12.0 (Ubuntu 16.04.2 LTS) Authenticator/XXX Installer/YYY)。\n\n","plink":"https://blog.jschef.com/Learning/97cad6591dc5/"},{"title":"Nginx站点配置","date":"2019-08-13T01:11:42.000Z","date_formatted":{"ll":"Aug 13, 2019","L":"08/13/2019","MM-DD":"08-13"},"updated":"2023-11-14T12:07:06.466Z","content":"一、域名解析\n  在配置站点之前，先到自己购买的域名页面，将域名A解析到我们服务器的公网IP。\n二、找到默认配置文件\n  之前安装完成了LNMP环境，现在开始配置站点了。首先是找到nginx默认的配置文件default，在 /etc/nginx/sites-enabled/ 目录下。我们将它复制到 /etc/nginx/conf.d/ ，并更改名为 yousite.com.conf 。这样改名的好处就是以后一目了然那个站点对应那个配置文件。\n1cp /etc/nginx/sites-enabled/default /etc/nginx/conf.d/www.zzboy.cn.conf\n  另外我们还需要将nginx默认站点给去掉，编辑 /etc/nginx/nginx.conf 文件，找到 include /etc/nginx/sites-enabled/*; 将其注释掉。当然也可以选择忽略此步，不关闭这个apache2默认站点。我们可以注意到，这个配置文件中这两行可以加载conf.d目录下的所有以.conf为后缀的文件和sites-enabled下的所有配置文件。我们直接注释掉这个加载默认站点的语句，即可关闭默认站点。\n1234vim /etc/nginx/nginx.conf        include /etc/nginx/conf.d/*.conf;#       include /etc/nginx/sites-enabled/*;\n三、配置文件\n  打开我们的复制到conf.d目录下的配置文件，编辑它。以下就是默认配置文件的内容，我就在里面用注释简单说一下。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970### You should look at the following URL&#x27;s in order to grasp a solid understanding# .....此处忽略一大堆注释# Default server configuration#server &#123;        # 监听ipv4的80端口        listen 80 default_server;        # 监听ipv6的80端口        listen [::]:80 default_server;        #SSL证书配置，本段忽略，用Let&#x27;s Encrypt免费SSL证书可以自动配置        # SSL configuration        # .....此处忽略一大堆注释        # 站点目录：也就是你的网站源代码根目录        root /var/www/html;        # 入口页面，一般是index.html 或者 index.php，当然改成其他如home.php也行        # Add index.php to the list if you are using PHP        index index.html index.htm index.nginx-debian.html;        # 服务器名称，这里就是绑定域名，_表示不用域名，ip直接访问        server_name _;        # 网站404文件路径配置        location / &#123;                # First attempt to serve request as file, then                # as directory, then fall back to displaying a 404.                try_files $uri $uri/ =404;        &#125;        # php文件解析设置        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        # 我们用php就需要把下面注释去掉        #location ~ \\.php$ &#123;        #       include snippets/fastcgi-php.conf;        #       # 用原生php-cgi管理        #       # With php7.0-cgi alone:        #       fastcgi_pass 127.0.0.1:9000;        #       # 用php-fpm管理，两者只能选一        #       # With php7.0-fpm:        #       fastcgi_pass unix:/run/php/php7.0-fpm.sock;        #&#125;        # 阻止apache站点的配置文件.htaccess。        # deny access to .htaccess files, if Apache&#x27;s document root        # concurs with nginx&#x27;s one        # 我们这是nginx服务器，可能你上传的站点以前是apache的，这里是避免不必要的问题需要将下面注释去掉        #location ~ /\\.ht &#123;        #       deny all;        #&#125;&#125;# 这下面就是给的一个配置简单例子。# Virtual Host configuration for example.com## You can move that to a different file under sites-available/ and symlink that# to sites-enabled/ to enable it.##server &#123;#       listen 80;#       listen [::]:80;##       server_name example.com;##       root /var/www/example.com;#       index index.html;##       location / &#123;#               try_files $uri $uri/ =404;#       &#125;#&#125;\n四、我们的配置\n  上面不懂没关系，可以直接拿走下面的用，一下以站点www.zzboy.cn配置为例：\n1234567891011121314151617181920212223242526#config for www.zzboy.cnserver &#123;        listen 80;        # listen [::]:80; #服务器没有ipv6地址就不用监听了        root /home/www.zzboy.cn; #站点目录名www.zzboy.cn，方便管理        # 首页，入口页        index index.html index.htm index.php;        # 绑定域名        server_name www.zzboy.cn;        # 404 路径        location / &#123;                try_files $uri $uri/ =404;        &#125;        # php管理，我们是7.2，一般都是在/run/php/下        location ~ \\.php$ &#123;                include snippets/fastcgi-php.conf;        #       # With php7.0-cgi alone:        #       fastcgi_pass 127.0.0.1:9000;        #       # With php7.0-fpm:                fastcgi_pass unix:/run/php/php7.2-fpm.sock;        &#125;        # 阻止.htaccess        location ~ /\\.ht &#123;                deny all;        &#125;&#125;\n  配置完成后，保存退出。重新加载nginx，重载配置文件前，要确认存在站点目录，否者会报错。\n123systemctl reload nginx#如果报错，可用以下命令查看错误nginx -t\n  现在可以用在浏览器输入域名访问了。\n五、多站点配置\n  多站点配置很简单，下面我以第二个站点为blog.zzboy.cn进行配置。\n\n同样先将网站2的域名A解析到服务器公网IP。\n复制之前配置好的文件\n\n1cp /etc/nginx/conf.d/www.zzboy.cn.conf /etc/nginx/conf.d/blog.zzboy.cn.conf\n\n打开blog.zzboy.cn.conf，只需要改两处（站点目录和域名绑定）就行了：\n\n1234567891011121314151617181920212223242526#config for blog.zzboy.cnserver &#123;        listen 80;        # listen [::]:80; #服务器没有ipv6地址就不用监听了        root /home/blog.zzboy.cn; #站点目录名blog.zzboy.cn，方便管理        # 首页，入口页        index index.html index.htm index.php;        # 绑定域名        server_name blog.zzboy.cn;        # 404 路径        location / &#123;                try_files $uri $uri/ =404;        &#125;        # php管理，我们是7.2，一般都是在/run/php/下        location ~ \\.php$ &#123;                include snippets/fastcgi-php.conf;        #       # With php7.0-cgi alone:        #       fastcgi_pass 127.0.0.1:9000;        #       # With php7.0-fpm:                fastcgi_pass unix:/run/php/php7.2-fpm.sock;        &#125;        # 阻止.htaccess        location ~ /\\.ht &#123;                deny all;        &#125;&#125;\n  配置完成后，保存退出。重新加载nginx：\n1systemctl reload nginx\n  现在在浏览器访问第二个站点了。\n六、有个小疑问\n  配置多站点后，只能有一个站点可用default_server，为啥？\n","plink":"https://blog.jschef.com/Learning/a6fb2798339e/"},{"title":"Ubuntu 16.04搭建lnmp环境","date":"2019-08-12T09:00:00.000Z","date_formatted":{"ll":"Aug 12, 2019","L":"08/12/2019","MM-DD":"08-12"},"updated":"2023-11-14T12:07:06.466Z","content":"一、环境说明\n\nLinux：阿里云轻量应用服务器Ubuntu16.04\nNginx：1.10.3\nMySQL：5.7.27\nPHP： 7.2.21\n\n\n二、写前吐槽\n  回想上次完全自己搭环境，还是大一的时候，啥也不会，linux基础命令都不会，买了个学生机，安装网上方法，lnmp搭建了三天，期间出问题不知重置了多少次服务器。后来我就直接用镜像市场的免费镜像了。\n  这次，因为项目需要，一不小心买了台阿里云轻量应用服务器，买完服务器更换系统镜像才发现阿里云轻量应用服务器，除了安装官方提供的几个应用镜像wordpress、lnmp啥的，此外只能用纯系统镜像了，应用市场用不了。于是我就选择了Ubuntu16.04，决定自己再搭一次！！\n三、安装步骤\n3.1 购买服务器\n  购买过程就免了，选系统的时候一定选Linux的Ubuntu，本文是针对Linux的，至于Ubuntu版本，没什么要求，可以和我选一样的，也可以选更高的19版本，低版本也是可以的。\n3.2 下载连接工具Putty\nPutty完整下载页\n推荐Putty.exe 不要1M的大小，也不用安装。下载后直接运行，输入你服务器的公网IP地址直接连接。\n3.3 使用root用户\n  如果不是root用户，建议切换的root用户下进行安装。现在服务器上也没有什么项目，一片空白，用root用户不怕出错，错了大不了重置系统重来嘛，反正现在也只是自己一个鼓捣。用root用户畅通无阻，方便！但是，今后对已有项目或者重要的服务器，慎用root用户，用普通用户操作，需要权限是再确认一下就Ok了。\n\n切换用户命令\n\n1su root\n3.4 安装nginx\n\n拿到新机器时，先进行apt-get更新，不然会出错。\n\n1apt-get update\n\n安装nginx\n\n1apt-get install nginx\n\n验证是否安装成功\n\n12nginx -vnginx version: nginx/1.10.3 (Ubuntu)\n3.5 安装MySQL\n\n安装MySQL\n\n1apt-get install mysql-server\n\n安装过程中会输入两次账号为root的密码，第二次为确认密码。\n验证是否成功\n\n12mysql --versionmysql  Ver 14.14 Distrib 5.7.27, for Linux (x86_64) using  EditLine wrapper\n\n设置密码\n\n123456mysql -uroot -puse mysql;update user set authentication_string=PASSWORD(&quot;密码&quot;) where user=&#x27;root&#x27;;update user set plugin=&quot;mysql_native_password&quot;;flush privileges;quit;\n\n开启远程连接\n\n注意：远程连接需要开启默认端口，需要到控制台安全组开启3306端口\n1/etc/mysql/mysql.conf.d/mysqld.cnf\n注释掉bind-address:\n1#bind-address           = 127.0.0.1\n然后重启mysql：\n1service mysql restart\n3.6 安装PHP\n\n正常执行install会找不到源，所以可以通过修改PPA源进行安装。第三条命令添加ppa源时，会让点击一次Enter键，点完若长时间不响应，可以Ctrl+C停止安装，再重新执行一次（我的经历）。\n\n12345apt-get install python-software-propertiesapt install software-properties-commonadd-apt-repository ppa:ondrej/phpapt-get updateapt-get install -y php7.2\n\n验证安装是否成功\n\n12345php -vPHP 7.2.21-1+ubuntu16.04.1+deb.sury.org+1 (cli) (built: Aug  7 2019 09:53:30) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies    with Zend OPcache v7.2.21-1+ubuntu16.04.1+deb.sury.org+1, Copyright (c) 1999-2018, by Zend Technologies\n\n安装完PHP后，还要安装一些基础扩展model\n查询所有扩展\n\n1apt-cache search php7.2\n\n扩展安装\n\n1apt-get install php7.2-mysql php7.2-curl php7.2-json php7.2-cgi php7.2-xsl php7.2-bcmath php7.2-gmp php7.2-mbstring php7.2-zip php7.2-dom\n\n安装php-fpm，为什么要用php-fpm\n\n1apt-get install php7.2-fpm\n3.7 nginx管理\n\n关闭nginx：\n\n1systemctl stop nginx\n\n开启nginx：\n\n1systemctl start nginx\n\n重启nginx：\n\n1systemctl restart nginx\n\n如果您只是进行配置更改，Nginx通常可以重新加载，可以使用此命令：\n\n1systemctl reload nginx\n\n关闭 Nginx随系统启动\n\n1systemctl disable nginx\n\n开启 Nginx 随系统一起启动\n\n1systemctl enable nginx\n3.8 参考文章\n  本文安装步骤是参考简书的一片文章，根据实际情况，稍有改变。\n  尊重原创：原文地址：沧海99\n四、站点访问\n  上面过程已经完成的环境搭建，现在可以在浏览器输入你服务器的公网IP地址访问了。你将会看到一片Apache2 Ubuntu Default Page的默认页面。此页面位于 /var/www/html/index.html, nginx配置文件位于 /etc/nginx/sites-enabled/default。至于如何配置nginx站点，可自行百度一下。\n","plink":"https://blog.jschef.com/Learning/1e8a589a019b/"},{"title":"JavaScript-axios","date":"2019-08-01T08:25:00.000Z","date_formatted":{"ll":"Aug 1, 2019","L":"08/01/2019","MM-DD":"08-01"},"updated":"2023-11-14T12:07:06.466Z","content":"一、特点\nAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。\n\n从浏览器中创建 XMLHttpRequests\n支持 Promise API\n拦截请求和响应\n转换请求数据和响应数据\n取消请求\n自动转换 JSON 数据\n客户端支持防御 XSRF\n\n二、安装\n使用npm：\n1npm install axios --save\n使用cdn：\n1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n三、使用\n3.1 通用API\naxios(config)\n12345678910// 发送 POST 请求axios(&#123;    method: &#x27;post&#x27;,    url: &#x27;&#x27;,    data: &#123;      key: value    &#125;  &#125;)  .then( function (res)&#123;&#125; )  .catch( function (err)&#123;&#125; );\n成功返回：\n1234567&#123;  data: &#123;&#125;,  status: 200,       //HTTP 状态码  statusText: &#x27;OK&#x27;,  //HTTP 状态信息  headers: &#123;&#125;,       //响应头  config: &#123;&#125;         //为请求提供的配置信息&#125;\n错误处理：\n123456789101112.catch(function (error) &#123;  if (error.response) &#123;    // 请求已发出，但服务器响应的状态码不在 2xx 范围内    console.log(error.response.data);    console.log(error.response.status);    console.log(error.response.headers);  &#125; else &#123;    // 因axios配置而导致的错误    console.log(&#x27;Error&#x27;, error.message);  &#125;  console.log(error.config);  &#125;);\n3.2 axios.get()\naxios.get(url[, config])\n1234567891011axios.get(&#x27;url&#x27;, &#123;    params: &#123;      key: value   //会处理成：url?key=value&amp;...    &#125;  &#125;)  .then(function (response) &#123;    console.log(response);  &#125;)  .catch(function (error) &#123;    console.log(error);  &#125;);\n3.3 axios.post()\naxios.post(url[, data[, config]])\n123456789axios.post(&#x27;url&#x27;, &#123;    key: value  &#125;)  .then(function (response) &#123;    console.log(response);  &#125;)  .catch(function (error) &#123;    console.log(error);  &#125;);\n四、并发请求\naxios.all(iterable)\naxios.spread(callback)\n123456789101112function getUserAccount() &#123;  return axios.get(&#x27;url1&#x27;);&#125;function getUserPermissions() &#123;  return axios.get(&#x27;url2&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()])  .then(axios.spread(function (acct, perms) &#123;    // 两个请求现在都执行完成  &#125;));\n五、其他别名请求\n在使用别名方法时， url、method、data 这些属性都不必在配置中指定。\naxios.request(config)\naxios.get(url[, config])\naxios.delete(url[, config])\naxios.head(url[, config])\naxios.post(url[, data[, config]])\naxios.put(url[, data[, config]])\naxios.patch(url[, data[, config]])\n六、config详细\n只有 url 是必需的，method默认使用 get 方法。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&#123;  // `url` 是用于请求的服务器 URL  url: &#x27;url&#x27;,  // `method` 是创建请求时使用的方法  method: &#x27;get&#x27;, // 默认是 get  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL  baseURL: &#x27;https://some-domain.com/api/&#x27;,  // `transformRequest` 允许在向服务器发送前，修改请求数据  // 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream  transformRequest: [function (data) &#123;    // 对 data 进行任意转换处理    return data;  &#125;],  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据  transformResponse: [function (data) &#123;    // 对 data 进行任意转换处理    return data;  &#125;],  // `headers` 是即将被发送的自定义请求头  headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;,  // `params` 是即将与请求一起发送的 URL 参数  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象  params: &#123;    ID: 12345  &#125;,  // `paramsSerializer` 是一个负责 `params` 序列化的函数  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)  paramsSerializer: function(params) &#123;    return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;)  &#125;,  // `data` 是作为请求主体被发送的数据  // 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27;  // 在没有设置 `transformRequest` 时，必须是以下类型之一：  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams  // - 浏览器专属：FormData, File, Blob  // - Node 专属： Stream  data: &#123;    firstName: &#x27;Fred&#x27;  &#125;,  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)  // 如果请求话费了超过 `timeout` 的时间，请求将被中断  timeout: 1000,  // `withCredentials` 表示跨域请求时是否需要使用凭证  withCredentials: false, // 默认的  // `adapter` 允许自定义处理请求，以使测试更轻松  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).  adapter: function (config) &#123;    /* ... */  &#125;,  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头  auth: &#123;    username: &#x27;janedoe&#x27;,    password: &#x27;s00pers3cret&#x27;  &#125;,  // `responseType` 表示服务器响应的数据类型，可以是 &#x27;arraybuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;  responseType: &#x27;json&#x27;, // 默认的  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称  xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // default  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称  xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // 默认的  // `onUploadProgress` 允许为上传处理进度事件  onUploadProgress: function (progressEvent) &#123;    // 对原生进度事件的处理  &#125;,  // `onDownloadProgress` 允许为下载处理进度事件  onDownloadProgress: function (progressEvent) &#123;    // 对原生进度事件的处理  &#125;,  // `maxContentLength` 定义允许的响应内容的最大尺寸  maxContentLength: 2000,  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte  validateStatus: function (status) &#123;    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的  &#125;,  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目  // 如果设置为0，将不会 follow 任何重定向  maxRedirects: 5, // 默认的  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：  // `keepAlive` 默认没有启用  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),  // &#x27;proxy&#x27; 定义代理服务器的主机名称和端口  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。  proxy: &#123;    host: &#x27;127.0.0.1&#x27;,    port: 9000,    auth: : &#123;      username: &#x27;mikeymike&#x27;,      password: &#x27;rapunz3l&#x27;    &#125;  &#125;,  // `cancelToken` 指定用于取消请求的 cancel token  // （查看后面的 Cancellation 这节了解更多）  cancelToken: new CancelToken(function (cancel) &#123;  &#125;)&#125;\n","plink":"https://blog.jschef.com/Learning/3802578f2aa7/"},{"title":"Vue学习-组件","date":"2019-07-24T09:30:00.000Z","date_formatted":{"ll":"Jul 24, 2019","L":"07/24/2019","MM-DD":"07-24"},"updated":"2023-11-14T12:07:06.466Z","content":"1、组件注册\n全局注册：Vue.component(‘component-name’, { /* … */ })，使用时直接使用。\n局部注册：var ComponentA = { /* … */ }，使用前现在components里声明。\n单文件组件：使用import ComponentA from ‘./ComponentA’，再在components里声明。\n2、prop声明\n命名和定义：根据vue代码规范B级建议，prop应该使用驼峰写法，且最好给prop说明数据类型。\n3、父子组件间传值\n父-&gt;子：用prop\n子-&gt;父：在methods内使用this.$emit(event, value)事件触发传出\n4、自定义事件\n事件名：this.$emit(‘kebab-case’)\n自定义v-model：\n12345678910111213141516Vue.component(&#x27;base-checkbox&#x27;, &#123;  model: &#123;    prop: &#x27;checked&#x27;,    event: &#x27;change&#x27;  &#125;,  props: &#123;    checked: Boolean  &#125;,  template: `    &lt;input      type=&quot;checkbox&quot;      v-bind:checked=&quot;checked&quot;      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;    &gt;  `&#125;)\n使用：\n1&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;\n5、在组件上使用原生事件\n1v-on:click.native\n6、组件实践\n根据组件学习，完成了一个组件：添加标签\n组件作用：给一个事物添加标签\n组件使用：在输入框输入内容（限制长度4字符），回车或按钮添加；单击关闭图标删除一个，双击标签同样也可以删除。\n\n\n\n属性\n类型\n默认值\n作用\n\n\n\n\ncloseIcon\nBoolean\n\n标签显示删除图标，不加不显示\n\n\ninitList\nArray\n\n初始化显示标签\n\n\ncolor\nString\nblue\n标签颜色，可选red、green、blue\n\n\nmax\nNumber\n5\n标签个数限制\n\n\n\n\n事件\n返回值\n作用\n\n\n\n\non-change\nArray\n返回当前标签数组\n\n\n导入步骤：\n12345//导入import SettingTags from &#x27;../components/SettingTags.vue&#x27;//示例中引用，这里简化了components: &#123; SettingTags &#125;\n12&lt;setting-tags close-icon @on-changed=&quot;getarr&quot; color=&quot;red&quot; :initList=&quot;list&quot;&gt;&lt;/setting-tags&gt;\n源码：SettingTags.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;input class=&quot;input&quot; type=&quot;text&quot; maxlength=&quot;4&quot;  placeholder=&quot;添加标签&quot; v-model=&quot;val&quot; @keyup.enter=&quot;handEnterClick()&quot; /&gt;    &lt;Button class=&quot;btn-add&quot; type=&quot;primary&quot; @click=&quot;handEnterClick()&quot; shape=&quot;circle&quot; icon=&quot;md-return-left&quot;&gt;&lt;/Button&gt;    &lt;br&gt;    &lt;div class=&quot;tags&quot;&gt;      &lt;div class=&quot;tag-content&quot; @dblclick=&quot;handDeleteTag(index)&quot; v-for=&quot;(item,index) of lists&quot; :key=&quot;index&quot; &gt;        &lt;div :class=&quot;[&#x27;tag&#x27;,color]&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;        &lt;Icon type=&quot;md-close&quot; v-if=&quot;closeIcon&quot; @click=&quot;handDeleteTag(index)&quot;/&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;SettingTags&#x27;,  props:&#123;    color: &#123;      type: String,      default: &#x27;blue&#x27;    &#125;,    closeIcon: Boolean,    initList: Array,    max: &#123;      type: Number,      default: 5    &#125;,  &#125;,  data () &#123;    return &#123;      lists: this.initList,      val: &#x27;&#x27;,      colors: [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]    &#125;  &#125;,  methods: &#123;    handEnterClick () &#123;      if(this.lists.length == this.max)&#123;        this.$Message.error(&quot;超过标签个数限制&quot;)        return      &#125;      this.val === &#x27;&#x27; ? &#x27;&#x27; : this.lists.push(this.val)      this.val = &#x27;&#x27;      this.$emit(&#x27;on-changed&#x27;, this.lists)    &#125;,    handDeleteTag (index) &#123;      this.lists.splice(index, 1)      this.$emit(&#x27;on-changed&#x27;, this.lists)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;  .container&#123;    margin: 8px;  &#125;  .input&#123;    width: 100px;    display: inline-block;    height: 28px;    line-height: 1.5;    padding: 2px 7px;    font-size: 12px;    border: 1px solid #dcdee2;    border-radius: 4px;    color: #515a6e;    background-color: #fff;    background-image: none;    position: relative;    cursor: text;    transition: border .2s ease-in-out,background .2s ease-in-out,box-shadow .2s ease-in-out;    outline: #57a3f3;  &#125;  .input:focus&#123;    border-color: #57a3f3;    box-shadow: #57a3f3 0px 0px 4px;  &#125;  .btn-add&#123;    margin-left: 5px;    height: 26px !important;    width: 26px !important;    margin-bottom: 3px;  &#125;  .tags&#123;    color: #515a6e;    display: flex;    margin-top: 2px;    width: 100%;    flex-wrap: wrap;  &#125;  .tag-content&#123;    display: flex;    margin: 4px 2px;  &#125;  .tag&#123;    width: fit-content;    padding: 2px;    font-size: 12px;    line-height: 14px;    border-radius: 3px;  &#125;  .green&#123;    border: 1px solid #b7eb8f;    background: #f6ffed;    color: #52c41a!important;;  &#125;  .blue&#123;    border: 1px solid #91d5ff;    background: #e6f7ff;    color: #1890ff!important;  &#125;  .red&#123;    border: 1px solid #ffa39e;    background: #fff1f0;    color: #f5222d!important;  &#125;  i&#123;    margin-top: -5px;    display: inline-block;    height: fit-content;  &#125;&lt;/style&gt;\n","plink":"https://blog.jschef.com/Learning/ba1793c0983f/"},{"title":"Vue学习-代码规范","date":"2019-07-23T09:30:00.000Z","date_formatted":{"ll":"Jul 23, 2019","L":"07/23/2019","MM-DD":"07-23"},"updated":"2023-11-14T12:07:06.466Z","content":"\n\n组件名：应该以多个单词进行命名；\n\n\n单文件组件的文件名：应该始终是单词大写开头；\n\n\n基础组件名：应用特定样式和约定的基础组件，应该全部以一个特定的前缀开头；\n\n\n单例组件名：只应用于单个活跃实例的组件，应以The前缀命名，以示唯一性；\n\n\n紧密耦合组件名：和父组件紧密耦合的子组件，应以父组件名作为前缀命名；\n\n\n组件名中的单词顺序：应以高级别单词开头，以描述性的修饰词结尾；\n\n\n完整单词的组件名：组件名应该倾向于完整单词而不是缩写；\n\n\n模板中组件名大小写：单文件组件和字符串模板中组件名应该总是PascalCase的，但是在DOM模板中总是kebab-case的；\n\n\nJS/JSX中的组件：应该始终是PascalCase的；\n\n\n组件数据：组件的data必须是一个函数；\n\n\nProp定义：Prop定义应该尽量详细；\n\n\nProp名大小写：在声明prop的时候，其命名始终应该驼峰写法，在模板和JSX中应始终kebab-case；\n\n\n为v-for设置键值：总是用key配合v-for；\n\n\n避免v-if和v-for用在一起：永远不要吧v-if和v-for同时用在一个元素上；\n\n\n为组件样式设置作用域：对于顶级App组件和布局组件中的样式可以是全局的，但其他所有组件都有应该是有作用域的，用scoped特性；\n\n\n私有属性名：使用模块作用保持不允许外部访问的函数的私有性，用$_；\n\n\n自闭合组件：在单文件、字符串、JSX组件中用PascalCase单标记，在DOM模板中用kebab-case双标记；\n\n\n多个特性的元素：多个特性的元素应该多行撰写，每个属性一行；\n\n\n模板中简单的表达式：在组件模板中只应包含简单表达式，复杂表达式应该重构为计算属性和方法；\n\n\n简单的计算属性：应该吧复杂计算属性，分割为尽可能多的简单的属性；\n\n\n带引号的特性值：:style=“{ width: sidebarWidth + ‘px’ }”；\n\n\n指令缩写：(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:) 应该要么都用要么都不用；\n\n\n","plink":"https://blog.jschef.com/Learning/fb3bb04d6643/"},{"title":"Vue学习-项目搭建","date":"2019-07-22T09:00:00.000Z","date_formatted":{"ll":"Jul 22, 2019","L":"07/22/2019","MM-DD":"07-22"},"updated":"2023-11-14T12:07:06.466Z","content":"计算属性和监听器\nwatch监听器写法：\n1变量名：function( new_value, old_value)&#123;&#125;\ncomputed计算属性写法：\n1新变量名：function()&#123;this.变量&#125;\n区别：watch监听单个变量变化就执行内部逻辑，而computed可以检测一个或同时多个变化，将执行内部逻辑结果返回给此计算名（新变量）。\n一句话：watch(异步场景):单个变量；computed(数据联动):实例内多个变量\nvue-cli、vue-router和vuex\n三种创建项目方法：\n① vue-cli：vue create newProject\n② UI图形界面：vue ui\n③ WebStorm新建项目，也是基于vue-cli的vue-router: 路由管理工具\n组件懒加载：\n1component: () =&gt; import(/* webpackChunkName: &quot;list&quot; */ &#x27;./views/List.vue&#x27;)\n组件跳转：\n1&lt;router-link :to=&quot;&#123;name: &#x27;list&#x27;&#125;&quot;&gt;新闻列表&lt;/router-link&gt;\nvuex：为vue开发提供组件状态集中管理模式\n12345678910import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123;      state: &#123;            lists: []      &#125;,      mutations: &#123;&#125;,      actions: &#123;&#125;&#125;)\n其他页面使用vuex：\n12import store from ‘@/store.js’methods: &#123; store.commit (mutations方法, 传参)&#125;","plink":"https://blog.jschef.com/Learning/0942d62fb0f3/"},{"title":"Vue学习-组件data和render","date":"2019-07-19T09:00:00.000Z","date_formatted":{"ll":"Jul 19, 2019","L":"07/19/2019","MM-DD":"07-19"},"updated":"2023-11-14T12:07:06.466Z","content":"Vue组件data\n在之前我使用vue.js时，实例Vue中的data是直接赋值一个对象的。但是，在看过公司项目的Vue项目时，发现data是用函数返回的。\n12345data: function () &#123;  return &#123;    count: 0  &#125;&#125;\n查看学习官方文档后，理解了在组件使用中，组件的data必须是一个函数。因为在使用组件时，一个页面可能有多个组件同时使用，改变组件Vue实例data，时，其他组件data会同时受到影响。但通过data使用匿名函数，可以保证页面内每一个实例是独立的data。\nVue render\nVue在绝大多数情况下是使用 template，然而在某些特定的场景中，我们需要JavaScript创建一些简单html。比如公司项目的表格最后一列编辑选项按钮，是用一个div突出固定显示在表格右侧的。render基本用法：\n12345render: function (createElement) &#123;  return createElement(&#x27;div&#x27;, [\tcreateElement (&#x27;Button&#x27;, &#123;props: &#123; &#125;, style: &#123; &#125;, on: &#123; &#125;&#125;&#125;, &#x27;文字&#x27;),])&#125;\n一般render创建的html不是静态的，需要在传入一个参数对象，对新建的html进行设计。\n","plink":"https://blog.jschef.com/Learning/8d0cb17b0653/"},{"title":"canvas学习","date":"2019-07-18T06:33:00.000Z","date_formatted":{"ll":"Jul 18, 2019","L":"07/18/2019","MM-DD":"07-18"},"updated":"2023-11-14T12:07:06.466Z","content":"canvas是HTML5新出的标记，是可以通过api绘制图形。使用之前必须的创建一块可用的canvas画布，之后的操作都是基于这画布上进行操作绘制。canvas是基于状态绘图的，先设定状态，通过方法执行。\n\n获取画布：\n\n12let canvas = document.getElementById(&quot;canvas&quot;);let context = canvas.getContext(&quot;2d&quot;);\n可通过canvas.width和canvas.height设置画布宽高。\n\n其他方法\n\n1234567891011121314151617moveTo() //将笔触移至指定点beginPath() //起始一条路径closePath() //闭合至起始点lineTo() //新建一个起点arc() //绘制一条曲线stroke() //绘制已定义路径fill() //填充当前绘图fillStyle //设置填充样式strokeStyle //设置笔触样式shadowColor //设置阴影颜色shadowBlur //设置阴影模糊级别clearRect() //清除指定像素（动画去重影）fillText() //设置文本font //设置文本字体属性textAlign //设置文本对齐方式strokeText() //绘制文本drawImage() //绘制图象\n学习成果\n\n源码\nhttps://github.com/Chef5/canvas-Clock\n","plink":"https://blog.jschef.com/Learning/973f37045c68/"},{"title":"JavaScript-事件","date":"2019-07-18T03:33:00.000Z","date_formatted":{"ll":"Jul 18, 2019","L":"07/18/2019","MM-DD":"07-18"},"updated":"2023-11-14T12:07:06.466Z","content":"事件流\n事件流：描述的是从页面中接收事件的顺序。其中有两种概览，分别是事件冒泡流和事件捕获流。\n事件冒泡流，是IE开发团队提出的，现在浏览器都支持冒泡流事件。冒泡流事件是事件从具体的的元素接收，然后逐级上传到较为不具体的节点（button-&gt;div-&gt;body-&gt;html-&gt;document）\n事件捕获流，是NC团队提出的，思想是最先由不具体节点接收事件，然后逐级下传到具体元素，恰好和冒泡流相对（document-&gt;html-&gt;body-&gt;div-&gt;button）。\n事件处理\n事件是用户或浏览器执行的动作，以on开头，有如onclick、onload、onmouceover等。\n事件处理分为5种情况：HTML事件处理、DOM0级事件、DOM2级事件、IE事件和跨浏览器事件。\nHTML事件是直接绑定某个元素上的，通过在元素属性上直接加事件处理名称。DOM0级是通过JavaScript获取节点，在通过节点属性判断是否做相应动作。DOM2级是通过节点addEventListener或removeEventListener给节点绑定或移除事件。IE事件和DOM2类似，通过attachEvent()和 detachEvent()给节点绑定和移除事件。跨浏览器事件是通过EventUtil对象的addHandler()方法绑定时间处理。\n事件对象\n兼容 DOM 的浏览器会将一个 event对象传入到事件处理程序中。event对象含bubbles、currentTarget、detail、target、type等常用属性和方法。IE中的对象事件可以通过window.event获取。而跨浏览器的事件对象可以通过EventUtil对象的getEvent()方法获取。\n事件类型\n\nUI事件：DOMActivate、load、unload、abort、error、select、resize、scroll；\n焦点事件：blur、DOMFocusIn、DOMFocusOut、focus、focusin、focusout；\n鼠标事件：click、dblclick、mousedown、mouseenter、mouseleave、mousemove、mouseout、mouseover、mouseup；\n键盘事件：keydown、keypress、keyup；\n设备事件：orientationchange、MozOrientation、deviceorientation、devicemotion；\n另外还有：复合事件、变动事件、触摸和手势事件。\n\n事件委托\n对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。通常在DOM 树中尽量最高的层次上添加一个事件处理程序，通过传入event对象，有event对象的target来区别不同事件响应。\n","plink":"https://blog.jschef.com/Learning/1444d05a63dc/"},{"title":"JavaScript获取URL参数","date":"2019-07-17T05:53:00.000Z","date_formatted":{"ll":"Jul 17, 2019","L":"07/17/2019","MM-DD":"07-17"},"updated":"2023-11-14T12:07:06.466Z","content":"获取单个参数\n12345678910111213/** * 根据键获取url单个参数值 * @param  String name 键 * @return String       */function getUrlParam(name) &#123;  //建立正则匹配规则\tlet reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);  //从？开始匹配\tlet r = window.location.search.substr(1).match(reg);  //解码返回\tif (r != null) return unescape(r[2]); return null;&#125;\n获取全部参数\n12345678910111213141516171819202122232425/** * 获取当前页Url所有参数 * @return Object */function getUrlParams()&#123; //取得查询字符串并去掉开头的问号 let qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split(&quot;&amp;&quot;) : [], item = null,name = null,value = null, len = items.length; //逐个将每一项添加到 args 对象中 for (let i=0; i &lt; len; i++)&#123;   item = items[i].split(&quot;=&quot;);   name = decodeURIComponent(item[0]);   value = decodeURIComponent(item[1]);   if (name.length) &#123;     args[name] = value;   &#125; &#125; return args;&#125;\n","plink":"https://blog.jschef.com/Learning/c23845560169/"},{"title":"JavaScript-对象创建","date":"2019-07-17T03:33:00.000Z","date_formatted":{"ll":"Jul 17, 2019","L":"07/17/2019","MM-DD":"07-17"},"updated":"2023-11-14T12:07:06.466Z","content":"工厂模式\n123456789function createPerson(name, age)&#123;      var o = new Object();      o.name = name;      o.age = age;      o.sayName = function()&#123;            alert(this.name);      &#125;;      return o; &#125;\n通过函数createPerson可以无限次的创建新的对象，工厂模式解决了创建多个相似对象的问题，但没有解决对象的标识问题（怎么知道对象的类型）。\n构造函数模式\n12345678function Person(name, age)&#123;      this.name = name;      this.age = age;      this.sayName = function()&#123;            alert(this.name);      &#125;; &#125; var person2 = new Person(&quot;Tom&quot;, 27);\n构造函数模式没有显式地创建对象，而直接将方法和属性直接赋值给了this，且没有返回语句。在使用构造函数方法创建对象时，是用过new关键字使用的。构造函数模式解决了工厂模式无法标识对象的问题，但也存在一个问题就是每个方法都是实例上重新创建的，即没有实现方法的复用。其中一种解决方法是将对象方法在全局声明，在构造函数中引用。另一种解决方法是原型模式。\n原型模式\n1234567function Person()&#123; &#125;     Person.prototype.name = &quot;Tom&quot;;     Person.prototype.age = 29;     Person.prototype.sayName = function()&#123;          alert(this.name);     &#125;; var person1 = new Person();\n每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，即可以让所有对象实例共享它所包含的属性和方法。\n","plink":"https://blog.jschef.com/Learning/308102780ef2/"},{"title":"JavaScript-数据操作","date":"2019-07-17T03:33:00.000Z","date_formatted":{"ll":"Jul 17, 2019","L":"07/17/2019","MM-DD":"07-17"},"updated":"2023-11-14T12:07:06.466Z","content":"类型检测\n\ntypeof 检测数据类型\ninstanceof 检测是哪个对象的实例\nArray.isArray(value) 检测数组\n\n数组操作\n\njoin() 重现方法toString() 使输出分隔字符替换为传入参数\npush() 末尾加项，return length\npop() 末尾移除一项，return 移除项\nshift() 首部移除一项，return 移除项\n堆栈实现：push() + pop()\n队列实现：push() + shift()\nreverse() 反序\nsort() 按字符类型排序，可传入自定义函数实现升序降序排列\nslice(start,[end+1])截取数组\nsplice(start,n,value…) 插入值\nevery(f(item,index,array){}) 均满足返回true\nsome(f(item,index,array){}) 存在一项满足就返回true\nfitter(f(item,index,array){}) 返回数组满足项\nforeach(f) 迭代\nreduce(f(pre,cur,index,array){}) 函数f返回值传入下一项操作\nreduceRight(f) 反方向reduce()\n\n字符串操作\n\nstr.charAt(n) 取字符\nstr.concat() 连接字符串（+）\nstr.slice(start,[edn+1]) 区间截取\nstr.substring(start,[end+1])等同于slice\nstr.substr(start,n) 从start开始截取n长\nstr.split() 分割字符串为数组\n\nMath\n\nMath.ceil() 向上舍入\nMath.floor() 向下舍入\nMath.round() 四舍五入\nMath.random() 大于等于0，小于1\n从某个整数范围任选值\n值 = Math.floor(Math.random()*总数 + 起始值)\n\n","plink":"https://blog.jschef.com/Learning/dfc654fe685e/"},{"title":"JavaScript函数问题","date":"2019-07-16T03:33:00.000Z","date_formatted":{"ll":"Jul 16, 2019","L":"07/16/2019","MM-DD":"07-16"},"updated":"2023-11-14T12:07:06.466Z","content":"Function类型创建\n  以下三种方法创建的函数作用相同，在使用上几乎也没有区别。区别在最后一章: 函数声明与函数表达式 。\n使用函数声明\n123function sum (num1, num2) &#123; return num1 + num2;&#125;\n使用函数表达式\n123var sum = function(num1, num2)&#123; return num1 + num2;&#125;;\nFunction构造函数(不推荐)\n1var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);\n没有重载\n  将函数名理解为指针，就很容易理解为什么没有重载了。再次定义函数将覆盖之前定义的函数。\n1234567function addSomeNumber(num)&#123;  return num + 100;&#125;function addSomeNumber(num) &#123;  return num + 200;&#125;var result = addSomeNumber(100); //300\n等同于（将函数名理解为指针）：\n1234567var addSomeNumber = function (num)&#123; return num + 100;&#125;;addSomeNumber = function (num) &#123; return num + 200;&#125;;var result = addSomeNumber(100); //300\n函数声明与函数表达式\n先看例子：\n12345678910// 例1：正常执行alert(sum(1,1));function sum(num1, num2)&#123; return num1 + num2;&#125;// 例2：报错 unexpected identifieralert(sum2(1,1));var sum2 = function(num1, num2)&#123; return num1 + num2;&#125;;\n函数声明和函数表达式定义后的作用无区别，但解析器对函数声明和函数表达式并非一视同仁。解析器会先读取所有函数声明，并使这些函数在执行\n任何代码之前可用。至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释。例2中如果把var sum2表达式放在前面则就不会报错了。\n","plink":"https://blog.jschef.com/Learning/95bd22fa5cef/"},{"title":"ES6学习-数组","date":"2019-07-15T09:00:00.000Z","date_formatted":{"ll":"Jul 15, 2019","L":"07/15/2019","MM-DD":"07-15"},"updated":"2023-11-14T12:07:06.466Z","content":"数组创建\nArray.of()\n将所有参数转化生成数组。\n123Array.of(1, 2, 3, 4);  // [1,2,3,4]Array.of(1, &#x27;2&#x27;, true);  // [1,&#x27;2&#x27;,true]Array.of(); // []\nArray.from()\n将可迭代的类数组对象转为数组。\n1234Array.from([1, 2]; // [1, 2]Array.from([1, , 3]); // [1, undefined, 3]Array.from([1, 2, 3], (n) =&gt; n * 2); // [2, 4, 6]Array.from(&quot;abc&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n查找\nfind()\n查找数组中符合条件的元素，返回第一个元素。\n12let arr = [1, 2, 1, 3];arr.find(item =&gt; item &gt; 2); //3\nfindIndex()\n查找数组中符合条件的元素索引，返回第一个元素索引。\n12let arr = [1, 2, 1, 3];arr.findIndex(item =&gt; item = 1); //0\n遍历\nentries()\n123let entries = [&#x27;a&#x27;, &#x27;b&#x27;].entries();console.log(entries.next().value); // [0, &quot;a&quot;]console.log(entries.next().value); // [1, &quot;b&quot;]\nkeys()\n1[&#x27;a&#x27;, &#x27;b&#x27;].keys(); // [0, 1]\nvalues()\n1[&#x27;a&#x27;, &#x27;b&#x27;].values(); // [&quot;a&quot;, &quot;b&quot;]\n填充\nfill()\n将指定索引范围内数组元素替换为单个指定值\n\n参数1：用来填充的值\n参数2：被填充的起始索引\n参数3(可选)：被填充的结束索引，默认为数组末尾\n\n1234let arr = [1, 2, 3, 4];//fill(value,start[,end=length-1])arr.fill(9,1,2); // [1,9,3,4]arr.fill(8,1);  //[1,8,8,8]\ncopyWithin()\n将取指定范围的数据覆盖在从指定位置的数据上\n\n参数1：被修改的起始索引\n参数2：被用来覆盖的数据的起始索引\n参数3(可选)：被用来覆盖的数据的结束索引，默认为数组末尾\n\n123456789//将 3 取出来覆盖 索引1处的值arr = [1,2,3,4,5];arr.copyWithin(1,2,3); //[ 1, 3, 3, 4, 5 ]//将3,4,5取出来覆盖索引 1,2,3处的值let arr = [1,2,3,4,5];arr.copyWithin(1,2,5); //[ 1, 3, 4, 5, 5 ]//默认数组末尾 效果同上一例arr = [1,2,3,4,5];arr.copyWithin(1,2); //[ 1, 3, 4, 5, 5 ]\n其它\nincludes()\n数组是否包含指定值\n\n参数1：包含的指定值\n参数2：可选，搜索的起始索引，默认为0\n\n123[1, 2, 3].includes(1);    // true[1, 2, 3].includes(1, 2); // false[1, NaN, 3].includes(NaN); // true\nflat()\n嵌套数组转低维数组\n123456// 基本用法[1 ,[2, 3]].flat(); // [1, 2, 3]// 指定转换的嵌套层数[1, [2, [3, [4, 5]]]].flat(2); // [1, 2, 3, [4, 5]]// 不管嵌套多少层[1, [2, [3, [4, 5]]]].flat(Infinity); // [1, 2, 3, 4, 5]\nflatMap()\n先对数组中每个元素进行了的处理，再对数组执行 flat() 方法\n\n参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组\n参数2：指定遍历函数中 this 的指向\n\n1[1, 2, 3].flatMap(n =&gt; [n * 2]); // [2, 4, 6]\n扩展运算符…\n1234567let arr = [1, 2];//复制数组用法arr1 = [...arr]; // [1,2]//合并数组用法arr2 = [...arr,...arr1]; // [1,2,1,2]//嵌套数组arr2 = [...arr,arr1]; // [ 1, 2, [ 1, 2 ] ]\n","plink":"https://blog.jschef.com/Learning/4a5a66b21e29/"},{"title":"ES6学习-Symbol类型、字符串、Maps与Objects","date":"2019-07-15T02:41:00.000Z","date_formatted":{"ll":"Jul 15, 2019","L":"07/15/2019","MM-DD":"07-15"},"updated":"2023-11-14T12:07:06.466Z","content":"Symbol数据类型\nES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。独一无二的意思就是即使两个传入的key是一样，但Symbol(“abc”)是不等于Symbol(“abc”)的。\n12345let sy1 = Symbol(&quot;abc&quot;);let sy2 = Symbol(&quot;abc&quot;);console.log(sy1); //Symbol(abc)console.log(sy2); //Symbol(abc)console.log(sy1 == sy2); //false\n字符串\n  以前判断字符串中是否含子串是通过indexOf方法，ES6新增了几种：\n\nbool includes(Sring); 判断是否找到参数字符串；\nbool startsWith(String,[int]); 判断参数字符串是否在原字符串的头部；\nbool endsWith(String,[int]); 判断参数字符串是否在原字符串的尾部；\nString repeat(int); 将字符串重复指定次数返回；\nString padStart(int, String); 用参数字符串从原串的前面补全直至参数Int个数；\nString padEnd(int, String); 用参数字符串从原串的后面补全直至参数Int个数；\n模板字符串 `字符串内容或表达式` ：可以在字符串中加入变量或者表达式；\ni18n `字符串${变量}` ：自动将内容转国际化语言；\n\nMaps和Objects\n\nObject的键只能是字符串或者Symbols，但Map键可以是任意值；\nMap中的键值是有序的（FIFO先进先出原则），而对象中的键是无序的；\nMap中的键值对个数可通过size属性获取，而对象的键值对个数只能通过遍历计算；\n\n","plink":"https://blog.jschef.com/Learning/7d5b1eb5af6f/"},{"title":"ES6学习-变量常量的声明与解构赋值","date":"2019-07-08T03:05:00.000Z","date_formatted":{"ll":"Jul 8, 2019","L":"07/08/2019","MM-DD":"07-08"},"updated":"2023-11-14T12:07:06.466Z","content":"变量声明：let\n基本用法\n1let a = 123;  //let声明\n特点\n\n\n块内有效\n123456&#123;let a = 0;  // a块内有效：只能在该代码块内使用var b = 1;  // b全局有效：声明后可在任意地方使用&#125;a  // ReferenceError: a is not definedb  // 1\n\n\n不能重复声明\n123456let a = 1;  //let只能声明一次let a = 2;var b = 3;  //var可以多次声明var b = 4;a  // Identifier &#x27;a&#x27; has already been declaredb  // 4\n\n\n不存在变量提升\n12345console.log(a);  //ReferenceError: a is not definedlet a = 1;console.log(b);  //undefinedvar b = 2;\n\n变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined。\n变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。\n\n\n\n顶层对象\n1234var a = 1;window.a // 1let b = 1;window.b // undefined\n\nvar和function的全局声明会自动绑定到window或global对象，而let和const不会。\n\n\n\nlet与var案例\nlet很适合做循环变量\n123456789101112for (var i = 0; i &lt; 10; i++) &#123;  setTimeout(function()&#123;    console.log(i);  &#125;)&#125;// 输出十个 10for (let j = 0; j &lt; 10; j++) &#123;  setTimeout(function()&#123;    console.log(j);  &#125;)&#125;// 输出 0123456789\n\n\n变量 i 是用 var 声明的，在全局范围内有效，所以全局中只有一个变量 i, 每次循环时，setTimeout 定时器里面的 i 指的是全局变量 i ，而循环里的十个 setTimeout 是在循环结束后才执行，所以此时的 i 都是 10。\n\n\n变量 j 是用 let 声明的，当前的 j 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出12345。（若每次循环的变量 j 都是重新声明的，如何知道前一个循环的值？这是因为 JavaScript 引擎内部会记住前一个循环的值）。\n\n\n常量声明：const\n基本用法\n12const PI = &quot;3.1415926&quot;;const DIR;  // SyntaxError: Missing initializer in const declaration\n  const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。\n原理与注意事项\n  const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。\n解构赋值\n什么是解构赋值？\n  解构赋值是对赋值运算符的扩展,是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。\n类似数组写法的解构（Array）\n123456789101112131415161718192021222324252627282930313233let [a, b, c] = [1, 2, 3];  //基础用法// a = 1// b = 2// c = 3let [a, [[b], c]] = [1, [[2], 3]];  //嵌套解构// a = 1// b = 2// c = 3let [a, , b] = [1, 2, 3];  //忽略解构// a = 1// b = 3let [a = 1, b] = [];  //不完全解构// a = 1, b = undefinedlet [a, ...b] = [1, 2, 3]; //剩余运算符“...”：将余下的数据以数组形式全赋值给b//a = 1//b = [2, 3]let [a, b, c, d, e] = &#x27;hello&#x27;;//在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。// a = &#x27;h&#x27;// b = &#x27;e&#x27;// c = &#x27;l&#x27;// d = &#x27;l&#x27;// e = &#x27;o&#x27;let [a = 2] = [undefined]; //默认值解构// a = 2let [a = 3, b = a] = [];     // a = 3, b = 3let [a = 3, b = a] = [1];    // a = 1, b = 1let [a = 3, b = a] = [1, 2]; // a = 1, b = 2\n类似对象写法的解构（Object）\n12345678910111213141516171819202122232425262728293031323334//1.基本用法：按照属性名进行匹配赋值let &#123; foo, bar &#125; = &#123; bar: &#x27;bbb&#x27;, foo: &#x27;aaa&#x27; &#125;;// foo = &#x27;aaa&#x27;// bar = &#x27;bbb&#x27;let &#123; baz : foo &#125; = &#123; baz : &#x27;ddd&#x27; &#125;; //指定属性名匹配赋值// foo = &#x27;ddd&#x27;//2.可嵌套忽略（较少使用）let obj = &#123;p: [&#x27;hello&#x27;, &#123;y: &#x27;world&#x27;&#125;] &#125;;let &#123;p: [x, &#123; y &#125;] &#125; = obj;// x = &#x27;hello&#x27;// y = &#x27;world&#x27;let obj = &#123;p: [&#x27;hello&#x27;, &#123;y: &#x27;world&#x27;&#125;] &#125;;let &#123;p: [x, &#123;  &#125;] &#125; = obj;// x = &#x27;hello&#x27;//3.不完全解构（较少使用）let obj = &#123;p: [&#123;y: &#x27;world&#x27;&#125;] &#125;;let &#123;p: [&#123; y &#125;, x ] &#125; = obj;// x = undefined// y = &#x27;world&#x27;//4.剩余运算符：将余下的数据以对象形式赋值给restlet &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;;// a = 10// b = 20// rest = &#123;c: 30, d: 40&#125;//5.默认值解构let &#123;a = 10, b = 5&#125; = &#123;a: 3&#125;;// a = 3; b = 5;let &#123;a: aa = 10, b: bb = 5&#125; = &#123;a: 3&#125;;// aa = 3; bb = 5;\n写在最后\n  今天是实习第一天，上午就填完一些材料，就让自己学学。经理往群里发了java学习的资料，而我作为一个“前端开发实习生”，没有资料。那我就自己在菜鸟上看了看ES6吧\n","plink":"https://blog.jschef.com/Learning/90da1569d69e/"},{"title":"Spring MVC配置","date":"2019-04-01T14:01:00.000Z","date_formatted":{"ll":"Apr 1, 2019","L":"04/01/2019","MM-DD":"04-01"},"updated":"2023-11-14T12:07:06.466Z","content":"导入库\n\n首先新建一个Java Web项目，最后一步选择框架时，此步不选任何框架，点击完成；\n然后再新建的项目 “库” 上右键 添加库 ,找到其中的Spring Framework、Spring Web MVC 、JSTL进行添加，前两个Spring库版本号需要一致；\n\n网站设置\n\n在项目的 源包（src） 目录下, 新建Java类：ApplicationInitializer和AppConfig，包：conf，其中类名和包名都可以自己任意起；\n在实现WebApplicationInitializer 的类中对网站进行配置. 这种硬编码的配置方式可以通过编写web.xml进行替换掉, 也就是web.xml优先起作用.\n\nsrc/conf/ApplicationInitializer.java：\n1234567891011121314151617181920package conf;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletRegistration;import org.springframework.web.WebApplicationInitializer;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;import org.springframework.web.servlet.DispatcherServlet;public class ApplicationInitializer implements WebApplicationInitializer &#123;  //实现这个接口是关键, 与类名无关.    @Override    public void onStartup(ServletContext servletContext) throws ServletException &#123;        AnnotationConfigWebApplicationContext annotationConfigWebApplicationContext = new AnnotationConfigWebApplicationContext();        annotationConfigWebApplicationContext.register(AppConfig.class); //注册自己定义的AppConfig类.        annotationConfigWebApplicationContext.setServletContext(servletContext);        ServletRegistration.Dynamic servlet = servletContext.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(annotationConfigWebApplicationContext));        servlet.addMapping(&quot;/&quot;); //此Servlet负责处理(mapping)除了对Servlet/JSP外的所有(URL)访问        servlet.setLoadOnStartup(1); //第1个加载这个Servlet. 最先加载的是第0个.     &#125;&#125;\nsrc/conf/AppConfig.java：\n1234567891011121314151617181920212223package conf;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;import org.springframework.web.servlet.view.JstlView;@Configuration  //配置如下@EnableWebMvc   //允许使用springMVC@ComponentScan(basePackages = &#123;&quot;controller&quot;&#125;)  //扫描controller包中的组件(类)public class AppConfig extends WebMvcConfigurerAdapter &#123; //类名随意    @Bean  //下面的方法产生一个bean    public InternalResourceViewResolver createViewResolver() &#123; //方法名随意        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();        viewResolver.setPrefix(&quot;/WEB-INF/view/&quot;); //前缀        viewResolver.setSuffix(&quot;.jsp&quot;); //后缀        viewResolver.setViewClass(JstlView.class); //使用JSTL视图        return viewResolver;    &#125;&#125;\n\n对于index.html的请求, 返回的是index加上前后缀. 如上配置的前缀为/WEB-INF/view/, 后缀为.jsp. 最终的视图文件为/WEB-INF/view/index.jsp.\n\n控制器源程序\n\n在项目的src目录下, 创建Java源程序文件/controller/mainController.java\n\nsrc/controller/mainController.java：\n12345678910111213141516package controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class mainController &#123;    @RequestMapping(&quot;/index&quot;)    public String hello()&#123;        return &quot;index&quot;;    &#125;    @RequestMapping(&quot;/login&quot;)    public String login()&#123;        return &quot;login&quot;;    &#125;&#125;\n视图\n\n项目的web目录 /WEB-INF/view/ ，可由前面的AppConfig进行配置。在该目录下，创建index.jsp和login.jsp文件。\n\n/WEB-INF/view/index.jsp：\n123456789101112&lt;%@page contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;        &lt;title&gt;Index page&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;This is RequestMapping(&quot;/index&quot;) page!!!&lt;/h1&gt;        &lt;a href=&quot;login&quot;&gt;登录&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;\n/WEB-INF/view/login.jsp：\n123456789101112131415&lt;%@page contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;        &lt;title&gt;login page&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;This is RequestMapping(&quot;/login&quot;) page!!!&lt;/h1&gt;        &lt;center&gt;            账号：&lt;input type=&quot;text&quot;&gt;            密码：&lt;input type=&quot;text&quot;&gt;        &lt;/center&gt;    &lt;/body&gt;&lt;/html&gt;\n整体结构\n\nspringmvc项目必须添加spring framework的包. 此项目中AppConfig指定使用JSTL视图JstlView.class, 因此还需要添加JSTL的包。项目结构如下：\n\n\n运行结果\n\n暂时没有，因为我的tomcat服务器出问题了，我还没有解决。运行不出来呀，蓝瘦、、\n\n","plink":"https://blog.jschef.com/Learning/280ed29779d2/"},{"title":"Vue更新data后没有渲染html问题","date":"2019-01-02T03:19:00.000Z","date_formatted":{"ll":"Jan 2, 2019","L":"01/02/2019","MM-DD":"01-02"},"updated":"2023-11-14T12:07:06.466Z","content":"问题源码\n  这是我做课程设计时遇到的一个让我抓狂的问题，本来元旦三天的，我花了两天写前端。然后写完前端那天晚上就开始配置后端SSM框架，额，一直报错，找不到控制器controller，然后各种抓狂心态爆炸的去查这改那，知道第二天晚上（昨天晚上）在大佬 Hashq 帮我找到原因，缺少一个**@ Controller**。然后后端问题终于解决了嘛，我就怀着愉快的心情奋奋地想在昨天晚上多写点接口。但是！但是！我测试的时候，前端页面能获取到数据，但是就是没有渲染出来，具体代码如下：\nJavaScript:\n1234567891011121314151617new Vue(&#123;\t\t\tel: &quot;#vueroot&quot;,      //vue控制挂载点\t\t\tdata: &#123;       //数据\t\t\t\thotFlowers: []\t\t\t&#125;,\t\t\tmethods:&#123;\t\t\t\tgetHotFlowers:function () &#123;\t\t\t\t\t$.getJSON(&quot;getHotFlowers&quot;,function(data)&#123;\t\t\t\t\t\tthis.hotFlowers = data;\t\t\t\t\t&#125;)\t\t\t\t&#125;\t\t\t&#125;,\t\t\t//生命周期函数\t\t\tcreated:function()&#123;\t\t\t\tthis.$options.methods.getHotFlowers();\t\t\t&#125;\t\t&#125;)\nHtml:\n12345&lt;div class=&quot;bd-con-hot-item&quot; v-for=&quot;item in hotFlowers&quot; &gt;\t&lt;div class=&quot;bd-con-hot-item-pic&quot;&gt;&lt;img v-bind:src=&quot;[&#x27;img/flower/&#x27;+item.picture]&quot; /&gt;&lt;/div&gt;\t&lt;div class=&quot;bd-con-hot-item-name&quot;&gt;&lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt;&lt;/div&gt;\t&lt;div class=&quot;bd-con-hot-item-price&quot;&gt;&lt;span&gt;¥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;\n解决过程\n  然后就是死活就是渲染不出来，真是心态爆炸，我起先怀疑是json格式问题，我尝试了json.parse()；然后怀疑是vue的生命周期函数问题，我尝试了mounted,updated；问题还是没有解决，看网上有人像如下这样写：\n12345678 $.getJSON(&quot;getHotFlowers&quot;,function(data)&#123;\t new Vue(&#123;\t \tel: &quot;#vueroot&quot;,\t \tdata:&#123;\t\t hotFlowers : data\t \t&#125;\t &#125;)&#125;);\n  这样写就可以渲染出来，然后我就在想我原来的写法肯定没有将data更新成功，后来我想起了我写微信小程序的时候经常用var that = this，我好像有点思路了，本来对这个理解有点似懂非懂。然后我将代码改成：\n12345678//前面代码省略...//生命周期函数\tcreated:function()&#123;\t\tvar that = this;\t\t$.getJSON(&quot;getHotFlowers&quot;,function(data)&#123;\t\t\tthat.hotFlowers = data;\t\t&#125;);\t&#125;\n  竟然好使了，然后我就懂了，这次错误还是错在细节问题上。应该在vue实例里用的this作用域是整个vue实例，但是，如果是在其内部使用的方法中，再使用this，那个this是指代的那个具体方法，也就是内部this和外部this不是同一个指代。所以，我们要提前区分一下，通过将外部作用的this转移，也就是像我上面那样赋值给that进行转移。然后在内部函数中，that就代表vue实例，此时this就代表$.getJSON。既然问题解决了，我就重新再优化了一下代码，将获取后台数据的方法封装到methods里，然后通过传参that进行vue实例数据更新，详细实现如下：\n123456789101112131415161718new Vue(&#123;\t\t\tel: &quot;#vueroot&quot;,      //vue控制挂载点\t\t\tdata: &#123;       //数据\t\t\t\thotFlowers: []\t\t\t&#125;,\t\t\tmethods:&#123;\t\t\t\tgetHotFlowers:function (that) &#123;\t\t\t\t\t$.getJSON(&quot;getHotFlowers&quot;,function(data)&#123;\t\t\t\t\t\tthat.hotFlowers = data;\t\t\t\t\t&#125;)\t\t\t\t&#125;,\t\t\t&#125;,\t\t\t//生命周期函数\t\t\tcreated:function()&#123;\t\t\t\tvar that = this;\t\t\t\tthat.$options.methods.getHotFlowers(that);//传递that\t\t\t&#125;\t\t&#125;)\n总结\n  都是 细节 问题，本来很简单的问题，因为不熟悉，因为缺少经验，但经过撕心裂肺后，这就是经验，学习不止步。\n","plink":"https://blog.jschef.com/Learning/077017a6a342/"},{"title":"Vue.js学习笔记","date":"2018-12-28T12:25:00.000Z","date_formatted":{"ll":"Dec 28, 2018","L":"12/28/2018","MM-DD":"12-28"},"updated":"2023-11-14T12:07:06.466Z","content":"先话\n  因为这周Java Web课程设计，自己对原生js操作也不是很熟练，想着用一下这个强大的vue框架，让自己做的课设更快一点，并且给老师一种高大尚的感觉。所以今天考试完后，就花了3个多小时，看vue官网文档（还是国人出的框架文档看起来快），并结合慕课网和 Bug昊 大佬很久以前就给我的vue视频，把基本的使用学了，并总结出一份笔记，我觉得这些足够应对我现在的小型项目了。\n\n笔记在此，日后参考，也供大家参考\n\n干货笔记\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;   &lt;!-- 引入js --&gt;&lt;script src=&quot;./js/jquery.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;\t&lt;div v-on:click=&quot;handleClick&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;\t&lt;div @:click=&quot;handleClick&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;   &lt;!-- 缩写形式 --&gt;\t\t&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; css1 &#125;&quot;&gt;&lt;/div&gt;\t&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; css1 : isActive1 , &#x27;css2&#x27;: isActive2 &#125;&quot;&gt;&lt;/div&gt;\t&lt;div class=&quot;static&quot; :class=&quot;&#123; css1 : isActive1 , &#x27;css2&#x27;: isActive2 &#125;&quot;&gt;&lt;/div&gt;     &lt;!-- 缩写形式 --&gt;\t&lt;div class=&quot;static&quot; :class=&quot;[css1, css2]&quot;&gt;&lt;/div&gt;      &lt;!-- 数组形式 --&gt;\t&lt;div v-if=&quot;条件1&quot;&gt;A&lt;/div&gt;     &lt;!-- 条件判断是否显示 --&gt;\t&lt;div v-else-if=&quot;条件2&quot;&gt;B&lt;/div&gt;\t&lt;div v-else&gt;C&lt;/div&gt;\t\t&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;      &lt;!-- 可见控制 --&gt;\t&lt;li v-for=&quot;(item, index) in items&quot;&gt;&#123;&#123; index &#125;&#125; - &#123;&#123; item.aa &#125;&#125;&lt;/li&gt;     &lt;!-- 循环渲染，index不必要 --&gt;\t\t&lt;div v-for=&quot;(value, key, index) in object&quot;&gt;&#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;      &lt;!-- 渲染对象 --&gt;\t\t&lt;input type=&quot;text&quot; v-model=&quot;message&quot; &gt;               &lt;!-- v-model进行表单值获取 --&gt;\t&lt;input type=&quot;checkbox&quot;  value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; \t&lt;input type=&quot;checkbox&quot;  value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;\t&lt;input type=&quot;radio&quot;  value=&quot;One&quot; v-model=&quot;picked&quot;&gt;\t &lt;select v-model=&quot;selected&quot;&gt; ... &lt;/select&gt;\t&lt;select v-model=&quot;selected&quot;&gt;     &lt;!-- option循环渲染案例 --&gt;  \t\t&lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;\t&lt;/select&gt;&lt;/div&gt;&lt;script&gt;\tnew Vue(&#123;\t\tel: &quot;#root&quot;,      //vue控制挂载点\t\tdata: &#123;       //数据\t\t\tcontent : &quot;hello&quot;,\t\t\tisActive1 : true,\t\t\tisActive2 : false,\t\t\tcss1: &quot;css1name&quot;,\t\t\tcss2: &quot;css2name&quot;,\t\t\titems: [&#123;aa: &quot;value1&quot;&#125;, &#123;aa: &quot;value2&quot;&#125;],\t\t\tobject: &#123; firstName: &#x27;John&#x27;,  lastName: &#x27;Doe&#x27;, age: 30 &#125;,\t\t\t\t\t\tmessage: &quot;&quot;,\t\t\tcheckedNames: [ ],\t\t\tpicked: &quot;&quot;,\t\t\tselected: &quot;&quot;,\t\t\toptions: [ &#123; text: &#x27;One&#x27;, value: &#x27;A&#x27; &#125;,  &#123; text: &#x27;Two&#x27;, value: &#x27;B&#x27; &#125;,   &#123; text: &#x27;Three&#x27;, value: &#x27;C&#x27; &#125; ],\t\t&#125;,\t\t//方法集合，供其他调用：this.$options.methods.handleClick();\t\tmethods: &#123;  \t\t\thandleClick: function()&#123;\t\t\t\tthis.content = &quot;world&quot;\t\t\t&#125;,\t\t\tgetData:function () &#123;   //结合jquery进行ajax的get请求\t\t\t\t$.ajax(&#123;\t\t\t\t\turl: &quot;&quot;,\t\t\t\t\ttype: &#x27;get&#x27;,\t\t\t\t\tdataType:&quot;json&quot;,\t\t\t\t\tsuccess: function (data) &#123; ...data是已格式好的...  &#125;,\t\t\t\t\terror: function() &#123; ... &#125;,\t\t\t\t\tcomplete: function() &#123; ... &#125;\t\t\t\t&#125;)          \t\t\t&#125;,\t\t\tpostData:function () &#123;   //结合jquery进行ajax的post请求\t\t\t\t$.ajax(&#123;\t\t\t\t\turl: &quot;&quot;\t\t\t\t\ttype: &#x27;post&#x27;,\t\t\t\t\tdataType:&quot;json&quot;,\t\t\t\t\tsuccess: function (data) &#123; ... &#125;,\t\t\t\t\terror: function() &#123; ... &#125;,\t\t\t\t\tcomplete: function() &#123; ... &#125;\t\t\t\t&#125;)          \t\t\t&#125;,\t\t&#125;, \t\tcreated: function()&#123; this.$options.methods.getData(); //初始化完成调用methods内的函数 &#125;\t\t//生命周期函数\t\tbeforeCreate: function()&#123; ...实例创建前... &#125;,\t\tcreated: function()&#123; ...实例创建后... &#125;,\t\tbeforeMount: function()&#123; ...HTML渲染前... &#125;,\t\tmounted: function()&#123; ...HTML渲染后... &#125;,\t\tbeforeUpdate: function()&#123; ...data更新渲染前... &#125;,\t\tupdated: function()&#123; ...data更新渲染后... &#125;,\t\tbeforeDestroy: function()&#123; ...实例摧毁前... &#125;,\t\tdestroyed: function()&#123; ...实例摧毁后... &#125;,\t\t\t&#125;)&lt;/script&gt;\n","plink":"https://blog.jschef.com/Learning/bc07c5f099c1/"},{"title":"阿里云lnmp更换预装mysql遇到的坑","date":"2018-12-05T11:00:00.000Z","date_formatted":{"ll":"Dec 5, 2018","L":"12/05/2018","MM-DD":"12-05"},"updated":"2023-11-14T12:07:06.466Z","content":"坑1：MySQL server PID file could not be found!\n  这是阿里云轻应用服务器的一个坑，提示PID文件找不到。这是预装的lnmp的问题，他们修改了配置文件。我们需要重新修改一下，具体步骤如下：\nvim 打开 /etc/my.cnf\n修改其中的pid路径，具体路径在：\n/usr/local/mysql/data/阿里应用名.pid\n坑2：Can’t connect to local MySQL server…\n  提示：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ ，这个也是无法找到sock文件导致的。我找到那个目录，确实也没有发现.sock文件，sock丢失。具体解决方法如下：\n  先杀死所有mysqld进程，然后重新生成sock文件。最后再重启mysqld服务\n1234killall mysqld/usr/local/mysql/bin/mysql_install_db/usr/local/mysql/bin/mysqld_safe &amp;    service mysqld start\n","plink":"https://blog.jschef.com/Learning/fd412be05567/"},{"title":"阿里轻量云服务器ssl证书部署","date":"2018-09-18T15:19:40.000Z","date_formatted":{"ll":"Sep 18, 2018","L":"09/18/2018","MM-DD":"09-18"},"updated":"2023-11-14T12:07:06.466Z","content":"\n在阿里购买了一个免费的一年ssl证书，下载下来后按照阿里给的教程没有安装成功，之后自己在网上找的一个方法，这里做个记录一下。\n第一步，上传证书文件到服务器\n保存在/usr/local/apache/cert/目录下，cert目录是自己创建的，可以自己取其他名字。\n第二步，配置http-vhosts.conf文件\n12345678910ServerAdmin webmaster@serveradmin.com DocumentRoot &quot;/home/www/htdocs/dc&quot; ServerName 你的域名 SSLEngine on SSLProtocol all -SSLv2 -SSLv3 SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM SSLCertificateFile cert/public.pem #三个证书文件 SSLCertificateKeyFile cert/214*********453.key #三个证书文件 SSLCertificateChainFile cert/chain.pem #三个证书文件 ProxyPassMatch ^/(.*\\.php(/.*)?)$ unix:/home/www/logs/php-fpm.sock|fcgi://127.0.0.1/home/www/htdocs/dc/  \n\n注：重点是端口一定要把原来的80改为443。\n\n第三步、重启\n1apache /usr/local/apache/bin/apachectl restart","plink":"https://blog.jschef.com/Learning/d97b541a2c03/"},{"title":"前端小厨子","date":"2023-11-14T12:19:17.973Z","date_formatted":{"ll":"Nov 14, 2023","L":"11/14/2023","MM-DD":"11-14"},"updated":"2023-11-14T12:19:17.973Z","content":"\n  Hi, I'm Chef Wu 👨‍🌾 ,\n  a front-end development engineer.\n  I develop programs like a chef who treats delicacies, intently and creatively!\n\n我认为写程序就像做菜一样，主要食材（编程语言）+调味品（数据结构、算法、样式等），按照配方（实际业务场景），就可以做出一道菜（项目）。\n我是一名「前端小厨子👨‍🍳‍ 」，我会用心去做好每一份“菜”！\nDoing\n\nLooking for a good job\nReading\n背单词：从2021-12-06开始，坚持每天早上使用墨墨APP背20个单词\nRealize some creativity ideas\n\nAbout Me\n12345678910111213141516171819202122232425262728&#123;  name: &#x27;Chef Wu&#x27;  age: 26,  gender: &#x27;M&#x27;,  profession: &#x27;FE Developer&#x27;,  experience: &#x27;4年&#x27;,  address: &#x27;Chengdu, Sichuan, China&#x27;,  education: &#x27;Bachelor&#x27;,  github: &#x27;https://github.com/Chef5&#x27;,  blog: &#x27;https://blog.jschef.com&#x27;,  email: &#x27;nunet#qq.com&#x27;,  hobbies: [&#x27;Marathon&#x27;, &#x27;Fishing&#x27;, &#x27;OSU!&#x27;],  description: &#x27;喜欢think，有很多idea，乐于用代码去实现&#x27;,  skills: [    [&#x27;Javascript(ES5/ES6+)&#x27;, &#x27;TypeScript&#x27;],    [&#x27;Vue2/3&#x27;, &#x27;React&#x27;, &#x27;Nest&#x27;, &#x27;Ionic&#x27;],    [&#x27;Vite&#x27;, &#x27;Webpack&#x27;, &#x27;Gulp&#x27;],    [&#x27;Git&#x27;, &#x27;SVN&#x27;],    [&#x27;ECharts&#x27;, &#x27;Wechat app&#x27;],  ],  devTools: [    [&#x27;VS Code&#x27;, &#x27;Android Studio&#x27;, &#x27;Vim&#x27;],    [&#x27;Chrome DevTools&#x27;, &#x27;Cocos&#x27;],    [&#x27;Typora&#x27;, &#x27;XMind&#x27;, &#x27;Photoshops&#x27;],    [&#x27;Postman&#x27;, &#x27;Charles&#x27;],    [&#x27;Navicat&#x27;, &#x27;Permute&#x27;, &#x27;RDM&#x27;],  ]  &#125;\nCompanies\n2021.11–2023.07 小芄医药科技(成都)有限公司 研发中心|前端开发\n\n负责公司运营平台、管理平台的前端迭代开发，主要技术：Vue2;\n负责公司互联网医院医患微信小程序开发，主要技术：原生微信小程序;\n独立架构微信小程序通用组件库，支持文档自动生产，支持cli一键创建组件;\n\n2019.09–2021.10 北京思路创新科技有限公司 研发中心|前端开发\n\n参与移动端项目: 攀枝花生态云驾驶舱 APP、江西辐射 APP、青海党费管理公众号、四川目标管控 APP;\n负责大屏可视化项目: 重庆事权政务大屏、深圳大鹏新区生态环境大屏;\n指导实习生;\n\nProjects\nWorks-show: https://null.plus/#/works\n\nShare together and make progress together.\n","plink":"https://blog.jschef.com/about/"},{"title":"Links","date":"2023-11-14T12:07:06.607Z","date_formatted":{"ll":"Nov 14, 2023","L":"11/14/2023","MM-DD":"11-14"},"updated":"2023-11-14T12:07:06.607Z","content":"友情链接\n这里是友情链接，联系可以互换哦\n\n\nIk’s blog :  https://qiyanan.com/\n\n\nxt:  http://xtzero.me/\n\n\n学习链接\n这些是我正在或者曾经学习的网上资源\n\n可可英语：www.kekenet.com\nHCNA华为认证网络工程师培训 V2.2 - 华为培训认证\n[计蒜客](https://www.jisuanke.com/plan?object=参加算法与程序设计竞赛&amp;subobject=信息学竞赛 NOIP/NOI)\n牛客网（就业）： https://www.nowcoder.com/\n英语听力学习：https://www.youzack.com/\n洛谷（算法）：https://www.luogu.org/\nLaravel：https://qianjinyike.com/category/laravel/\nnode.js：https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040\n\n工具链接\n这些工具链接，先备在这里吧，以免找不到\n\n在线正则校验：http://reg.1zdz.cn/\n在线JSON校验：https://www.json.cn/\n在线Markdown: https://www.mdeditor.com/\nPDF工具：https://pdf.io/\n在线剪辑音频：https://mp3cut.net/\nTinyPNG – 压缩图片\n工具资源操作系统等下载：MSDN, 我告诉你\nColor Themes：http://color-themes.com/?view=index\nColor Hunt：https://colorhunt.co/\n谷歌插件下载： https://chrome-extension-downloader.com/\n\n资料链接\n\nCSS参考手册： http://css.doyoe.com/\nBuefy UI ：https://buefy.org/documentation/customization\nAll Standards and Drafts - W3C：https://www.w3.org/TR/\nsymfony： https://symfony.com/doc/current/index.html#gsc.tab=0\n\n作品链接\n\nSTS学习资讯平台：http://www.stsedu.cn/\n智能语音识别记账本：https://github.com/Chef5/AiBook-backEnd\n工大教务处：https://github.com/Chef5/miniDLPU-WechatProgram\n安递物流：https://github.com/Chef5/andiExpress-WechatProgram\n跑鸭（毕设）：https://github.com/Chef5/poprun\n跑鸭（后端）：https://github.com/Chef5/poprun-b\n\n","plink":"https://blog.jschef.com/links/"},{"title":"书单","date":"2021-02-18T00:00:00.000Z","date_formatted":{"ll":"Feb 18, 2021","L":"02/18/2021","MM-DD":"02-18"},"updated":"2023-11-14T12:07:06.466Z","content":"\n\n书名\n当前进度\n开始时间\n完成时间\n笔记\n\n\n\n\n《JavaScript高级程序设计》\n30%\n2019-07-10\n-\nJavaScript-函数问题JavaScript-数据操作JavaScript-对象创建 JavaScript-获取URL参数 JavaScript-事件\n\n\n《WebRTC音视频开发》\n100%\n2021-05-02\n2021-05-04\nWebRTC实践\n\n\n《极客与团队》\n100%\n2021-08-22\n2021-08-28\n-\n\n\n《深入浅出Vue.js》- 月影\n0%\n-\n-\n-\n\n\n《前端开发核心知识进阶》- 候策\n14%\n2021-12-11\n-\n-\n\n\n《你不知道的JavaScript(上卷)》\n2%\n2022-01-17\n-\n-\n\n\n《Practical Enterprise React》\n45%\n2022-04-25\n-\n-\n\n\n《Vue.js设计与实现》- 霍春阳\n100%\n2022-11-13\n2023-04-11\n-\n\n\n《前端函数式演进》\n13%\n2023-04-21\n-\n-\n\n\n","plink":"https://blog.jschef.com/booklist/"},{"title":"愿望清单","date":"2018-11-28T00:21:25.000Z","date_formatted":{"ll":"Nov 28, 2018","L":"11/28/2018","MM-DD":"11-28"},"updated":"2023-11-14T12:07:06.607Z","content":"个人小目标，努力努力再努力！\n\n\n愿望s\n许愿日期\n实现日期\n备注\n\n\n\n\n长10斤肉\n2018-11-28\n2019-04-08\n不知不觉长到124.3，开心\n\n\n跑一次全马\n2018-12-05\n2019-05-26\n鲅鱼圈全程马拉松5时21分完赛\n\n\n仿写一个游戏\n2019-03-11\n2021-02-03\n合成大西瓜，cocos\n\n\n卡片机SONY RX100 M6\n2019-05-29\n-\n-\n\n\n制作邻水三五反扑克牌游戏\n2020-01-26\n-\n-\n\n\n2020年参加大连或者成都马拉松\n2020-01-29\n-\n疫情影响\n\n\n学会一个人去看电影\n2020-02-06\n2020-07-26\n《多力特的奇幻冒险》\n\n\n学会一个人去吃自助\n2020-02-06\n2020-05-05\n为什么单人要加收10块钱？\n\n\n买一辆小摩托\n2020-03-28\n-\n-\n\n\n写2篇高质量原创（翻译）文章\n2021-01-10\n\n\n\n\n2021户外跑步600公里\n2021-01-10\n\n\n\n\n","plink":"https://blog.jschef.com/wishlist/"}]